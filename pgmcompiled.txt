; TEMPO DIALOG CONFIGURATION FILE
; Copyright 1997-2004 Reflective Computing.  All Rights Reserved.
; This file was created by TEMPO and should not be edited directly by the user.
; The commands in this file are undocumented and subject to change in future releases.
; Thu Sep 16 20:30:18 2004
; DLOAD all_pros.dcf

; DIALOGS

SCREENRES 1280,1024,32

DIAPAGE 0,"Info_and_StartClock"
DIAPOS   0,0,-1,-1,-1,-1,411,354,791,557,0
DIAOBJ   0,0,2,269,120,349,150,"OK","start;\r\ndpop Info_and_StartClock;"
DIAOBJ   0,3,1,17,14,243,157,"","ALL_PROS.pro     (F1)\r\n\r\nprotocol control structure\r\nand associated protocols\r\n\r\nwritten by\r\ndavid.c.godlove@vanderbilt.edu\r\nJanuary, 2011"

DIAPAGE 1,"Choose_Task"
DIAPOS   1,0,0,972,-1,-1,881,263,1252,874,1
DIAOBJ   1,0,2,190,66,339,96,"Countermanding","quiet State = 6;\r\ndshow countermanding;\r\ndpop Choose_Task"
DIAOBJ   1,1,1,20,12,166,62,"","Which task do you\r\nwant to run? (F2)"
DIAOBJ   1,2,2,270,538,350,562,"Exit","Exit"
DIAOBJ   1,3,2,175,538,255,562,"Stop Clock","stop"
DIAOBJ   1,4,2,10,109,159,139,"Visually Guided","quiet State = 2;\r\ndpop Choose_Task"
DIAOBJ   1,5,2,10,66,159,96,"Fixation","quiet State = 1;\r\ndialog Fixation_Main;\r\ndpop Choose_Task"
DIAOBJ   1,6,2,12,236,161,266,"Memory Guided","quiet State = 5;\r\ndshow Memory_guided;\r\ndpop Choose_Task"
DIAOBJ   1,7,2,190,110,339,140,"Choice Countermand","quiet State = 7;\r\ndshow choice_countermanding;\r\ndpop Choose_Task"
DIAOBJ   1,8,2,11,154,155,182,"Amplitude","quiet State = 3;\r\ndshow Amplitude_task;\r\ndpop Choose_Task"
DIAOBJ   1,9,2,11,277,152,302,"Go/No-go","quiet State = 8;\r\ndshow go_nogo;\r\ndpop Choose_Task"
DIAOBJ   1,10,2,12,196,158,223,"Delayed","quiet State = 4;\r\ndshow delayed_task;\r\ndpop Choose_Task"
DIAOBJ   1,11,2,192,196,336,221,"Choice CM Target","quiet State = 7;\r\ncheckerIsTarg = 1;\r\ndshow choice_countermanding;\r\ndpop Choose_Task"
DIAOBJ   1,13,2,196,241,324,263,"VWM","quiet State = 10;\r\ndshow VWM;\r\ndpop Choose_Task"

DIAPAGE 2,"mask_betting"
DIAPOS   2,0,-1,-1,-1,-1,817,72,1203,862,2
DIAOBJ   2,0,2,296,728,360,750,"Start","beginTaskFlag = 1; "
DIAOBJ   2,1,2,211,728,275,750,"Quit","dshow quit_check;\r\nDPOP"
DIAOBJ   2,2,2,118,730,191,749,"Update","DSET;"
DIAOBJ   2,3,2,21,729,96,750,"Pause","quiet Pause = 1;\r\ndialog Resume"
DIAOBJ   2,4,1,8,45,105,66,"","Mask Trial %"
DIAOBJ   2,5,1,8,79,105,100,"","Bet Trial %"
DIAOBJ   2,6,1,8,113,105,134,"","Retro Trial %"
DIAOBJ   2,7,1,8,148,105,168,"","ProTrial %"
DIAOBJ   2,8,1,116,16,244,38,"","Trial Distribution"
DIAOBJ   2,9,3,205,45,266,63,"","maskPct"
DIAOBJ   2,10,3,205,78,266,94,"","betPct"
DIAOBJ   2,11,3,205,109,266,131,"","retroPct"
DIAOBJ   2,12,3,205,146,266,168,"","proPct"
DIAOBJ   2,13,1,10,201,105,221,"","Target Amp"
DIAOBJ   2,14,5,119,199,182,220,"","ampDefault"
DIAOBJ   2,15,3,218,198,294,217,"","ampDefault"
DIAOBJ   2,16,1,8,229,109,249,"","Target 1 Angle"
DIAOBJ   2,17,5,120,113,170,134,"","retroPct"
DIAOBJ   2,18,5,119,259,182,277,"","maskAngleArray[1]"
DIAOBJ   2,19,5,120,149,170,168,"","proPct"
DIAOBJ   2,20,5,120,45,170,64,"","maskPct"
DIAOBJ   2,21,5,120,78,170,99,"","betPct"
DIAOBJ   2,22,5,119,229,182,250,"","maskAngleArray[0]"
DIAOBJ   2,23,3,218,229,294,247,"","maskAngleArray[0]"
DIAOBJ   2,24,5,119,287,182,308,"","maskAngleArray[2]"
DIAOBJ   2,25,5,119,320,182,337,"","maskAngleArray[3]"
DIAOBJ   2,26,3,218,318,294,340,"","maskAngleArray[3]"
DIAOBJ   2,27,3,218,288,294,310,"","maskAngleArray[2]"
DIAOBJ   2,28,3,218,259,294,276,"","maskAngleArray[1]"
DIAOBJ   2,29,1,7,257,107,274,"","Target 2 Angle"
DIAOBJ   2,30,1,8,287,112,305,"","Target 3 Angle"
DIAOBJ   2,31,1,11,321,111,340,"","Target 4 Angle"
DIAOBJ   2,32,1,13,395,108,414,"","Mask Window"
DIAOBJ   2,33,5,142,393,205,411,"","targWinSize"
DIAOBJ   2,34,3,263,393,308,409,"","targWinSize"
DIAOBJ   2,35,1,12,424,105,444,"","Bet Window"
DIAOBJ   2,36,5,142,425,205,444,"","betWinSize"
DIAOBJ   2,37,3,263,423,305,442,"","betWinSize"
DIAOBJ   2,38,1,11,480,123,501,"","Fake Correct Rate"
DIAOBJ   2,39,5,142,479,205,499,"","fakeCorrectRate"
DIAOBJ   2,40,3,263,481,310,500,"","fakeCorrectRate"
DIAOBJ   2,41,1,11,508,126,530,"","Target Right Rate"
DIAOBJ   2,42,5,142,505,205,527,"","targetRightRate"
DIAOBJ   2,43,3,263,508,306,526,"","targetRightRate"
DIAOBJ   2,44,1,11,536,139,558,"","High Bet Right Rate"
DIAOBJ   2,45,3,263,535,308,556,"","highBetRightRate"
DIAOBJ   2,46,5,142,534,205,554,"","highBetRightRate"
DIAOBJ   2,47,3,251,597,316,614,"","baseRewardDuration"
DIAOBJ   2,48,5,144,591,211,609,"","baseRewardDuration"
DIAOBJ   2,49,1,20,589,120,608,"","Reward time"
DIAOBJ   2,50,1,16,621,121,641,"","Timeout"
DIAOBJ   2,51,3,244,628,326,643,"","basePunishDuration"
DIAOBJ   2,52,5,145,625,215,641,"","basePunishDuration"
DIAOBJ   2,53,5,132,660,200,679,"","nTarg"
DIAOBJ   2,54,3,245,664,315,679,"","nTarg"
DIAOBJ   2,55,1,28,662,111,681,"","nTarg"
DIAOBJ   2,56,2,142,698,252,720,"Slow it down","intertrialDuration = 2500;"

DIAPAGE 3,"VWM"
DIAPOS   3,0,160,972,-1,-1,298,42,656,895,3
DIAOBJ   3,0,2,272,15,336,37,"OK","DSET; DPOP"
DIAOBJ   3,1,2,272,45,336,67,"Cancel","DPOP"
DIAOBJ   3,2,1,109,8,165,27,"","Duration"
DIAOBJ   3,3,1,9,61,91,82,"","memRefresh"
DIAOBJ   3,4,1,11,39,83,58,"","fixDuration"
DIAOBJ   3,5,5,112,40,165,62,"","fixDuration"
DIAOBJ   3,6,3,172,40,238,61,"","fixDuration"
DIAOBJ   3,7,5,111,66,164,88,"","memRefresh"
DIAOBJ   3,8,3,172,66,238,87,"","memRefresh"
DIAOBJ   3,9,1,11,91,94,112,"","retDuration"
DIAOBJ   3,10,5,111,92,164,114,"","retDuration"
DIAOBJ   3,11,3,172,92,238,113,"","retDuration"
DIAOBJ   3,12,1,11,118,93,139,"","testDuraton"
DIAOBJ   3,13,5,111,118,164,140,"","testDuration"
DIAOBJ   3,14,3,172,118,238,139,"","testDuration"
DIAOBJ   3,15,1,11,145,108,169,"","rewardDuration"
DIAOBJ   3,16,5,111,144,164,166,"","baseRewardDuration"
DIAOBJ   3,17,3,172,144,238,165,"","baseRewardDuration"
DIAOBJ   3,18,1,11,175,63,196,"","timeOut"
DIAOBJ   3,19,5,111,174,164,196,"","basePunishDuration"
DIAOBJ   3,20,3,172,173,238,194,"","basePunishDuration"
DIAOBJ   3,21,1,107,324,187,341,"","Trial Setting"
DIAOBJ   3,22,1,54,341,92,361,"","Same"
DIAOBJ   3,23,1,181,344,205,359,"","Diff"
DIAOBJ   3,24,1,15,367,41,386,"","SS1"
DIAOBJ   3,25,5,48,370,95,391,"","nTrialsArray[0]"
DIAOBJ   3,26,3,100,366,165,386,"","nTrialsArray[0]"
DIAOBJ   3,27,5,180,365,226,385,"","nTrialsArray[1]"
DIAOBJ   3,28,3,230,365,294,385,"","nTrialsArray[1]"
DIAOBJ   3,29,1,15,394,41,413,"","SS2"
DIAOBJ   3,30,5,48,396,95,417,"","nTrialsArray[2]"
DIAOBJ   3,31,3,100,392,165,412,"","nTrialsArray[2]"
DIAOBJ   3,32,5,180,392,226,412,"","nTrialsArray[3]"
DIAOBJ   3,33,3,230,392,294,412,"","nTrialsArray[3]"
DIAOBJ   3,34,1,15,421,41,440,"","SS3"
DIAOBJ   3,35,1,15,448,41,467,"","SS4"
DIAOBJ   3,36,1,15,475,41,494,"","SS5"
DIAOBJ   3,37,1,15,506,41,525,"","SS6"
DIAOBJ   3,38,5,48,422,95,443,"","nTrialsArray[4]"
DIAOBJ   3,39,5,48,448,95,469,"","nTrialsArray[6]"
DIAOBJ   3,40,5,48,474,95,495,"","nTrialsArray[8]"
DIAOBJ   3,41,5,48,503,95,524,"","nTrialsArray[10]"
DIAOBJ   3,42,3,100,418,165,438,"","nTrialsArray[4]"
DIAOBJ   3,43,3,100,444,165,464,"","nTrialsArray[6]"
DIAOBJ   3,44,3,100,470,165,490,"","nTrialsArray[8]"
DIAOBJ   3,45,3,100,500,165,520,"","nTrialsArray[10]"
DIAOBJ   3,46,5,180,419,226,439,"","nTrialsArray[5]"
DIAOBJ   3,47,5,180,446,226,466,"","nTrialsArray[7]"
DIAOBJ   3,48,5,180,473,226,493,"","nTrialsArray[9]"
DIAOBJ   3,49,5,180,500,226,520,"","nTrialsArray[11]"
DIAOBJ   3,50,3,230,419,294,439,"","nTrialsArray[5]"
DIAOBJ   3,51,3,230,446,294,466,"","nTrialsArray[7]"
DIAOBJ   3,52,3,230,473,294,493,"","nTrialsArray[9]"
DIAOBJ   3,53,3,230,501,294,521,"","nTrialsArray[11]"
DIAOBJ   3,54,2,11,549,84,571,"Pause","quiet Pause = 1;\r\ndialog Resume"
DIAOBJ   3,55,2,96,549,169,571,"Update","dset;"
DIAOBJ   3,56,2,181,549,254,571,"Quit","dialog Quit_Check;\r\ndpop;"
DIAOBJ   3,57,2,266,549,339,571,"Start","beginTaskFlag = 1;\r\nDSET;"
DIAOBJ   3,58,1,128,586,209,607,"","Performance"
DIAOBJ   3,59,1,4,527,132,549,"","Text Field"
DIAOBJ   3,60,1,106,232,188,251,"","WindowSize"
DIAOBJ   3,61,1,6,266,73,285,"","fixwinsize"
DIAOBJ   3,62,1,6,294,82,313,"","targwinsize"
DIAOBJ   3,63,1,12,202,96,220,"","targholdtime"
DIAOBJ   3,64,5,111,201,165,223,"","targholdtime"
DIAOBJ   3,65,3,172,202,238,223,"","targholdtime"
DIAOBJ   3,66,5,114,264,163,285,"","fixwinsize"
DIAOBJ   3,67,3,193,267,260,289,"","fixwinsize"
DIAOBJ   3,68,5,115,292,164,314,"","targwinsize"
DIAOBJ   3,69,3,197,293,262,313,"","targwinsize"
DIAOBJ   3,70,1,20,631,50,651,"","SS1"
DIAOBJ   3,71,1,20,658,50,678,"","SS2"
DIAOBJ   3,72,1,20,685,50,705,"","SS3"
DIAOBJ   3,73,1,20,712,50,732,"","SS4"
DIAOBJ   3,74,3,57,633,124,654,"","vwm_performance[0]"
DIAOBJ   3,75,3,130,631,197,652,"","vwm_performance[6]"
DIAOBJ   3,76,3,203,631,270,652,"","vwm_performance[12]"
DIAOBJ   3,77,3,275,632,342,653,"","vwm_performance[18]"
DIAOBJ   3,78,3,57,656,124,677,"","vwm_performance[1]"
DIAOBJ   3,79,3,57,684,124,705,"","vwm_performance[2]"
DIAOBJ   3,80,3,57,711,124,732,"","vwm_performance[3]"
DIAOBJ   3,81,3,203,655,270,676,"","vwm_performance[13]"
DIAOBJ   3,82,3,130,684,197,705,"","vwm_performance[8]"
DIAOBJ   3,83,3,130,711,197,732,"","vwm_performance[9]"
DIAOBJ   3,84,3,130,655,197,676,"","vwm_performance[7]"
DIAOBJ   3,85,3,203,682,270,703,"","vwm_performance[14]"
DIAOBJ   3,86,3,203,708,270,729,"","vwm_performance[15]"
DIAOBJ   3,87,3,275,655,342,676,"","vwm_performance[19]"
DIAOBJ   3,88,3,274,680,341,701,"","vwm_performance[20]"
DIAOBJ   3,89,3,276,708,343,729,"","vwm_performance[21]"
DIAOBJ   3,90,1,20,739,52,760,"","SS5"
DIAOBJ   3,91,1,22,769,51,793,"","SS6"
DIAOBJ   3,92,3,54,738,122,759,"","vwm_performance[4]"
DIAOBJ   3,93,3,53,768,121,788,"","vwm_performance[5]"
DIAOBJ   3,94,3,127,735,196,753,"","vwm_performance[10]"
DIAOBJ   3,95,3,128,766,198,787,"","vwm_performance[11]"
DIAOBJ   3,96,3,203,733,274,752,"","vwm_performance[16]"
DIAOBJ   3,97,3,198,763,269,784,"","vwm_performance[17]"
DIAOBJ   3,98,3,271,732,340,752,"","vwm_performance[22]"
DIAOBJ   3,99,3,281,762,340,782,"","vwm_performance[23]"

DIAPAGE 13,"Quit_Check"
DIAPOS   13,0,-1,-1,-1,-1,431,452,791,632,13
DIAOBJ   13,0,2,233,119,345,141,"Quit Task","quiet state = 0;\r\nDPOP Fixation_Main;\r\nDPOP;\r\n"
DIAOBJ   13,1,2,110,119,222,141,"Don't Quit","DPOP"
DIAOBJ   13,2,1,8,15,218,79,"","QUIT TASK\r\n\r\nAre you sure you want to quit?"

DIAPAGE 14,"Fixation_Main"
DIAPOS   14,0,-1,-1,-1,-1,687,617,1037,901,14
DIAOBJ   14,0,2,116,229,180,250,"Start","quiet beginTaskFlag = 1;"
DIAOBJ   14,1,2,195,229,259,250,"Quit","dialog Quit_Check;"
DIAOBJ   14,2,1,6,65,134,87,"","Reward duration"
DIAOBJ   14,3,1,6,97,134,119,"","Tone frequency"
DIAOBJ   14,4,1,6,129,134,151,"","Target window targSize"
DIAOBJ   14,5,1,3,190,131,212,"","Inter-trial interval"
DIAOBJ   14,6,1,6,161,134,183,"","Hold fixation time"
DIAOBJ   14,7,2,271,228,335,249,"Apply","DSET"
DIAOBJ   14,8,5,144,126,211,148,"","targWinSize"
DIAOBJ   14,9,5,144,158,211,180,"","targHoldtime"
DIAOBJ   14,10,5,144,190,211,212,"","interTrialDuration"
DIAOBJ   14,11,5,144,62,211,84,"","baseRewardDuration"
DIAOBJ   14,12,5,144,94,211,116,"","Success_Tone_medR"
DIAOBJ   14,13,3,257,131,324,149,"","targWinSize"
DIAOBJ   14,14,3,257,163,324,181,"","targHoldtime"
DIAOBJ   14,15,3,257,195,324,213,"","interTrialDuration"
DIAOBJ   14,16,3,257,67,324,85,"","baseRewardDuration"
DIAOBJ   14,17,3,257,99,324,117,"","Success_Tone_medR"
DIAOBJ   14,18,1,115,8,243,41,"","Set fixation task\r\nvariables"
DIAOBJ   14,19,1,251,11,295,33,"","(F3)"

DIAPAGE 15,"Resume"
DIAPOS   15,0,-1,-1,-1,-1,512,377,694,513,15
DIAOBJ   15,0,1,35,22,148,50,"","Task is paused."
DIAOBJ   15,1,2,53,63,117,85,"Resume","quiet Pause = 0;\r\nDPOP"

DIAPAGE 16,"Select_Monkey"
DIAPOS   16,0,-1,-1,-1,-1,884,264,1235,618,16
DIAOBJ   16,0,2,121,245,185,267,"OK","DPOP"
DIAOBJ   16,1,2,13,149,138,185,"Default","quiet setMonkey = 1;\r\ndpop"
DIAOBJ   16,2,2,11,70,139,104,"Euler","quiet Monkey = 4;\r\nquiet setMonkey = 1;\r\ndpop"
DIAOBJ   16,4,2,210,280,335,316,"Xena","quiet Monkey = 1;\r\nquiet setMonkey = 1;\r\ndpop"
DIAOBJ   16,5,2,10,11,135,47,"Broca","quiet Monkey = 2;\r\nquiet setMonkey = 1;\r\ndpop"

DIAPAGE 17,"Memory_guided"
DIAPOS   17,0,-1,-1,-1,-1,752,276,1130,729,17
DIAOBJ   17,0,2,295,396,359,418,"Start","beginTaskFlag = 1;\r\nDSET;"
DIAOBJ   17,1,2,207,394,271,416,"Quit","dialog Quit_Check;\r\ndpop;"
DIAOBJ   17,2,5,124,36,207,58,"","ampDefault"
DIAOBJ   17,3,5,127,192,207,212,"","baseRewardDuration"
DIAOBJ   17,4,3,205,37,333,59,"","ampDefault"
DIAOBJ   17,5,3,209,188,337,210,"","baseRewardDuration"
DIAOBJ   17,6,1,16,38,119,59,"","Eccentricity"
DIAOBJ   17,7,1,10,194,113,215,"","Reward Time"
DIAOBJ   17,8,2,108,396,192,417,"Update","dset;"
DIAOBJ   17,9,5,124,125,210,146,"","targWinSize"
DIAOBJ   17,10,1,10,123,117,144,"","Target Window"
DIAOBJ   17,11,3,225,123,328,143,"","targWinSize"
DIAOBJ   17,12,5,124,157,209,179,"","fixWinSize"
DIAOBJ   17,13,1,6,156,98,177,"","Fix Window"
DIAOBJ   17,14,3,238,153,326,174,"","fixWinSize"
DIAOBJ   17,15,3,239,222,336,245,"","basePunishDuration"
DIAOBJ   17,16,5,132,225,223,246,"","basePunishDuration"
DIAOBJ   17,17,1,16,225,101,246,"","Timeout"
DIAOBJ   17,18,2,7,397,96,419,"Pause","quiet Pause = 1;\r\ndialog Resume"
DIAOBJ   17,19,3,136,328,214,345,"","nTrialRemain"
DIAOBJ   17,20,5,143,298,211,320,"","nTrialPerTarget"
DIAOBJ   17,21,1,8,298,136,320,"","Trials Per Target"
DIAOBJ   17,22,1,7,323,135,345,"","Trials Remaining"
DIAOBJ   17,23,4,129,63,204,85,"","angleArray[0]"
DIAOBJ   17,24,1,4,62,117,85,"","Right Targ Angle"
DIAOBJ   17,25,3,208,61,336,83,"","angleArray[0]"
DIAOBJ   17,26,2,105,357,233,379,"180","angleArray[1] = angleArray[0] + 180;\r\nampArray[1] = ampArray[0];"
DIAOBJ   17,27,3,261,90,336,105,"","angleArray[1]"
DIAOBJ   17,28,5,125,92,217,113,"","angleArray[1]"
DIAOBJ   17,29,1,11,92,117,109,"","Left Targ Angle"
DIAOBJ   17,30,3,261,258,354,277,"","interTrialDuration"
DIAOBJ   17,31,5,141,257,230,278,"","interTrialDuration"
DIAOBJ   17,32,1,4,257,132,279,"","interTrialDuration"

DIAPAGE 18,"choice_countermanding"
DIAPOS   18,0,0,972,-1,-1,838,0,1283,971,18
DIAOBJ   18,0,2,326,916,390,938,"Start","beginTaskFlag = 1;\r\n"
DIAOBJ   18,1,2,236,916,300,938,"Quit","dshow quit_check;\r\nDPOP"
DIAOBJ   18,2,1,19,522,179,540,"","Right Targ Square Prop."
DIAOBJ   18,3,5,12,549,68,571,"","targ1PropArray[0]"
DIAOBJ   18,4,5,12,581,68,603,"","targ1PropArray[1]"
DIAOBJ   18,5,5,13,611,69,633,"","targ1PropArray[2]"
DIAOBJ   18,6,5,14,644,70,666,"","targ1PropArray[3]"
DIAOBJ   18,7,5,17,675,73,697,"","targ1PropArray[4]"
DIAOBJ   18,8,5,16,702,72,724,"","targ1PropArray[5]"
DIAOBJ   18,9,5,18,731,74,753,"","targ1PropArray[6]"
DIAOBJ   18,10,5,17,760,73,782,"","targ1PropArray[7]"
DIAOBJ   18,11,5,18,788,74,810,"","targ1PropArray[8]"
DIAOBJ   18,12,5,18,819,74,841,"","targ1PropArray[9]"
DIAOBJ   18,13,1,219,521,380,540,"","SSDs (Sreen Refreshes)"
DIAOBJ   18,14,5,217,550,272,569,"","ssdArray[0]"
DIAOBJ   18,15,5,221,582,276,601,"","ssdArray[1]"
DIAOBJ   18,16,5,220,612,275,631,"","ssdArray[2]"
DIAOBJ   18,17,5,214,645,269,664,"","ssdArray[3]"
DIAOBJ   18,18,5,217,676,272,695,"","ssdArray[4]"
DIAOBJ   18,19,5,216,703,271,722,"","ssdArray[5]"
DIAOBJ   18,20,5,218,732,273,751,"","ssdArray[6]"
DIAOBJ   18,21,5,217,761,272,780,"","ssdArray[7]"
DIAOBJ   18,22,5,218,789,273,808,"","ssdArray[8]"
DIAOBJ   18,23,5,218,820,273,839,"","ssdArray[9]"
DIAOBJ   18,24,3,98,552,171,567,"","targ1PropArray[0]"
DIAOBJ   18,25,3,102,582,175,599,"","targ1PropArray[1]"
DIAOBJ   18,26,3,101,612,174,629,"","targ1PropArray[2]"
DIAOBJ   18,27,3,95,645,168,662,"","targ1PropArray[3]"
DIAOBJ   18,28,3,98,676,171,693,"","targ1PropArray[4]"
DIAOBJ   18,29,3,97,703,170,720,"","targ1PropArray[5]"
DIAOBJ   18,30,3,99,732,172,749,"","targ1PropArray[6]"
DIAOBJ   18,31,3,98,761,171,778,"","targ1PropArray[7]"
DIAOBJ   18,32,3,99,789,172,806,"","targ1PropArray[8]"
DIAOBJ   18,33,3,99,821,172,838,"","targ1PropArray[9]"
DIAOBJ   18,34,2,123,919,209,940,"Update","DSET;\r\ngoPct = 100 - stopPct;"
DIAOBJ   18,35,3,278,552,379,567,"","ssdArray[0]"
DIAOBJ   18,36,3,282,584,383,599,"","ssdArray[1]"
DIAOBJ   18,37,3,281,614,382,629,"","ssdArray[2]"
DIAOBJ   18,38,3,275,647,376,662,"","ssdArray[3]"
DIAOBJ   18,39,3,278,678,379,693,"","ssdArray[4]"
DIAOBJ   18,40,3,277,705,378,720,"","ssdArray[5]"
DIAOBJ   18,41,3,279,734,380,749,"","ssdArray[6]"
DIAOBJ   18,42,3,278,763,379,778,"","ssdArray[7]"
DIAOBJ   18,43,3,279,791,380,806,"","ssdArray[8]"
DIAOBJ   18,44,3,279,822,380,837,"","ssdArray[9]"
DIAOBJ   18,45,1,4,238,166,260,"","CHECKER STIMULUS:"
DIAOBJ   18,46,3,119,263,184,283,"","checkerWidthDegrees"
DIAOBJ   18,47,3,316,264,381,285,"","checkerHeightDegrees"
DIAOBJ   18,48,3,251,293,332,308,"","iSquareSizePixels"
DIAOBJ   18,49,5,163,289,228,308,"","iSquareSizePixels"
DIAOBJ   18,50,1,11,288,139,310,"","Squares pixel width"
DIAOBJ   18,51,5,163,319,228,338,"","checkerAmp"
DIAOBJ   18,52,3,251,323,332,338,"","checkerAmp"
DIAOBJ   18,53,1,11,318,139,340,"","Chekcer stim Eccent"
DIAOBJ   18,54,1,11,349,139,371,"","Chekcer stim Angle"
DIAOBJ   18,55,5,163,350,228,369,"","checkerAngle"
DIAOBJ   18,56,3,251,354,332,369,"","checkerAngle"
DIAOBJ   18,57,1,3,5,131,27,"","TARGETS:"
DIAOBJ   18,58,1,6,29,73,50,"","Amp 1"
DIAOBJ   18,59,3,336,36,414,55,"","ampArray[0]\r\n"
DIAOBJ   18,60,5,270,35,333,53,"","ampArray[0]"
DIAOBJ   18,61,1,7,57,75,80,"","Angle 1"
DIAOBJ   18,62,5,271,58,334,76,"","angleArray[0]"
DIAOBJ   18,63,3,337,59,415,78,"","angleArray[0]"
DIAOBJ   18,64,1,12,263,101,283,"","Width (deg.)"
DIAOBJ   18,65,1,209,264,298,285,"","Height (deg.)"
DIAOBJ   18,66,4,163,381,228,399,"","chkrWinSize"
DIAOBJ   18,67,1,12,380,140,402,"","Checker Window"
DIAOBJ   18,68,1,87,149,171,170,"","Targ Window"
DIAOBJ   18,69,5,176,152,239,170,"","targWinSize"
DIAOBJ   18,70,5,178,213,243,231,"","fixWinSize"
DIAOBJ   18,71,1,79,212,175,233,"","Fix Window"
DIAOBJ   18,72,3,237,152,315,173,"","targWinSize"
DIAOBJ   18,73,3,247,213,325,235,"","fixWinSize"
DIAOBJ   18,74,3,204,381,332,403,"","chkrWinSize"
DIAOBJ   18,75,2,9,918,98,939,"Pause","quiet Pause = 1;\r\ndialog Resume"
DIAOBJ   18,76,5,151,413,229,431,"","baseRewardDuration"
DIAOBJ   18,77,3,252,413,340,430,"","baseRewardDuration"
DIAOBJ   18,78,1,15,415,113,437,"","Reward Time"
DIAOBJ   18,79,1,13,440,141,462,"","Timeout"
DIAOBJ   18,80,5,153,437,230,452,"","basePunishDuration"
DIAOBJ   18,81,3,246,438,337,453,"","basePunishDuration"
DIAOBJ   18,82,5,97,32,159,49,"","ampArray[1]"
DIAOBJ   18,83,3,178,32,256,48,"","ampArray[1]"
DIAOBJ   18,84,1,3,89,77,111,"","Amp 2"
DIAOBJ   18,85,5,96,57,164,76,"","angleArray[1]"
DIAOBJ   18,86,3,175,59,253,75,"","angleArray[1]"
DIAOBJ   18,87,1,3,114,80,135,"","Angle 2"
DIAOBJ   18,88,2,81,884,132,903,"180","angleArray[1] = angleArray[0] + 180;\r\nampArray[1] = ampArray[0];\r\ncheckerAngle = angleArray[0] + 90;"
DIAOBJ   18,89,5,208,491,263,511,"","stopPct"
DIAOBJ   18,90,1,82,494,210,516,"","Stop Trial Percent"
DIAOBJ   18,91,3,317,491,366,508,"","stopPct"
DIAOBJ   18,92,3,258,182,320,197,"","targetRightRate"
DIAOBJ   18,93,5,181,182,248,197,"","targetRightRate"
DIAOBJ   18,94,1,43,181,171,203,"","Right Target Proportion"
DIAOBJ   18,95,3,272,856,344,878,"","ccmDelayFlag"
DIAOBJ   18,96,5,193,854,266,874,"","ccmDelayFlag"
DIAOBJ   18,97,2,57,854,185,876,"Delay Version?","ccmDelayFlag = 1;"
DIAOBJ   18,98,1,305,8,366,28,"","Right"
DIAOBJ   18,99,1,149,7,196,24,"","Left"
DIAOBJ   18,100,2,142,885,234,905,"4 Targ 180","angleArray[1] = angleArray[0] + 180;\r\nampArray[1] = ampArray[0];\r\nangleArray[3] = angleArray[2] + 180;\r\nampArray[3] = ampArray[2];\r\n"
DIAOBJ   18,101,5,92,91,154,108,"","ampArray[3]"
DIAOBJ   18,102,3,181,93,250,113,"","ampArray[3]"
DIAOBJ   18,103,5,271,92,335,110,"","ampArray[2]"
DIAOBJ   18,104,3,346,91,414,111,"","ampArray[2]"
DIAOBJ   18,105,5,93,113,150,131,"","angleArray[3]"
DIAOBJ   18,106,3,176,113,249,129,"","angleArray[3]"
DIAOBJ   18,107,5,271,119,332,134,"","angleArray[2]"
DIAOBJ   18,108,3,345,118,420,135,"","angleArray[2]"
DIAOBJ   18,109,2,287,881,415,903,"4 TARGETS","nTarg = 4;\r\nsizeArray[2] = sizeArray[0];\r\nsizeArray[3] = sizeArray[0];\r\nangleArray[0] = 20\r\nangleArray[1] = 200;\r\nangleArray[2] = -20;\r\nangleArray[3] = 160;\r\n"
DIAOBJ   18,110,5,150,463,228,478,"","intertrialDuration\r\n"
DIAOBJ   18,111,3,265,460,343,477,"","intertrialDuration"
DIAOBJ   18,112,1,6,460,134,482,"","intertrialDuration"

DIAPAGE 19,"Amplitude_task"
DIAPOS   19,0,-1,-1,-1,-1,810,469,1146,755,19
DIAOBJ   19,0,2,188,232,252,254,"Start","beginTaskFlag = 1;\r\nDSET;"
DIAOBJ   19,1,2,115,232,179,254,"Quit","dshow quit_check;\r\nDPOP"
DIAOBJ   19,2,4,44,88,107,109,"","angleArray[0]"
DIAOBJ   19,3,1,2,90,61,108,"","Angle"
DIAOBJ   19,4,3,173,91,207,106,"","angleArray[0]"
DIAOBJ   19,5,2,52,13,180,35,"Turn ON Auto-targSize","autoTargetSizeFlag = 1;"
DIAOBJ   19,6,2,52,43,180,65,"Turn OFF Auto-szie","autoTargetSizeFlag = 0;"
DIAOBJ   19,7,2,40,232,106,254,"Update","spawn GOODVARS;\r\ndset;"
DIAOBJ   19,8,3,143,181,229,200,"","nTrialRemain"
DIAOBJ   19,9,5,160,152,231,171,"","nTrialPerTarget"
DIAOBJ   19,10,1,11,151,139,173,"","Trials Per Target"
DIAOBJ   19,11,1,11,177,139,199,"","Trials Remaining"

DIAPAGE 20,"go_nogo"
DIAPOS   20,0,-1,-1,-1,-1,730,125,1142,882,20
DIAOBJ   20,0,2,308,699,372,721,"Start","beginTaskFlag = 1;\r\ndset;"
DIAOBJ   20,1,2,16,701,92,723,"Quit Task","dialog Quit_Check"
DIAOBJ   20,2,2,190,701,299,722,"Update","DSET;\r\nangleArray[1] = angleArray[0] + 180;\r\nnTrialArray[1] = ampArray[0];"
DIAOBJ   20,3,1,6,34,141,54,"","Target Eccentricity"
DIAOBJ   20,4,3,263,33,347,51,"","ampDefault"
DIAOBJ   20,5,5,166,34,250,53,"","ampDefault\r\n"
DIAOBJ   20,6,1,11,62,139,84,"","Right Target Angle"
DIAOBJ   20,7,5,166,67,250,86,"","angleArray[0]"
DIAOBJ   20,8,3,263,66,347,84,"","angleArray[0]"
DIAOBJ   20,9,3,263,132,347,150,"","targWinSize"
DIAOBJ   20,10,5,166,133,250,152,"","targWinSize"
DIAOBJ   20,11,1,13,119,141,141,"","Target Window"
DIAOBJ   20,12,1,9,150,137,172,"","Fixation Window"
DIAOBJ   20,13,5,166,166,250,185,"","fixWinSize"
DIAOBJ   20,14,3,263,165,347,183,"","fixWinSize"
DIAOBJ   20,15,1,8,300,233,325,"","Go Square Proportions"
DIAOBJ   20,16,5,4,339,132,361,"","goPropArray[0]"
DIAOBJ   20,17,5,4,373,132,395,"","goPropArray[1]"
DIAOBJ   20,18,5,3,405,131,427,"","goPropArray[2]"
DIAOBJ   20,19,5,3,436,131,458,"","goPropArray[3]"
DIAOBJ   20,20,5,6,470,134,492,"","goPropArray[4]"
DIAOBJ   20,21,5,6,505,134,527,"","goPropArray[5]"
DIAOBJ   20,22,5,4,537,132,559,"","goPropArray[6]"
DIAOBJ   20,23,5,5,570,133,592,"","goPropArray[7]"
DIAOBJ   20,24,5,6,601,134,623,"","goPropArray[8]"
DIAOBJ   20,25,5,4,636,132,658,"","goPropArray[9]"
DIAOBJ   20,26,3,146,341,274,363,"","goPropArray[0]"
DIAOBJ   20,27,3,145,373,273,395,"","goPropArray[1]"
DIAOBJ   20,28,3,139,404,267,426,"","goPropArray[2]"
DIAOBJ   20,29,3,140,437,268,459,"","goPropArray[3]"
DIAOBJ   20,30,3,136,471,264,493,"","goPropArray[4]"
DIAOBJ   20,31,3,135,505,263,527,"","goPropArray[5]"
DIAOBJ   20,32,3,139,537,267,559,"","goPropArray[6]"
DIAOBJ   20,33,3,133,570,261,592,"","goPropArray[7]"
DIAOBJ   20,34,3,134,601,262,623,"","goPropArray[8]"
DIAOBJ   20,35,3,135,636,263,658,"","goPropArray[9]"
DIAOBJ   20,36,3,263,198,347,216,"","baseRewardDuration"
DIAOBJ   20,37,5,166,199,250,218,"","baseRewardDuration"
DIAOBJ   20,38,1,6,192,118,212,"","Reward Time"
DIAOBJ   20,39,3,263,231,347,249,"","basePunishDuration"
DIAOBJ   20,40,5,166,232,250,251,"","basePunishDuration"
DIAOBJ   20,41,1,9,231,137,253,"","Timeout time"
DIAOBJ   20,42,2,99,702,184,723,"Pause","quiet Pause = 1;\r\ndialog Resume"
DIAOBJ   20,43,5,166,270,250,289,"","iSquareSizePixels"
DIAOBJ   20,44,3,263,270,347,288,"","iSquareSizePixels"
DIAOBJ   20,45,1,6,270,143,290,"","Chkr Sqr Pixel Width"
DIAOBJ   20,46,5,166,100,250,119,"","targetRightRate"
DIAOBJ   20,47,3,263,99,347,117,"","targetRightRate"
DIAOBJ   20,48,1,6,92,151,110,"","Right Target Proportion"

DIAPAGE 21,"Visually_Guided"
DIAPOS   21,0,-1,-1,-1,-1,748,427,1122,837,21
DIAOBJ   21,0,2,283,350,347,372,"Start","dset;\r\nbeginTaskFlag = 1;"
DIAOBJ   21,1,2,206,351,270,373,"quit","dshow quit_check;\r\nDPOP"
DIAOBJ   21,2,2,101,352,185,371,"Update","spawn GOODVARS;\r\ndset;"
DIAOBJ   21,3,5,134,48,185,70,"","ampDefault"
DIAOBJ   21,4,3,223,48,290,68,"","ampDefault"
DIAOBJ   21,5,1,20,49,103,68,"","Eccentricity"
DIAOBJ   21,6,3,225,109,292,124,"","targWinSize"
DIAOBJ   21,7,1,17,112,116,128,"","Target Window"
DIAOBJ   21,8,5,142,142,196,159,"","fixWinSize"
DIAOBJ   21,9,2,14,351,96,373,"Pause","quiet Pause = 1;\r\ndialog Resume"
DIAOBJ   21,10,5,130,179,181,198,"","baseRewardDuration"
DIAOBJ   21,11,3,198,178,285,197,"","baseRewardDuration"
DIAOBJ   21,12,1,19,176,120,196,"","Reward duration"
DIAOBJ   21,13,1,26,211,154,233,"","Trials Per Target"
DIAOBJ   21,14,1,19,241,147,263,"","Trials Remaining"
DIAOBJ   21,15,5,163,210,226,228,"","nTrialPerTarget"
DIAOBJ   21,16,3,170,241,231,256,"","nTrialRemain"
DIAOBJ   21,17,5,136,110,189,129,"","targWinSize"
DIAOBJ   21,18,3,225,139,292,155,"","fixWinSize"
DIAOBJ   21,19,1,19,142,136,160,"","Fixation Window"
DIAOBJ   21,20,2,131,321,259,343,"180","angleArray[1] = angleArray[0] + 180;\r\nampArray[1] = ampArray[0];\r\n"
DIAOBJ   21,21,1,16,79,128,98,"","Right Targ Angle"
DIAOBJ   21,22,5,135,79,187,99,"","angleArray[0]"
DIAOBJ   21,23,3,222,79,291,101,"","angleArray[0]"
DIAOBJ   21,24,4,175,282,251,305,"","intertrialduration"
DIAOBJ   21,25,1,28,284,156,306,"","Intertrial interval"
DIAOBJ   21,26,3,269,285,356,305,"","intertrialduration"

DIAPAGE 22,"delayed_task"
DIAPOS   22,0,-1,-1,-1,-1,796,211,1168,676,22
DIAOBJ   22,0,2,286,399,350,421,"Start","DSET;\r\nbeginTaskFlag = 1;"
DIAOBJ   22,1,2,200,399,264,421,"Quit","dshow quit_check;"
DIAOBJ   22,2,2,110,400,194,421,"Update","dset;"
DIAOBJ   22,3,5,127,27,209,47,"","ampDefault"
DIAOBJ   22,4,3,212,27,340,49,"","ampDefault"
DIAOBJ   22,5,1,4,28,106,47,"","Eccentricity"
DIAOBJ   22,6,3,250,90,327,105,"","targWinSize"
DIAOBJ   22,7,5,136,92,208,113,"","targWinSize"
DIAOBJ   22,8,1,6,163,134,185,"","Reward Time"
DIAOBJ   22,9,1,4,91,132,113,"","Target Window"
DIAOBJ   22,10,5,137,125,208,148,"","fixWinSize"
DIAOBJ   22,11,3,219,125,339,145,"","fixWinSize"
DIAOBJ   22,12,1,6,125,134,147,"","Fix Window targSize"
DIAOBJ   22,13,5,139,160,213,181,"","baseRewardDuration"
DIAOBJ   22,14,3,261,161,340,183,"","baseRewardDuration"
DIAOBJ   22,15,2,18,401,101,423,"Pause","quiet Pause = 1;\r\ndialog Resume"
DIAOBJ   22,16,5,141,190,215,210,"","basePunishDuration"
DIAOBJ   22,17,1,11,191,115,210,"","Timeout Time"
DIAOBJ   22,18,3,256,189,347,208,"","basePunishDuration"
DIAOBJ   22,19,1,40,339,168,361,"","Trials Remaining"
DIAOBJ   22,20,1,41,312,169,334,"","Trials Per Target"
DIAOBJ   22,21,5,173,312,236,333,"","nTrialPerTarget"
DIAOBJ   22,22,3,171,343,238,358,"","nTrialRemain"
DIAOBJ   22,23,2,128,369,256,391,"180","angleArray[1] = angleArray[0] + 180;\r\nampArray[1] = ampArray[0];\r\n"
DIAOBJ   22,24,5,128,59,210,79,"","angleArray[0]"
DIAOBJ   22,25,3,266,60,345,80,"","angleArray[0]"
DIAOBJ   22,26,1,4,57,113,76,"","Right Targ Angle"
DIAOBJ   22,27,5,139,231,219,249,"","interTrialDuration"
DIAOBJ   22,28,3,266,233,344,250,"","interTrialDuration"
DIAOBJ   22,29,1,8,229,136,251,"","interTrialDuration"

DIAPAGE 23,"countermanding"
DIAPOS   23,0,-1,-1,-1,-1,836,113,1211,790,23
DIAOBJ   23,0,2,286,615,350,637,"Start","dset;\r\nbeginTaskFlag = 1;"
DIAOBJ   23,1,2,202,614,266,636,"Quit","dshow quit_check;\r\nDPOP"
DIAOBJ   23,2,5,156,39,219,62,"","ampDefault"
DIAOBJ   23,3,1,5,40,133,62,"","Target Eccentricity"
DIAOBJ   23,4,3,265,44,337,62,"","ampDefault"
DIAOBJ   23,5,3,264,71,338,90,"","angleArray[0]"
DIAOBJ   23,6,5,158,75,227,94,"","angleArray[0]"
DIAOBJ   23,7,1,10,70,138,92,"","Right Target Angle"
DIAOBJ   23,8,1,8,132,136,154,"","Target Window"
DIAOBJ   23,9,1,10,165,138,187,"","Fixation Window"
DIAOBJ   23,10,5,160,165,227,181,"","fixWinSize"
DIAOBJ   23,11,3,264,163,337,180,"","fixWinSize"
DIAOBJ   23,12,5,157,131,229,148,"","targWinSize"
DIAOBJ   23,13,3,267,126,332,144,"","targWinSize"
DIAOBJ   23,14,1,127,13,255,35,"","STIMULI"
DIAOBJ   23,15,1,25,278,153,300,"","SSDs"
DIAOBJ   23,16,3,100,308,169,327,"","ssdArray[0]"
DIAOBJ   23,17,5,20,306,77,325,"","ssdArray[0]"
DIAOBJ   23,18,5,20,339,77,358,"","ssdArray[1]"
DIAOBJ   23,19,3,100,342,169,361,"","ssdArray[1]"
DIAOBJ   23,20,3,100,370,169,389,"","ssdArray[2]"
DIAOBJ   23,21,5,20,370,77,389,"","ssdArray[2]"
DIAOBJ   23,22,5,20,401,77,420,"","ssdArray[3]"
DIAOBJ   23,23,3,100,398,169,417,"","ssdArray[3]"
DIAOBJ   23,24,3,100,431,169,450,"","ssdArray[4]"
DIAOBJ   23,25,5,20,431,77,450,"","ssdArray[4]"
DIAOBJ   23,26,5,20,460,77,479,"","ssdArray[5]"
DIAOBJ   23,27,3,100,460,169,479,"","ssdArray[5]"
DIAOBJ   23,28,3,100,487,169,506,"","ssdArray[6]"
DIAOBJ   23,29,5,20,489,77,508,"","ssdArray[6]"
DIAOBJ   23,30,5,20,516,77,535,"","ssdArray[7]"
DIAOBJ   23,31,3,100,513,169,532,"","ssdArray[7]"
DIAOBJ   23,32,3,100,542,169,561,"","ssdArray[8]"
DIAOBJ   23,33,5,20,546,77,565,"","ssdArray[8]"
DIAOBJ   23,34,5,20,578,77,597,"","ssdArray[9]"
DIAOBJ   23,35,3,100,573,169,592,"","ssdArray[9]"
DIAOBJ   23,36,2,17,615,100,636,"Pause","quiet pause = 1;\r\ndialog Resume;"
DIAOBJ   23,37,2,104,615,196,636,"Update","DSET;\r\nangleArray[1] = angleArray[0] + 180;\r\nnTrialArray[1] = ampArray[0];\r\ngoPct = 100 - stopPct;\r\n"
DIAOBJ   23,38,3,297,310,349,329,"","baseRewardDuration"
DIAOBJ   23,39,5,203,310,274,330,"","baseRewardDuration"
DIAOBJ   23,40,1,228,288,315,306,"","Reward Time"
DIAOBJ   23,41,1,234,354,313,373,"","Timeout"
DIAOBJ   23,42,5,198,379,263,400,"","basePunishDuration"
DIAOBJ   23,43,3,275,382,352,398,"","basePunishDuration"
DIAOBJ   23,44,3,254,101,340,117,"","targetRightRate"
DIAOBJ   23,45,5,167,103,226,119,"","targetRightRate"
DIAOBJ   23,46,1,6,104,156,124,"","Right Target Proportion"
DIAOBJ   23,47,5,155,227,213,242,"","stopPct"
DIAOBJ   23,48,3,258,228,329,243,"","stopPct"
DIAOBJ   23,49,1,10,222,138,244,"","Stop Trial Percent"
DIAOBJ   23,50,2,148,255,200,274,"ON","randomAmpFlag = 1;\r\ndset;"
DIAOBJ   23,51,3,287,260,350,276,"","randomAmpFlag "
DIAOBJ   23,52,2,220,255,272,274,"OFF","randomAmpFlag = 0;\r\ndset;"
DIAOBJ   23,53,1,11,257,139,279,"","Vary Eccentricity"

; END OF DIALOGS

; TEMPO PROTOCOL CONFIGURATION FILE
; Copyright 1997-2003 Reflective Computing.  All Rights Reserved.
; This file was created by TEMPO and should not be edited directly by the user.
; The commands in this file are undocumented and subject to change in future releases.
; Tue Dec 30 21:11:40 2003
; CLOAD ALL_PROS.pcf

; tempow 11.7 Set 40.13   'CLIENT0294656' connected to 'tempo4'
; KPED 11.2 Set 40
; KSRV 11.3 Set 40.13 (Server 'tempo4          ' running on computer '')
; PCL 0.0     TEMPO 0.0
; ANALOGRESOLUTION=16
; WARNING=2
; SPEED=1000.000000  PROSPEED=500.000000  (100/100000 Sec/SampleSet)
; ASETS=2(2)  CSETS=2(2)  ESETS=2(2)
; ACHANNELS=3
; CCHANNELS=2
; ECHANNELS=2
;
;                          Protocol Usage of Kernel Resources  
;
; Parameter       Limit          Used    Pct        Bytes/Total        Develop    Stable
; -------------   -------     -------  -----        -----------        -------    ------
; PROCESSES       =80              55    69%         2420/3520          =79        =58      
; INSTRUCTIONS    =7000          4854    69%        87360/126000        =6068      =5110    
; InstructionsXMS =20025         4854    24%        87360/360448        =6068      =5110    
; SYMBOLTABLE     =2200          1882    86%        22584/26400         =2214      =1981    
; HASHTABLE       =     257,2200         75%        11418/14742       Use Kernel Default
; NAMETABLE       =60000        21405    36%        21405/60000         =25182     =22532   
; DATABASES       =16               0     0%            0/960           =0         =0       
; ARRAYTABLE      =500            478    96%          478/500           =598       =493     
; ARRAYDATA       =10240         9456    92%         9456/10240         =11820     =9748    
; OBJECTS         =41              25    61%         1100/1804          =28        =26      
;
; PROTOCOL PROCESS CONTROL BLOCKS (XMS Instructions Caching ENABLED)
; INSTRUCTIONS=7000,20024
; Memory (bytes):  87360/126000 Conventional, 87360/360448 XMS
; Server CPU Mhz  Empirical 2992.5    Theoretical 3000.0
;
;    STATE PROCESS  Longest  1.306ms   PC INST  MAX LONG     MS  MaxMS LongMS Bytes  Conventional        XMS      Loaded  uSec 
;   1 DONE DEFAULT                   8292    0  292    0  0.000  0.172  0.000  8292    7392-15691        2-8293        1    16
;   2 DONE GOODVARS                  3786    0  847    0  0.000  0.390  0.000  3786   15692-19485     8294-12079       1     6
;   3 DONE SET_CLRS                   842    0   71    0  0.000  0.150  0.000   842   19486-20335    12080-12921       1     4
;   4 DONE SET_COOR                   192    0   17    0  0.000  0.093  0.000   192    3976-4175     12922-13113       1     3
;   5 DONE GRAPHS                     548    0   47    0  0.000  0.043  0.000   548    4176-4731     13114-13661       1     3
;   6 SUSP SET_INH                      0    0    0    0  0.000  0.000  0.000   506    not loaded    13662-14167       0     0
;   7 DONE SET_PSY                    712    0   68    0  0.000  0.049  0.000   712   20336-21055    14168-14879       1     3
;   8 DONE JUICE                       44    0    4    1  0.000  0.016  0.004    44   58298-58349    14880-14923       1     2
;   9 SUSP STIM                         0    0    0    0  0.000  0.000  0.000    88    not loaded    14924-15011       0     0
;  10 DONE STAIR                      316    0   21    0  0.000  0.012  0.000   316   27290-27613    15012-15327       1     3
;  11 SUSP STAIR_DSC                    0    0    0    0  0.000  0.000  0.000   574    not loaded    15328-15901       0     0
;  12 DONE SETTRIAL                  6226    0  499    0  0.000  0.126  0.000  6226   21056-27289    15902-22127       1    13
;  13 DONE WINDOWS                   4264    0  134    0  0.000  0.050  0.000  4264   32780-37051    22128-26391       1     9
;  14 DONE LOCATE_I                  1416    0   43   42  0.000  0.148  0.013  1416    5230-6653     26392-27807       1     3
;  15 RUN  WATCHEYE                   486   20   51   27  0.009  0.150  0.015   490    4732-5229     27808-28297       1     3
;  16 DONE TONE                        54    0    5    0  0.000  0.014  0.000    54   58350-58411    28298-28351       1     4
;  17 SUSP TONESWEP                     0    0    0    0  0.000  0.000  0.000   288    not loaded    28352-28639       0     0
;  18 DONE WATCHMTH                   404    0    7    0  0.000  0.011  0.000   404    6812-7223     28640-29043       1     4
;  19 DONE WATCHBOD                   160    0    2    0  0.000  0.008  0.000   160    7224-7391     29044-29203       1     2
;  20 DONE SVR_BELL                   180    0    4    0  0.000  0.014  0.000   180   57974-58161    29204-29383       1     3
;  21 SUSP SVR_BEL2                     0    0    0    0  0.000  0.000  0.000    20    not loaded    29384-29403       0     0
;  22 DONE DRW_SQR                    380    0  129    0  0.000  0.116  0.000   380   30204-30591    29404-29783       1     3
;  23 DONE DRW_CHKR                  1920    0 2493    0  0.000  0.884  0.000  1920   30852-32779    29784-31703       1     5
;  24 SUSP DRW_GNG                      0    0    0    0  0.000  0.000  0.000  1910    not loaded    31704-33613       0     0
;  25 SUSP FIX_PGS                      0    0    0    0  0.000  0.000  0.000   154    not loaded    33614-33767       0     0
;  26 SUSP VIS_PGS                      0    0    0    0  0.000  0.000  0.000   876    not loaded    33768-34643       0     0
;  27 SUSP AMP_PGS                      0    0    0    0  0.000  0.000  0.000   884    not loaded    34644-35527       0     0
;  28 SUSP DEL_PGS                      0    0    0    0  0.000  0.000  0.000  1330    not loaded    35528-36857       0     0
;  29 SUSP MEM_PGS                      0    0    0    0  0.000  0.000  0.000  1348    not loaded    36858-38205       0     0
;  30 SUSP CMD_PGS                      0    0    0    0  0.000  0.000  0.000  1630    not loaded    38206-39835       0     0
;  31 DONE CCM_PGS                   2582    0   55    0  0.000  0.057  0.000  2582   27614-30203    39836-42417       1     6
;  32 SUSP GNG_PGS                      0    0    0    0  0.000  0.000  0.000  1266    not loaded    42418-43683       0     0
;  33 SUSP FIXTRIAL                     0    0    0    0  0.000  0.000  0.000   430    not loaded    43684-44113       0     0
;  34 DONE CCMTRIAL                  5694    0   75    0  0.000  0.143  0.000  5694   37052-42753    44114-49807       1    12
;  35 SUSP MEMTRIAL                     0    0    0    0  0.000  0.000  0.000  1686    not loaded    49808-51493       0     0
;  36 SUSP DELTRIAL                     0    0    0    0  0.000  0.000  0.000  1752    not loaded    51494-53245       0     0
;  37 SUSP VISTRIAL                     0    0    0    0  0.000  0.000  0.000  1374    not loaded    53246-54619       0     0
;  38 SUSP AMPTRIAL                     0    0    0    0  0.000  0.000  0.000  1402    not loaded    54620-56021       0     0
;  39 SUSP CMDTRIAL                     0    0    0    0  0.000  0.000  0.000  2680    not loaded    56022-58701       0     0
;  40 SUSP GNGTRIAL                     0    0    0    0  0.000  0.000  0.000  2478    not loaded    58702-61179       0     0
;  41 SUSP UPD8_INH                     0    0    0    0  0.000  0.000  0.000  1306    not loaded    61180-62485       0     0
;  42 DONE UPD8_PSY                  2642    0  239    0  0.000  0.096  0.000  2642   55324-57973    62486-65127       1     6
;  43 DONE INFOS                     6282    0 1416 1416  0.000  0.488  0.479  6282   49034-55323    65128-71409       1    15
;  44 DONE REWARDS                   6272    0   96    8  0.000  0.140  0.014  6272   42754-49033    71410-77681       1    13
;  45 DONE KEY_REWD                   128    0   10    0  0.000  0.023  0.000   128   58162-58297    77682-77809       1     4
;  46 SUSP KEY_T_UP                     0    0    0    0  0.000  0.000  0.000    50    not loaded    77810-77859       0     0
;  47 SUSP KEY_T_DN                     0    0    0    0  0.000  0.000  0.000    68    not loaded    77860-77927       0     0
;  48 SUSP KEY_MOVE                     0    0    0    0  0.000  0.000  0.000   116    not loaded    77928-78043       0     0
;  49 SUSP KEY_STIM                     0    0    0    0  0.000  0.000  0.000    26    not loaded    78044-78069       0     0
;  50 DONE WAIT_MU                    100    0  600  558  0.000  0.701  0.612   100   30744-30851    78070-78169       1     2
;  51 DONE SEND_TTL                   144    0   70   70  0.000  0.100  0.088   144   30592-30743    78170-78313       1     2
;  52 RUN  QUE_TTL                    146    8   68   68  0.006  0.141  0.043   150    6654-6811     78314-78463       1     2
;  53 SUSP VWM_PGS                      0    0    0    0  0.000  0.000  0.000  1434    not loaded    78464-79897       0     0
;  54 SUSP VWMTRIAL                     0    0    0    0  0.000  0.000  0.000  3496    not loaded    79898-83393       0     0
;  55 RUN  IDLE                      2466    4  149    1  0.005  0.137  0.005  3966       2-3975     83394-87359       1     9


SPEED 1000

; ANALOG TABLE SETTINGS
;; ACHANNELS=3

; SPIKE TABLE SETTINGS
;; CCHANNELS=2

; EVENT TABLE SETTINGS
;; ECHANNELS=2

PLOAD ALL_PROS.pro

; DATABASES=16


; WINDOW CONFIGURATION

SCREENRES 1280,1024,32
MAINWND 1,-1,-1,-1,-1,1,-1,912,53,0
MSGWND 1,-1,-1,-1,-1,1,53,382,910,0
STATUSWND 1,-1,-1,-1,-1,369,429,1271,973,0
SHOW v 510

CMDWND 1,-1,-1,-1,-1,3,911,618,961,0
ANIMPAGE 0x1,1,-1,-1,-1,-1,368,54,1275,430,0
ANIMVIEW 0,1,-1,-1,-1,-1,0,0,449,349,0
ANIMVIEW 1,1,-1,-1,-1,-1,449,0,898,349,1

; DATABASES PAGES & VIEWS

DBPCOLORS 0x0,0x0,0x0,0x0,0x0

; END GRAPH CONFIGURATION

DLOAD all_pros.dcf

; BEGIN KEY DEFINITIONS

KEY F1 = dialog Info_and_StartClock
KEY ESC = dpop
KEY PLUS = spawn key_rewd
KEY INSERT = spawn key_rewd
KEY ALTE = Eye_on_VDOSync = 1
KEY ALTX = Eye_on_VDOSYnc = 0
KEY ALTC = CenterEyeNow = 1
KEY F2 = dialog Choose_Task
KEY F3 = dialog Fixation_Main
KEY F4 = dialog in_task_pane
KEY ALTM = spawn key_move
KEY CURUP = spawn KEY_REWD
KEY PGUP = spawn KEY_STIM

; END KEY DEFINITIONS

//----------------------------------------------------------------------------
// ALL_PROS.pro



#pragma declare = 1                     // require declarations of all variables

declare IDLE();							// must be declared in top because it is called by other processes below

declare int state;						// The state global variable allows the control structure to run tasks...
										// ...depending on the current stystem state. The beginning state is idling.
declare int beginTaskFlag;				// Starts tasks after setting variables;
declare int allowTaskToBegin;
declare int setMonkey;
declare int monkey;	
declare int Pause;						// Gives user ability to pause task with a button press
declare int Last_task;					// Keeps\ track of the last task which was run to hold onto default variable values
declare int Event_fifo_N = 1000;		// Length of strobed event buffer
declare int Event_fifo[Event_fifo_N];	// Global first in first out buffer for event codes
declare int Set_event = 0;              // Current index of Event_fifo buffer to set
declare int xena 	= 1;
declare int broca    	= 2;
declare int cajal    	= 3;
declare int euler    	= 4;


#include C:/TEMPO/ProcLib/PGM/RIGSETUP.pro  // declares a bunch of rig specific global variables
#include C:/TEMPO/ProcLib/PGM/EVENTDEF.pro	// event code definitions
#include C:/TEMPO/ProcLib/PGM/ALL_VARS.pro	// declares global variables needed to run protocols
#include C:/TEMPO/ProcLib/PGM/DEFAULT.pro	// sets all globals to their appropriate defaults for countermanding
#include C:/TEMPO/ProcLib/PGM/GOODVARS.pro	// do user defined variables make sense before starting the task?
#include C:/TEMPO/ProcLib/PGM/SET_CLRS.pro	// sets the stim colors up
#include C:/TEMPO/ProcLib/PGM/DIO.pro		// necessary for digital input output communication
#include C:/TEMPO/ProcLib/PGM/SET_COOR.pro  // set screen coordinates up and calculate some conversion factors
#include C:/TEMPO/ProcLib/PGM/GRAPHS.pro    // required when using object graphs in cmanding protocol (modified from object.pro to include graph setup)
#include C:/TEMPO/ProcLib/PGM/SET_INH.pro	// sets up the inhibition function graph used in cmanding
#include C:/TEMPO/ProcLib/PGM/SET_PSY.pro	// sets up the psychometric function graph used in go/no-go
#include C:/TEMPO/ProcLib/PGM/JUICE.pro
#include C:/TEMPO/ProcLib/PGM/STIM.pro
#include C:/TEMPO/ProcLib/PGM/SETTRIAL.pro	// sets up all of the input to run a countermanding trial
#include C:/TEMPO/ProcLib/PGM/WINDOWS.pro	// sets fixation and target window targSize (these valeus are needed in WATCHEYE.pro)
#include C:/TEMPO/ProcLib/PGM/WATCHEYE.pro	// monitors eye position on each process cyle
#include C:/TEMPO/ProcLib/PGM/TONE.pro      // does simple frequency conversion and presents tone accordingly
#include C:/TEMPO/ProcLib/PGM/TONESWEP.pro	// a sweep through several tones for a sound which can be distinguished from pure tones
#include C:/TEMPO/ProcLib/PGM/WATCHMTH.pro	// monitors mouth movement on each process cycle
#include C:/TEMPO/ProcLib/PGM/WATCHBOD.pro	// monitors body movement on each process cycle
#include C:/TEMPO/ProcLib/PGM/SVR_BELL.pro	// sounds speaker on server
#include C:/TEMPO/ProcLib/PGM/SVR_BEL2.pro	// sounds speaker on server (different)
#include C:/TEMPO/ProcLib/PGM/DRW_SQR.pro	// simple process for drawing stim
#include C:/TEMPO/ProcLib/PGM/DRW_CHKR.pro	// process for drawing checkered discriminatory stimulus
#include C:/TEMPO/ProcLib/PGM/DRW_GNG.pro	// process for drawing checkered go/no-go discriminatory stimulus
#include C:/TEMPO/ProcLib/PGM/FIX_PGS.pro						// sets all pgs of video memory up for the impending trial
#include C:/TEMPO/ProcLib/PGM/VIS_PGS.pro						// sets all pgs of video memory up for the impending trial
#include C:/TEMPO/ProcLib/PGM/AMP_PGS.pro						// sets all pgs of video memory up for the impending trial
#include C:/TEMPO/ProcLib/PGM/DEL_PGS.pro						// sets all pgs of video memory up for the impending trial
#include C:/TEMPO/ProcLib/PGM/MEM_PGS.pro						// sets all pgs of video memory up for the impending trial
#include C:/TEMPO/ProcLib/PGM/CMD_PGS.pro						// sets all pgs of video memory up for the impending trial
#include C:/TEMPO/ProcLib/PGM/CCM_PGS.pro						// sets all pgs of video memory up for the impending trial
#include C:/TEMPO/ProcLib/PGM/GNG_PGS.pro						// sets all pgs of video memory up for the impending trial
#include C:/TEMPO/ProcLib/PGM/FIXTRIAL.pro	// modified from CMDTRIAL, for choice countermanding
#include C:/TEMPO/ProcLib/PGM/CCMTRIAL.pro	// modified from CMDTRIAL, for choice countermanding
#include C:/TEMPO/ProcLib/PGM/MEMTRIAL.pro	// runs a single mem guided trial based on input
#include C:/TEMPO/ProcLib/PGM/DELTRIAL.pro	// runs a single delayed sacc trial based on input
#include C:/TEMPO/ProcLib/PGM/VISTRIAL.pro	// runs a single visually guided trial based on input
#include C:/TEMPO/ProcLib/PGM/AMPTRIAL.pro	// runs a single amplitude trial based on input
#include C:/TEMPO/ProcLib/PGM/CMDTRIAL.pro	// runs a single countermanding trial based on input
#include C:/TEMPO/ProcLib/PGM/GNGTRIAL.pro	// modified from CMDTRIAL, for go/no-go
#include C:/TEMPO/ProcLib/PGM/UPD8_INH.pro	// updates inhibition function for cmanding
#include C:/TEMPO/ProcLib/PGM/UPD8_PSY.pro	// updates psychometric function for go/no-go
#include C:/TEMPO/ProcLib/PGM/INFOS.pro		// queue up all trial event codes for strobing to plexon
#include C:/TEMPO/ProcLib/PGM/REWARDS.pro	// ends a trial based on outcome
#include C:/TEMPO/ProcLib/PGM/KEY_REWD.pro	// needed to give reward manually from keyboard (stupid)
#include C:/TEMPO/ProcLib/PGM/KEY_TARG.pro	// see above
#include C:/TEMPO/ProcLib/PGM/KEY_MOVE.pro	// see above
#include C:/TEMPO/ProcLib/PGM/KEY_STIM.pro	// see above
#include C:/TEMPO/ProcLib/PGM/QUE_TTL.pro	// makes a ring buffer for sending TTL events


#include C:/TEMPO/ProcLib/PGM/VWM_PGS.pro	// 
#include C:/TEMPO/ProcLib/PGM/VWMTRIAL.pro	// 

//#include C:/TEMPO/ProcLib/PGM/SEARCH_PGS.pro	// SEARCH control structure



//----------------------------------------------------------------------
process IDLE() enabled				// When the clock is started the task is not yet running.
{									// At any time we can press a button to return to this...
									// ...idle loop.  It will make sure everything is off...
									// ...and all necessary variables are reset before...
									// ...starting the task over or starting a new task.
declare hide int off = 0;
declare hide int idling = 1;			// makes the while loop run
declare int i;

seed1(timeus());					// randomly seed the number generator
normal(1);							// call the normal distribution to replenish queue after seeding
				  
dioSetMode(0, PORTA|PORTB|PORTC); 	// set 1st three TTL lines to output					  
mio_dig_set(juiceChannel,off);		// make sure the juice line is closed
mio_fout(off);						// make sure the speaker is off
dsend("vi 256;");					// make sure vdosync is in correct config
dsend("ca");						// flush all vdosync memory
		
		
		
		
spawn SET_COOR();					// set up screen coordinates based on globals defined in RIGSETUP.pro	
			
spawn GRAPHS();						// this is currently countermanding specific and should be changed
	
spawn WATCHEYE();					// start monitoring eye position

spawn QUE_TTL();					// set up for plexon communication


printf("flushing video memory please wait...\n");
wait 5000; 							// it can take up to 5 seconds to clear all vdo sync memory (pg 7-37)
printf("done!\n");
system("dialog Choose_Task");		// Pop up choose task dialog
if (!setMonkey)
	{
	system("dialog Select_Monkey");
	}
		system("key curup = spawn KEY_REWD");		// define up key macro
		system("key pgup = spawn KEY_STIM");		// define page up key macro







	
while (idling)						// wait for the user to specify which task to run
	{
	beginTaskFlag = 0;				// after exiting a task (or before ever starting one for the session), reset (set) beginTaskFlag
	allowTaskToBegin = 0;			// ensures a task doesn't get spawned before re-setting stuff in "if (state != stateNoTask)" conditional
	




	
// --------------------------------------------------------------------------------
// If a task has been selected to run, do a few things common to all tasks before calling relevant task below
// --------------------------------------------------------------------------------
	if (state != stateNoTask)					// stop idling if a task is being run
		{
		idling = 0;					
		
		nTrial				= 1;			// initialize some counters
		nTrialComplete			= 0;
		Block_number			= 1;

								
	
		dsend("DM RFRSH");                			// This code sets up a vdosync macro definition to wait a specified ...
		if (Room == 23)                   			// ...number of vertical retraces based on the room in which we are    ...
			{                             			// ...recording.  This kluge is necessary because vdosync operates     ...
			dsendf("vw %d:\n",1);         			// ...differently in the different rooms.  In 028 a command to wait    ...
			}                             			// ...2 refresh cycles usually only waits for one and a command to     ...
		else                              			// ...wait for 1 usually only waits for 0.  Room 029 and 023 appear to ...
			{                             			// ...work properly.
			dsendf("vw %d:\n",2);
			}
		dsend("EM RFRSH");
		
		// if (setMonkey)
			// {
			// spawnwait DEFAULT();			// Set all globals to their default values based on the monkey.
			// }
	

		spawn WATCHMTH;								// start watching the mouth motion detector if present
		spawn WATCHBOD;								// start watching motion detector for body if present
		

		
		allowTaskToBegin = 1;
		nexttick 10;								// to prevent buffer overflows after task reentry.
		
		}
		
		
		
		
		
		
// --------------------------------------------------------------------------------
// FIXATION TASK
// --------------------------------------------------------------------------------
	if (state == stateFIX && allowTaskToBegin)		// user wants to run the fixation task
		{

		spawnwait DEFAULT();
		spawnwait SET_CLRS();
		spawnwait GOODVARS();
		system("dialog Fixation_Main");		// Pop up choose task dialog
		
		nTrial				= 1;

		system("key currt = spawn KEY_T_UP");		// define right key macro
		system("key curlf = spawn KEY_T_DN");		// define left key macro
		system("key curdn = beginTaskFlag = 1");				// define down to start task

		while (!beginTaskFlag)									
			{
			nexttick;
			}
		while (State == stateFIX)				// while the user has not yet terminated the countermanding task
			{

			// No need to call SETTRIAL since we manually advance through target locations: may want to update this and make it optional in the future though.
			spawnwait 	SETTRIAL();		
			spawnwait 	FIX_PGS();		
			spawnwait 	WINDOWS();		
			spawnwait 	FIXTRIAL();		
			spawnwait 	REWARDS();		
					
			nTrial = nTrial + 1;			
			nexttick;								// wait at least one cycle and do it all again
			
			while(Pause)							// gives the user the ability to pause the task without ending it
				{
				nexttick;
				}
			}
		
		system("key currt = ");							// clear right key macro
		system("key curlf = ");							// clear left key macro
		system("key curup = ");							// clear up key macro
		system("key curdn = ");							// clear down key macro		

		}
		










// --------------------------------------------------------------------------------
// VISUALLY GUIDED SACCADE TASK
// --------------------------------------------------------------------------------
	if (state == stateVIS && allowTaskToBegin)		// user wants to run the visually guided task
		{
		
		spawnwait DEFAULT();
		spawnwait GOODVARS();
		spawnwait SET_CLRS();
		system("dialog Visually_Guided");		// Pop up choose task dialog

		
		nTrial				= 1;
		
		// Wait for user to specify when to start (by pressing Start button on task GUI)
		while (!beginTaskFlag)									
			{
			nexttick;
			}
		Event_fifo[Set_event] = VisHeader_;			// Set a strobe to identify this file as a visually guided session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		Event_fifo[Set_event] = Identify_Room_;		// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		Event_fifo[Set_event] = Room;				// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		
	nTrialRemain = nTrialPerTarget * nTarg;

	while (State == stateVIS)				// while the user has not yet terminated the countermanding task
			{
	
			spawnwait 	SETTRIAL();		
			spawnwait 	VIS_PGS();		
			spawnwait 	WINDOWS();		
			spawnwait 	VISTRIAL();			// run a trial with variables defined by SETTRIAL.pro			
			spawnwait 	REWARDS();			// end a trial with trialOutcome 
					
			nexttick;								// wait at least one cycle and do it all again
			
			while(Pause)							// gives the user the ability to pause the task without ending it
				{
				nexttick;
				}
			
			}
		}


// --------------------------------------------------------------------------------
// VISUAL Search Task
// --------------------------------------------------------------------------------
//	if (state == stateSEARCH && allowTaskToBegin)		// user wants to run the visual search task
//		{
//		
//		spawnwait DEFAULT();
//		spawnwait GOODVARS();
//		spawnwait SET_CLRS();
//		system("dialog Visual_Search");		// Pop up choose task dialog
//
//		
//		nTrial				= 1;
//		
//		// Wait for user to specify when to start (by pressing Start button on task GUI)
//		while (!beginTaskFlag)									
//			{
//			nexttick;
//			}
//		Event_fifo[Set_event] = VisHeader_;			// Set a strobe to identify this file as a visual search session and...	
//		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
//		Event_fifo[Set_event] = Identify_Room_;		// Set a strobe to identify this file as a Cmanding session and...	
//		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
//		Event_fifo[Set_event] = Room;				// Set a strobe to identify this file as a Cmanding session and...	
//		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
//		
//	nTrialRemain = nTrialPerTarget * nTarg;
//
//	while (State == stateSEARCH)				// while the user has not yet terminated the countermanding task
//			{
//	
//			spawnwait 	SETTRIAL();		
//			spawnwait 	VIS_PGS();		
//			spawnwait 	WINDOWS();		
//			spawnwait 	VISTRIAL();			// run a trial with variables defined by SETTRIAL.pro			
//			spawnwait 	REWARDS();			// end a trial with trialOutcome 
//					
//			nexttick;								// wait at least one cycle and do it all again
//			
//			while(Pause)							// gives the user the ability to pause the task without ending it
//				{
//				nexttick;
//				}
//			
//			}
//		}
//


// --------------------------------------------------------------------------------
// AMPLITUDE SACCADE TASK
// --------------------------------------------------------------------------------
	if (state == stateAMP && allowTaskToBegin)		// user wants to run the amplitude task
		{

		spawnwait DEFAULT();
		spawnwait GOODVARS();
		spawnwait SET_CLRS();

		
		// Wait for user to specify when to start (by pressing Start button on task GUI)
		while (!beginTaskFlag)									
			{
			nexttick;
			}
		Event_fifo[Set_event] = AmpHeader_;			// Set a strobe to identify this file as a visually guided session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		Event_fifo[Set_event] = Identify_Room_;		// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		Event_fifo[Set_event] = Room;				// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		
		while (State == stateAMP)				// while the user has not yet terminated the mem guided task
			{
			
			spawnwait	SETTRIAL();		// see ALL_VARS.pro and DEFAULT.pro
			spawnwait 	AMP_PGS();		// see ALL_VARS.pro and DEFAULT.pro
			spawnwait 	WINDOWS();		// see ALL_VARS.pro and DEFAULT.pro
			spawnwait 	AMPTRIAL();		// run a trial with variables defined by SETTRIAL.pro			
			spawnwait 	REWARDS();		
					
			nexttick;								// wait at least one cycle and do it all again
			
			while(Pause)							// gives the user the ability to pause the task without ending it
				{
				nexttick;
				}
			
			}
		}
		
		
		
		
		
		
// --------------------------------------------------------------------------------
// DELAYED SACCADE TASK
// --------------------------------------------------------------------------------
	if (state == stateDEL && allowTaskToBegin)		// user wants to run the mem guided sacc task
		{

		spawnwait DEFAULT();
		spawnwait GOODVARS();
		spawnwait SET_CLRS();

		
		nTrial				= 1;
		
		// Wait for user to specify when to start (by pressing Start button on task GUI)
		while (!beginTaskFlag)									
			{
			nexttick;
			}
		Event_fifo[Set_event] = DelayHeader_;			// Set a strobe to identify this file as a visually guided session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		Event_fifo[Set_event] = Identify_Room_;		// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		Event_fifo[Set_event] = Room;				// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		
	nTrialRemain = nTrialPerTarget * nTarg;

	while (State == stateDEL)				// while the user has not yet terminated the mem guided task
			{
	
			spawnwait 	SETTRIAL();		// see ALL_VARS.pro and DEFAULT.pro
			spawnwait 	DEL_PGS();		// see ALL_VARS.pro and DEFAULT.pro
			spawnwait 	WINDOWS();		// see ALL_VARS.pro and DEFAULT.pro	
			spawnwait 	DELTRIAL();		// run a trial with variables defined by SETTRIAL.pro	
			spawnwait 	REWARDS();			// end a trial with trialOutcome set in MEMTRIAL.pro
	
			nexttick;								// wait at least one cycle and do it all again
	
			while(Pause)							// gives the user the ability to pause the task without ending it
				{
				nexttick;
				}
	
			}
		}







// --------------------------------------------------------------------------------
// MEMORY GUIDED SACCADE TASK
// --------------------------------------------------------------------------------
	if (state == stateMEM && allowTaskToBegin)		// user wants to run the mem guided sacc task
		{
		
		spawnwait DEFAULT();
		spawnwait GOODVARS();
		spawnwait SET_CLRS();

		
		nTrial				= 1;
		
		// Wait for user to specify when to start (by pressing Start button on task GUI)
		while (!beginTaskFlag)									
			{
			nexttick;
			}
		Event_fifo[Set_event] = MemHeader_;			// Set a strobe to identify this file as a visually guided session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		Event_fifo[Set_event] = Identify_Room_;		// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		Event_fifo[Set_event] = Room;				// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		
	nTrialRemain = nTrialPerTarget * nTarg;

	while (State == stateMEM)				// while the user has not yet terminated the mem guided task
			{
			
			spawnwait 		SETTRIAL();		// see ALL_VARS.pro and DEFAULT.pro
			spawnwait 	MEM_PGS();		// see ALL_VARS.pro and DEFAULT.pro
			spawnwait 		WINDOWS();		// see ALL_VARS.pro and DEFAULT.pro	
			spawnwait 	MEMTRIAL();		// run a trial with variables defined by SETTRIAL.pro
			spawnwait 	REWARDS();			// end a trial with trialOutcome set in MEMTRIAL.pro
					
			nexttick;								// wait at least one cycle and do it all again
			
			while(Pause)							// gives the user the ability to pause the task without ending it
				{
				nexttick;
				}
			
			}
		}







// --------------------------------------------------------------------------------
// COUNTERMANDING TASK
// --------------------------------------------------------------------------------
	if (state == stateCMD && allowTaskToBegin)		// user wants to run the countermanding task
		{

		spawnwait DEFAULT();
		spawnwait GOODVARS();
		spawnwait SET_CLRS();

		
		spawnwait SET_INH();
		
		nTrial				= 1;
		nTrialComplete			= 0;
		LastOutcome 			= 1;		// Global output used to staircase 

		// Wait for user to specify when to start (by pressing Start button on task GUI)
		while (!beginTaskFlag)									
			{
			nexttick;
			}
		Event_fifo[Set_event] = CmanHeader_;		// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		Event_fifo[Set_event] = Identify_Room_;		// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		Event_fifo[Set_event] = Room;				// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		
		while (State == stateCMD)				// while the user has not yet terminated the countermanding task
			{
			
			spawnwait 	SETTRIAL();		// see ALL_VARS.pro and DEFAULT.pro
			spawnwait 	CMD_PGS();		// see ALL_VARS.pro and DEFAULT.pro
			spawnwait 	WINDOWS();		// see ALL_VARS.pro and DEFAULT.pro
			spawnwait 	CMDTRIAL(); 	// run a trial with variables defined in SETTRIAL.pro
			spawnwait 	REWARDS();		

			if(lastOutcome != 2)							// quick way to check if last trial was a stop trial
				{
				spawn 	UPD8_INH(); 						// update the inh graph
				}
					
			nexttick;								// wait at least one cycle and do it all again
			
			while(Pause)							// gives the user the ability to pause the task without ending it
				{
				nexttick;
				}
			}
			randomAmpFlag = 0;      // Reset to zero so other tasks don't have randomly varying amplitudes
		}
		
		
		
		
		
		
		
		
// --------------------------------------------------------------------------------
// CHOICE COUNTERMANDING TASK
// --------------------------------------------------------------------------------
	if (state == stateCCM && allowTaskToBegin)		// user wants to run the choice countermanding task
		{

		spawnwait DEFAULT();
		spawnwait GOODVARS();
		spawnwait SET_CLRS();
		

	//	spawnwait SET_INH(); 					// Set up the right graph for INH f(x).
		spawnwait SET_PSY(); 					// Set up the right graph for psychometric f(x)
						
		nTrial				= 1;
		nTrialComplete			= 0;
		LastOutcome 			= 1;		// Global output used to staircase Go/No-Go stimulus
		
		// Wait for user to specify when to start (by pressing Start button on task GUI)
		while (!beginTaskFlag)									
			{
			nexttick;
			}
		Event_fifo[Set_event] = ChCmanHeader_;		// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		Event_fifo[Set_event] = Identify_Room_;		// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		Event_fifo[Set_event] = Room;				// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		
		while (State == stateCCM)				// (pgm) while the user has not yet terminated the countermanding task
			{
					
			spawnwait 	SETTRIAL();		// see ALL_VARS.pro and DEFAULT.pro
			spawnwait 	CCM_PGS();		// see ALL_VARS.pro and DEFAULT.pro
			spawnwait 	WINDOWS();		// see ALL_VARS.pro and DEFAULT.pro
			spawnwait 	CCMTRIAL(); 	// run a trial with variables defined in SETTRIAL.pro			
			spawnwait 	REWARDS();		
			spawn 		UPD8_PSY();
			
			if (trialType == stopTrial)
				{
				lastStopArray[proportionIndex] = lastOutcome;   // THIS NEEDS TO BE UPDATED BEFORE CALLING SETTRIAL, SINCE lastOutcome gets updated there based on the last outcome in a newly assigned discriminatory level
				}
				
			nexttick;								// wait at least one cycle and do it all again
			
			while(Pause)							// gives the user the ability to pause the task without ending it
				{
				nexttick;
				}
			
			}
													// the State global variables allow a control structure...
		checkerIsTarg = 0;					// ...to impliment the task.
		
		}
		
		
		
		
		
		
		
		
// --------------------------------------------------------------------------------
// GO NO-GO TASK
// --------------------------------------------------------------------------------
	if (state == stateGNG && allowTaskToBegin)		// user wants to run the amplitude task
		{

		spawnwait DEFAULT();
		spawnwait GOODVARS();
		spawnwait SET_CLRS();

		
		
		nTrial				= 1;
		nTrialComplete			= 0;
		LastOutcome = 1;		// Global output used to staircase Go/No-Go stimulus
				
				
		spawnwait SET_PSY(); 					// Set up the right graph for psychometric f(x)
		
		// Wait for user to specify when to start (by pressing Start button on task GUI)
		while (!beginTaskFlag)									
			{
			nexttick;
			}
		Event_fifo[Set_event] = GoNoGoHeader_;		// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		Event_fifo[Set_event] = Identify_Room_;		// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		Event_fifo[Set_event] = Room;				// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		
		while (State == stateGNG)				// while the user has not yet terminated the countermanding task
			{
	
			spawnwait 	SETTRIAL();		// see ALL_VARS.pro and DEFAULT.pro
			spawnwait 	GNG_PGS();		// see ALL_VARS.pro and DEFAULT.pro
			spawnwait 	WINDOWS();		// see ALL_VARS.pro and DEFAULT.pro
			spawnwait 	GNGTRIAL();	 	// run a trial with variables defined in SETC_TRL.pro
			spawnwait 	REWARDS();		
			spawn 		UPD8_PSY();
					
			nexttick;								// wait at least one cycle and do it all again
			
			while(Pause)							// gives the user the ability to pause the task without ending it
				{
				nexttick;
				}
			
			}
		}





				

		
	
// --------------------------------------------------------------------------------
// Visual Working Memory TASK
// --------------------------------------------------------------------------------
	if (state == stateVWM && allowTaskToBegin)		// user wants to run visual working memory task
		{
		
		spawnwait DEFAULT();
		spawnwait GOODVARS();
		spawnwait SET_CLRS();
		
		//set performance monitors
		vwm_performance[0] = 0; //corr_sac1
		vwm_performance[1] = 0; //corr_sac2
		vwm_performance[2] = 0; //corr_sac3
		vwm_performance[3] = 0; //corr_sac4
		vwm_performance[4] = 0; //corr_sac5
		vwm_performance[5] = 0; //corr_sac6
		vwm_performance[6] = 0; //inc_sac1
		vwm_performance[7] = 0; //inc_sac2
		vwm_performance[8] = 0; //inc_sac3
		vwm_performance[9] = 0; //inc_sac4
		vwm_performance[10] = 0; //inc_sac5
		vwm_performance[11] = 0; //inc_sac6
		vwm_performance[12] = 0; //broke_targ1
		vwm_performance[13] = 0; //broke_targ2
		vwm_performance[14] = 0; //broke_targ3
		vwm_performance[15] = 0; //broke_targ4
		vwm_performance[16] = 0; //broke_targ5
		vwm_performance[17] = 0; //broke_targ6
		vwm_performance[18] = 0; //broke_fix1
		vwm_performance[19] = 0; //broke_fix2
		vwm_performance[20] = 0; //broke_fix3
		vwm_performance[21] = 0; //broke_fix4
		vwm_performance[22] = 0; //broke_fix5
		vwm_performance[23] = 0; //broke_fix6
		
		

		
		nTrial				= 1;
		
		// Wait for user to specify when to start (by pressing Start button on task GUI)
		while (!beginTaskFlag)									
			{
			nexttick;
			}
		Event_fifo[Set_event] = VWMHeader_;			// Set a strobe to identify this file as a visually guided session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		Event_fifo[Set_event] = Identify_Room_;		// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		Event_fifo[Set_event] = Room;				// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		
	nTrialRemain = nTrialsArray[0]+nTrialsArray[1]+nTrialsArray[2]+nTrialsArray[3]+nTrialsArray[4]+nTrialsArray[5]+nTrialsArray[6]+nTrialsArray[7]+nTrialsArray[8]+nTrialsArray[9]+nTrialsArray[10]+nTrialsArray[11];

	while (state == stateVWM)				// while the user has not yet terminated the mem guided task
			{
			
			spawnwait 		SETTRIAL();		// see ALL_VARS.pro and DEFAULT.pro
			printf("targAngle = %d\n",targAngle);
			spawnwait 	VWM_PGS();		// see ALL_VARS.pro and DEFAULT.pro
			printf("targAngle = %d\n",targAngle);
			spawnwait 		WINDOWS();		// see ALL_VARS.pro and DEFAULT.pro	
			spawnwait 	VWMTRIAL();		// run a trial with variables defined by SETTRIAL.pro
			spawnwait 	REWARDS();			// end a trial with trialOutcome set in MEMTRIAL.pro
					
			nexttick;								// wait at least one cycle and do it all again
			
			while(Pause)							// gives the user the ability to pause the task without ending it
				{
				nexttick;
				}
			
			}
		}
	
	nexttick;						// if no task is specified idle for another process... 
									// ...cycle and then check again.
	}  // while (idling) loop
	oSetGraph(gleft,aCLEAR);					// clear the left graph
	oSetGraph(gright,aCLEAR);					// clear the right graph
	
	i = 1;
	while (i <= nObject)
		{
		oDestroy(i);
		i = i + 1;
		}
	idling = 1;
	spawn IDLE();  // kick it back to the top to reset stuff and start a new task

} // process



// Global variables common to all tasks and some that are task-specific



declare hide int stateNoTask 	= 0;	// state 0 is 
declare hide int stateFIX = 1;	// gaze fixation task
declare hide int stateVIS = 2;	// visually guided saccade task
declare hide int stateAMP = 3;	// amplitude saccade task
declare hide int stateDEL = 4;	// delay saccade task
declare hide int stateMEM = 5;	// mem guided sacc
declare hide int stateCMD = 6;	// countermanding
declare hide int stateCCM = 7;	// choice countermanding
declare hide int stateGNG = 8;	// go/no-go saccade task
declare hide int stateMCM = 9;	// metacognition with masking decision task
declare hide int stateVWM = 10;	// metacognition with masking decision task


// Code all possible outcomes (for all tasks!)
declare hide int  trialOutcome, maskOutcome, betOutcome;
declare hide int  noFix			= 1;		// never attained fixation
declare hide int  brokeFix		= 2;		// attained and then lost fixation before target presentation
declare hide int  goIncorrect	= 3;		// never made saccade on a go trial (cmanding)
declare hide int  nogoCorrect	= 4;		// successfully canceled trial (cmanding)
declare hide int  saccOut		= 5;		// made an inaccurate saccade out of the target box
declare hide int  brokeTarg		= 6;		// didn't hold fixation at the target for long enough
declare hide int  goTarg		= 7;		// correct saccade on a go trial (cmanding)
declare hide int  nogoTarg		= 8;		// error noncanceled trial 
declare hide int  saccEarly		= 9;		// made a saccade before fixation offset
declare hide int  noSacc		= 10;		// didn't make a saccade after cued to do so (mem guided, reverse masking)
declare hide int  saccTarg		= 11;		// correct saccade (vis, del, mem, metacog)
declare hide int  bodyMove		= 12;		// error body movement (for training stillness)	
declare hide int  goDist		= 13;	// (choice countermanding): made a saccade to distractor on a go trial (=error)
declare hide int  nogoDist		= 14;	// (choice countermanding): made a saccade to distractor on a stop trial (=error)
declare hide int  checkerAbort	= 15;	// (choice countermanding): made a saccade to the checker stimulus (=abort)
declare hide int  brokeDist 	= 16;	// (choice countermanding): made a saccade to the checker stimulus (=abort)
declare hide int  saccDist		= 17;		// metacog masks
declare hide int  betAbort		= 18;		// metacog masks
declare hide int  brokeBet		= 19;		// metacog masks: did not hold bet target post-saccade fixation
declare hide int  highBet		= 20;		// metacog masks: did not hold bet target post-saccade fixation
declare hide int  lowBet		= 21;		// metacog masks: did not hold bet target post-saccade fixation
declare hide int  targHighBet	= 22;
declare hide int  distHighBet 	= 23;
declare hide int  targLowBet 	= 24;
declare hide int  distLowBet    = 25;

//VWM
declare hide int  hitCorSac     = 26;   //VWM correct identification of the test location (Hit&Correct localization)
declare hide int  hitIncSac     = 27;	//VWM misidentification of the test location (Hit & Incorrect localization)
declare hide int  cr            = 28;   //VWM correct rejection of the test item (CR)
declare hide int  miss          = 29;   //VWM failure of target recognition (Miss)
declare hide int  fa		    = 30;   //VWM false alarm (FA)
declare hide int  miscError     = 31;   //VWM eye went somewhere irrelevant...


//  Flags for keeping track of trial types	
declare hide int  goTrial 		= 0;			// 
declare hide int  stopTrial 	= 1;		// 
declare hide int  ignoreTrial 	= 2;			// 
declare hide int  nogoTrial 	= 3;			// 
declare hide int  tMaskTrial    = 4; 	// trial types for metacog suite of tasks
declare hide int  tBetTrial     = 5;
declare hide int  tRetroTrial   = 6;
declare hide int  tProTrial     = 7;



	
declare int		loadDefault = 1;			// a flag that determines whether DEFAULT.pro gets loaded when a protocol is loaded.
declare int		nTrial;
declare int		nTrialComplete;
declare int		Block_number;
declare int		nTrialArray[8];		// Keeps track of number of trials completed at each location
declare int 	nTrialPerTarget; 			// Gets set to stop the task after so nTrialPerTarget trials at each target
declare int		nTrialRemain; 				// Counts down to zero to end the task
declare int 	trialType;
declare int 	nObject;         // used to keep track of graph objects, so they can easily be destroyed in a while loop after exiting a task
	
declare int 	trl_running;  			// This variable makes the while loop work in each XXXTRIAL.pro file
declare int		success = 1;
declare int		failure = 0;
declare int		noChange = 2;


//----------------------------------------------------------------------------------------------------------------
// Trial type distributions (must sum to 100)
declare float	goPct;				// percentage of go trials
declare float	NogoPct;			// percentage of no-go trials
declare float	stopPct;			// percentage of stop trials
declare float	ignorePct;			// percentage of ignore trials

declare float	Bonus_weight;			// percentage of time that the subject is wrong but gets rewarded anyway.
declare float	Dealer_wins_weight;		// percentage of time that the subject is right but gets punished anyway.

declare float	BigR_weight;			// weights for random changes of reward targSize
declare float	MedR_weight;			// weights for random changes of reward targSize
declare float	SmlR_weight;			// weights for random changes of reward targSize
declare float	SmlP_weight;			// weights for random changes of punsiment targSize
declare float	MedP_weight;			// weights for random changes of punsiment targSize
declare float	BigP_weight;			// weights for random changes of punsiment targSize



//----------------------------------------------------------------------------------------------------------------
// Stimulus properties

// photodiode properties
declare hide float 	pdAmp;										
declare hide float	pdAngle;										
declare hide float 	opposite;										
declare hide float	adjacent;										
declare hide int   	open        = 0;		// used to draw squares either filled or open center								
declare hide int   	fill        = 1;										


declare float 	fixSize, fixAngle, fixAmp;        											
declare float 	targSize, targAngle, targAmp;        											
declare float 	distAngle, distAmp; 

declare int		Classic;				// emulates the old stop signal task
declare int		targColorArray[10,3];		// targColor of each target individually (see critique above)
declare int		stopColorArray[3];		// need to make this more finely adjustable for luminance matching
declare int		ignoreColorArray[3];	// need to make this more finely adjustable for luminance matching
declare int		fixColorArray[3];		// need to make this more finely adjustable for luminance matching
declare int		maskColorArray[3];		// need to make this more finely adjustable for luminance matching
declare int		highBetColorArray[3];		// need to make this more finely adjustable for luminance matching
declare int		lowBetColorArray[3];		// need to make this more finely adjustable for luminance matching
declare int		betFixColorArray[3];		// need to make this more finely adjustable for luminance matching
declare int		proFixColorArray[3];		// need to make this more finely adjustable for luminance matching
declare int   	targColor;								
declare int   	nogoColor;								
declare int 	fixColor 	= 255;				// used to send to VIDEOSYNC
declare int 	stopColor 	= 254;				// used to send to VIDEOSYNC
declare int 	ignoreColor 	= 253;				// used to send to VIDEOSYNC
declare int 	maskColor 	= 252;				// used to send to VIDEOSYNC
declare int 	highBetColor 	= 251;				// used to send to VIDEOSYNC
declare int 	lowBetColor 	= 250;				// used to send to VIDEOSYNC
declare int		betFixColor		= 249;
declare int		proFixColor 	= 248;
//VWM
declare int     redColor     = 247;
declare int     greenColor   = 246;
declare int     blueColor    = 245;
declare int     magentaColor = 244;
declare int     cyanColor    = 243;
declare int     yellowColor  = 242;
declare int     brownColor   = 241;
declare int     whiteColor   = 240;
declare int 	blackColor   = 239;//background
//

declare int		nTarg;					// number of target positions (need to calculate this based on user input)
declare float	sizeArray[9];			// targSize of each target individually (degrees)
declare float	angleArray[9];			// angle of each target individually (degrees)
declare float	ampDefault;	// distance of each target from center of screen individually (degrees)
declare float	ampArray[9];	// distance of each target from center of screen individually (degrees)

declare int		Set_Tones;				// sets up the tones to either high or low based on user input
declare int		Success_Tone_bigR;		// positive secondary reinforcer in Hz (large reward)
declare int		Success_Tone_medR;		// positive secondary reinforcer in Hz (medium reward)
declare int		Success_Tone_smlR;		// positive secondary reinforcer in Hz (small reward)		
declare int		Failure_Tone_smlP;		// negative secondary reinforcer in Hz (short timeout)
declare int		Failure_Tone_medP;		// negative secondary reinforcer in Hz (medium timeout)
declare int		Failure_Tone_bigP;		// negative secondary reinforcer in Hz (long timeout)
declare float	TargetSizeConversion; 	// For automatically setting the target targSize based on its eccentricity from fixation
declare int		AutoTargetSizeFlag;		// Sometimes want to set the target targSize automatically, sometimes themselves- this will allow option.
declare int		targDuration;			// For memory-guided saccades, sets the number of refreshes the target stays on before turing off


//----------------------------------------------------------------------------------------------------------------
// Amplitude task
declare float	trialAmp;			// The eccentricity of a trial in the amplitude task


//----------------------------------------------------------------------------------------------------------------
// Countermanding globals
declare int		ssd;
declare int		decideSSD = -1; 					// Set as a flag initially to alert the task that it's the first SSD of the session
declare int		decideIndex = -1; 					// Set as a flag initially to alert the task that it's the first SSD of the session
declare int		nIndex; 					// Set as a flag initially to alert the task that it's the first SSD of the session
declare int 	lastOutcome = 1;				// Global output used to staircase SSD
declare int 	randomAmpFlag;				// 0 if want same target eccentricity every trial, 1 if want it to vary across trials
declare int 	ampIndex;					//
declare int 	nTrialAmpSSD[4, 20], nSaccAmpSSD[4, 20];

//----------------------------------------------------------------------------------------------------------------
// Discriminatory (checkered) Stimulus properties 
declare int 	nCheckerColumn, nCheckerRow, nSquare;
declare float 	checkerAmp;
declare float 	checkerAngle;
declare float 	decideCheckerAngle;
declare int 	checkerTarg;
declare float 	iSquareSizePixels;
declare int 	nDiscriminate;					// number of possible discriminatory levels
declare float	maxDiscriminate;				// highest proportion of targColor 1 possible
declare float	minDiscriminate;				// lowest proportion of targColor 1 possible
declare float 	targetRightRate;  // Varied from .5 to bias one of the targets to appear more than the other
declare float 	fiftyPercentRate;  // For choice countermanding and go/no-go, used to determine how often to present trials with 50% coherence (even checker targColor proportions) RELATIVE TO THE OTHER PROPORTION TRIALS
									// For 7 levels of signal strength, fiftyPercentRate = 4/7 gives equal probability w.r.t other signal strengths, so use 4/7 as the factor


//----------------------------------------------------------------------------------------------------------------
// Choice countermanding 
declare float 	targ1PropArray[10];	  				// Checkered Stimulus properties
declare float 	trialDist[10], trialRate[10], trialRateBound[10];	  				// Trial distribution for the targ1PropArray, can be used to determine how often each trial is offered (trialRate)
declare int 	Targ2SquareColor[3], Targ1SquareColor[3];   // Checkered Stimulus properties
declare int 	checkerboardArray[100];  					// Checkered Stimulus properties
declare int 	nTrialPsySSD[15,15], nSaccPsySSD[15,15], nTarg1PsySSD[15,15];	// arrays to tally trial types 
declare int 	lastStopArray[15], decideSSDArray[15];   	// used to staircase SSDs indpendently in each discriminatory proportion
declare float 	targ1ExtraPct, targ2ExtraPct;
declare int 	checkerIsTarg;
declare float   checkerTargRate;
declare int 	distIndex;
declare int 	ccmDelayFlag;	 // logical used to determine whether to impose a delay (1) or not (0) before the cue to respond


//----------------------------------------------------------------------------------------------------------------
// psychometric function variables
declare float 	psyValue;			// The value of the discrimatory level (one of the values in the discriminatory stimulus array
declare int 	psyIndex;			// The index in the disciminatory stimulus array
declare int hide nTarg1Respond[10]; // To keep track of how many target 1 responses monkey makes


//----------------------------------------------------------------------------------------------------------------
// Go/No-go variables (go/no-go task)
declare float 	goPropArray[10];
declare float	goCheckerProp;
declare int 	NoGoSquareColor[3], GoSquareColor[3];
declare int 	proportionIndex;
declare int 	nPsy[10];
declare int 	nPsyRespond[10];

//----------------------------------------------------------------------------------------------------------------
declare float	fixWinSize;			// size of fixation window (degrees)
declare float	targWinSize;			// size of target window (degrees)
declare float	chkrWinSize;			// size of checker stimulus window (degrees) for choice countermanding
declare float	betWinSize;			// size of checker stimulus window (degrees) for choice countermanding


//----------------------------------------------------------------------------------------------------------------
// Task timing/reward/punishments paramaters (all times in ms unless otherwise specified)
declare int 	trialStartTime;
declare int		allowFixTime;		// subject has this long to acquire fixation before a new trial is initiated
declare int		expoJitterFlag;			// defines if exponential holdtime is used or if holdtime is sampled from rectanglular dist.
declare int		expoJitterFlag_SOA;		// defines if exponential holdtime is used for fixation offset in mem guided sacc task
declare int		holdtimeMin;			// minimum time after fixation before target presentation
declare int		holdtimeMax;			// maximum time after fixation before target presentation
declare int		soaMin;				// minimum time from target onset to fixation offset (mem guided only)
declare int		soaMax;				// maximum time from target onset to fixation offset (mem guided only)
declare int 	soa;				// next trial time between target onset and fixation offset
declare int		saccTimeMax;		// subject has this long to saccade to the target
declare int		saccDurationMax;		// once the eyes leave fixation they must be in the target before this time is up
declare int		targHoldtime;			// after saccade subject must hold fixation at target for this long
declare int		nSSD;					// number of stop signal delays (need to calculate this myself)
declare int		ssdMax;				// longest SSD
declare int		ssdMin;				// shortest SSD
declare int		Staircase;				// do we select the next SSD based on a staircasing algorithm?
declare float	ssdArray[12];			// needs to be in refresh rate units
declare int		holdStopDuration;				// subject must hold fixation for this long on a stop trial to be deemed canceled
declare int		toneDuration;			// how long should the error and success tones be presented?
declare int		rewardDelay;			// how long after tone before juice is given (needed to seperate primary and secondary reinforcement)
declare int		baseRewardDuration;		// how long will the juice solonoid remain open (monkeys are very interested in this varaible)
declare int		basePunishDuration;		// time out for messing up
declare int 	rewardDuration;			//GLOBAL OUTPUT FOR INFOS.pro will be set by END_TRL.pro
declare int 	punishDuration;				//GLOBAL OUTPUT FOR INFOS.pro will be set by END_TRL.pro
declare int 	toneChoiceSuccess;				//
declare int 	toneChoiceFailure;				//
declare int 	toneStopSuccess;				//
declare int 	toneStopFailure;				//
declare int 	toneAbort;				//
declare int 	toneTargHigh, toneTargLow, toneDistHigh, toneDistLow;				//
declare int		Bmove_tout;				// additive timeout imposed for each body movement
declare int		Move_ct;				// Output lets us know how many times the body has moved.
declare int		Max_move_ct;			// Setting maximum move_ct so monkey doesn't self-punish to eternity
declare int		TrainingStill;			// Indicates that we are using motion detector to train the monk to be still
declare int		Canc_alert;				// Alert operator that the monk has canceled a trial (during training)
declare int		fixedTrialDuration;		// 1 for fixed trial length, 0 for fixied inter trial intervals
declare int		trialDuration;			// fixed at this value (only works if fixedTrialDuration == 1) must figure out max time for this variable and include it in comments
declare int		interTrialDuration;			// how long between trials (only works if fixedTrialDuration == 0)




//----------------------------------------------------------------------------------------------------------------
// Metacognition with masking
declare float maskAmpArray[4], maskAngleArray[4], betAmpArray[2], betAngleArray[2];  // locations of targets, masks, bets
declare float maskSize, betSize;
declare int maskPct, betPct, retroPct, proPct;  		// percentage of each metacog trial type-- sum must add to 100
declare int nBet = 2; 										// number of bet targets
declare float highBetAngle, lowBetAngle, acceptBetAngle;
declare float highBetAmp, lowBetAmp;
declare float targetRightRate, highBetRightRate;
declare int soaArray[10];
declare int nSOA, decideSOA;
declare int lastMaskOutcome;							// used to staircase the soa if we want to
declare int lastMaskArray[4], decideSOAArray[4];		// for staircasing SOA at each target location
declare float fakeCorrectRate;



//----------------------------------------------------------------------------------------------------------------
// Metacognition with masking
declare int stimDuration = 2;

//----------------------------------------------------------------------------------------------------------------
// VWM task
declare int setSizeArray[12]; //define the setsize value for each condition
declare int sameDiffArray[12];// define the same or diff for each condition
declare int nTrialsArray[12];// define the number of trials for each condition
declare int condCounterArray[12];//keep track of the number of trials run for each condition

declare int vwmColorArray[9,3];
declare float vwmAngleArray[4];//original had 8

//for trial setup
//declare float LocArray[4];//original had 6
declare float LocArray[4];//original had 6
declare int ColorArray[7]; //refers to the color pallette

declare int memRefresh = 70; //mem duration has to be determined by the number of refresh cycle, 10 = 167 msec for 60hz monitor
declare int retDuration = 2000;
declare int fixDuration = 1000;
declare int saccadeInitiationDuration = 1000;
declare int testDuration = 600;
declare int testRefresh = 70; //70
declare int testHoldDuration = 1000;//400 1000
declare int nTrialsperCond = 20;
declare float testAmp = 0.0; //defines the amplitude of the test stimulus
declare int lorr = 0;

//performance monitoring
declare int vwm_performance[24];//first 4 corr_sac, next 4 inc_sac, next4 broke_targ, last 4 broke_fix
//declare int inc_sac[4];
//declare int broke_targ[4];
//declare int broke_fix[4];





//--------------------------------------------------------------------------------------------------
// process AMP_PGS();
//
// Figure out all stimuli that will be needed on the next visually guided saccade trial and
// place it all into video memory.
//


declare AMP_PGS();                       										// see GRAPHS.pro

process AMP_PGS()	                       										// see GRAPHS.pro
{										
										

// number the pgs that need to be drawn
declare hide int   	blank       		= 0;	
declare hide int	pd					= 1;
declare hide int	fixation_pd			= 2;										
declare hide int	fixation    		= 3;
declare hide int	target_pd			= 4;	
declare hide int	target		   		= 5;										

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Calculate screen coordinates for stimuli on this trial								
if (AutoTargetSizeFlag)
	{
	targSize        	 	= targAmp * TargetSizeConversion;   			// Figure out the attributes of the current target
	}
else
	{
	targSize				= sizeArray[targIndex];
	}
targColor        = targIndex + 1;																// zero is reserved for black.  see SET_CLRS.pro							
												


opposite = ((screenHeight/2)-pdBottom);														// Figure out angle and eccentricity of photodiode marker in pixels
adjacent = ((screenWidth/2)-pdLeft);                                                         // NOTE: I am assuming your pd is in the lower left quadrant of your screen
pdAmp = sqrt((opposite * opposite) + (adjacent * adjacent));
pdAngle = rad2deg(atan (opposite / adjacent));
pdAngle = pdAngle + 180; 																	//change this for different quadrent or write some code for flexibility

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 1
// print("photodiode");
dsendf("rw %d,%d;\n",pd,pd);				 												// draw first pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker	
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 2
// print("fixation with photodiode");
dsendf("rw %d,%d;\n",fixation_pd,fixation_pd); 												// draw second pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 3	  
// print("fixation");
dsendf("rw %d,%d;\n",fixation,fixation);   													// draw 3rd pg of video memory                                       
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 4	  
// print(target and photodiode");
dsendf("rw %d,%d;\n",target_pd,target_pd);   								// draw 4th pg of video memory                                       
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 5	  
// print("target");
dsendf("rw %d,%d;\n",target,target);  														// draw pg 6                                        
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);         	// draw target
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 0 (last is displayed first)	
// print("blank"); 																			
dsendf("rw %d,%d;\n",blank,blank);                                          				// draw the blank screen last so that it shows up first
dsendf("cl:\n");                                                                            // clear screen (that's all)

}//--------------------------------------------------------------------------------------------
// Run a memory guided saccade trial based on the variables calculated by SETV_TRL.pro and 
// those given by the user.  Adapted from CMDTRIAL.
//
// 11-2011: Created by adapting VISTRIAL.pro -pgm


declare AMPTRIAL();		

process AMPTRIAL()        	
	{
	
	
	// Number the trial stages to make them easier to read below
	declare hide int 	need_fix  	= 1;
	declare hide int 	fixating  	= 2;
	declare hide int 	targ_on   	= 3;
	declare hide int	fix_off		= 4;
	declare hide int 	in_flight 	= 5;
	declare hide int 	on_target 	= 6;	
	declare hide int 	stage;
	
	// Number the stimuli pages to make reading easier
	declare hide int   	blank       		= 0;
	declare hide int	pd					= 1;
	declare hide int	fixation_pd 		= 2;
	declare hide int	fixation    		= 3;
	declare hide int	target_pd   		= 4;	
	declare hide int	target      		= 5;
	
	  
	// Timing variables which will be used to time task
	declare hide float 	fix_on_time; 	
	declare hide float 	aquire_fix_time;
	declare hide float  targ_time;	
	declare hide float  saccade_time;
	declare hide float	aquire_targ_time;	
	
	
	// Have to be reset on every iteration since 
	// variable declaration only occurs at load time
	trl_running 		= 1;
	stage 				= need_fix;
	
	// Tell the user what's up
	printf(" \n");
	printf("# %d\n",nTrial);
	printf(" \n");
	printf("Amplitude %.1d\n", targAmp);

	
	
																			// HERE IS WHERE THE FUN BEGINS
	Event_fifo[Set_event] = TrialStart_;									// queue TrialStart_ strobe
	Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
	dsendf("vp %d\n",fixation_pd);											// flip the pg to the fixation stim with pd marker
	fix_on_time = time();  													// record the time
	Event_fifo[Set_event] = FixSpotOn_;										// queue strobe
	Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
	dsendf("XM RFRSH:\n"); 													// wait for one retrace
	dsendf("vp %d\n",fixation);												// flip the pg to the fixation stim without pd marker
	oSetAttribute(object_fix, aVISIBLE); 									// turn on the fixation point in animated graph
	
	
	while (trl_running)														// trials ending will set trl_running = 0
		{	
		
	//--------------------------------------------------------------------------------------------
	// STAGE need_fix (the fixation point is on, but the subject hasn't looked at it)
		if (stage == need_fix)
			{		
			if (In_FixWin)													// If the eyes have entered the fixation window (before time, see below)...
				{
				aquire_fix_time = time();									// ...function call to time to note current time and...
				trialStartTime = aquire_fix_time;							// Global output for timing iti
				Event_fifo[Set_event] = Fixate_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				stage = fixating;											// ...advance to the next stage.
				}
			else if (time() > fix_on_time + allowFixTime)				// But if time runs out...
				{
				trialOutcome = noFix;    									// TRIAL OUTCOME ABORT (no fixation)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen,...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Aborted (no fixation)\n");							// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}			
			}
			
			

	//--------------------------------------------------------------------------------------------
	// STAGE fixating (the subject is looking at the fixation point waiting for target onset)		
		else if (stage == fixating)
			{
			if (!In_FixWin && time() > aquire_fix_time + 100)													// If the eyes stray out of the fixation window...
				{
				trialOutcome = brokeFix;									// TRIAL OUTCOME ABORT (broke fixation)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}
			else if (In_FixWin && time() > aquire_fix_time + preTargHoldtime)	// But if the eyes are still in the window at end of holdtime...
				{
				dsendf("vp %d\n",target_pd);						// ...flip the pg to the target with pd marker...	
				targ_time = time(); 										// ...record the time...
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				dsendf("vp %d\n",target);							// ...flip the pg to the target point without pd marker.
		
							
				oSetAttribute(object_targ, aVISIBLE); 						// ...show target in animated graph...
														
				stage = targ_on;											// Advance to the next trial stage.				
				}
			}
			
			

	//--------------------------------------------------------------------------------------------
	// STAGE targ_on (the target has been presented but the subject is still fixating)		
		else if (stage == targ_on)
			{		
			if (!In_FixWin)													// If the eyes leave the fixation window...			
				{															// ...we have a saccade, so...
				saccade_time = time();										// ...record the time...
				Event_fifo[Set_event] = Saccade_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				printf("                          rt = %d\n",saccade_time - targ_time);	// ...tell the user whats up...
				stage = in_flight;											// ...and advance to the next stage.
				}
			
			else if (In_FixWin &&  											// But if no saccade occurs...
				time() > targ_time + saccTimeMax) 					// ...and time for a saccade runs out...
				{
				trialOutcome = noSacc;           							// TRIAL OUTCOME ERROR (no saccade after cue)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (no saccade)\n");								// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}	
			}


			
			
	//--------------------------------------------------------------------------------------------
	// STAGE in_flight (eyes have left fixation window but have not entered target window)		
		else if (stage == in_flight)
			{
			if (In_TargWin)													// If the eyes get into the target window...
				{
				dsendf("vp %d\n",target_pd);								// ...flip the pg to the target with pd marker...	
				aquire_targ_time = time(); 									// ...record the time...
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				dsendf("vp %d\n",target);									// ...flip the pg to the target without pd marker.
				Event_fifo[Set_event] = Decide_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				stage = on_target;											// ...and advance to the next stage of the trial.
				}
			else if (time() > saccade_time + saccDurationMax)				// But, if the eyes are out of the target window and time runs out...
				{
				trialOutcome = saccOut;   									// TRIAL OUTCOME ERROR (innacurrate saccade)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (inaccurate saccade)\n");						// ...tell the user whats up...
				trl_running = 0; 											// ...and terminate the trial.
				}
			}
		
		
		
	//--------------------------------------------------------------------------------------------
	// STAGE on_target (eyes have entered the target window.  will they remain there for duration?)	
		else if (stage == on_target)
			{
			if (!In_TargWin)												// If the eyes left the target window...
				{			
				trialOutcome = brokeTarg;									// TRIAL OUTCOME ERROR (broke target fixation)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (broke target fixation)\n");					// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}		
			else if (In_TargWin  											// But if the eyes are still in the target window...
				&&  time() > aquire_targ_time + targHoldtime)				// ...and the target hold time is up...				
				{
				trialOutcome = saccTarg;									//TRIAL OUTCOME CORRECT (correct sacc trial)
				Event_fifo[Set_event] = Correct_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				printf("Correct (saccade)\n");								// ...tell the user whats up...
				dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				trl_running = 0;											// ...and terminate the trial.
				}			
			}
			
		nexttick;
		}
	}//--------------------------------------------------------------------------------------------------
// process BET_PGS();
//
// Figure out all stimuli that will be needed on the next mem guided trial and
// place it all into video memory.
//
// written by david.c.godlove@vanderbilt.edu 	July, 2011


declare BET_PGS();                       										// see GRAPHS.pro

process BET_PGS()	                       										// see GRAPHS.pro
{

// number the pgs that need to be drawn
declare hide int   	blank       		= 0;
declare hide int	pd					= 1;
declare hide int	betFix_pd			= 2;
declare hide int	betFix    			= 3;
declare hide int	fix_bet_pd			= 4;
declare hide int	fix_bet				= 5;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Calculate screen coordinates for stimuli on this trial


opposite = ((screenHeight/2)-pdBottom);														// Figure out angle and eccentricity of photodiode marker in pixels
adjacent = ((screenWidth/2)-pdLeft);                                                         // NOTE: I am assuming your pd is in the lower left quadrant of your screen
pdAmp = sqrt((opposite * opposite) + (adjacent * adjacent));
pdAngle = rad2deg(atan (opposite / adjacent));
pdAngle = pdAngle + 180; 																	//change this for different quadrent or write some code for flexibility

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 1
// print("betFix with photodiode");
dsendf("rw %d,%d;\n",betFix_pd,betFix_pd); 												// draw second pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 2
// print("betFix with photodiode");
dsendf("rw %d,%d;\n",betFix,betFix); 												// draw second pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
nexttick;



//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 4
// print("betFix target and photodiode");
dsendf("rw %d,%d;\n",fix_bet_pd,fix_bet_pd);   								// draw 4th pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
spawnwait DRW_SQR(betSize, highBetAngle, highBetAmp, highBetColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
spawnwait DRW_SQR(betSize, lowBetAngle, lowBetAmp, lowBetColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 5
// print("fixation target and photodiode");
dsendf("rw %d,%d;\n",fix_bet,fix_bet);   								// draw 4th pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
spawnwait DRW_SQR(betSize, highBetAngle, highBetAmp, highBetColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
spawnwait DRW_SQR(betSize, lowBetAngle, lowBetAmp, lowBetColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
nexttick;


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 0 (last is displayed first)
// print("blank");
dsendf("rw %d,%d;\n",blank,blank);                                          				// draw the blank screen last so that it shows up first
dsendf("cl:\n");                                                                            // clear screen (that's all)

}//--------------------------------------------------------------------------------------------
// Run a bet trial based on the variables calculated by SETCCTRL.pro and those 
// given by the user.
//

declare hide int lastOutcome = 1;	// Global output used to staircase SSD
declare int nSuccess;

declare BETTRIAL();			// animated graph object

process BETTRIAL()        		// animated graph object
{


// Number the trial stages to make them easier to read below
declare hide int 	need_fix  		= 1;
declare hide int 	fixating  		= 2;
declare hide int 	bet_on   		= 3;
declare hide int 	in_flight 		= 4;
declare hide int 	on_Highbet 		= 5;	
declare hide int 	on_Lowbet 		= 6;	
declare hide int 	stage;

// number the pgs that need to be drawn
declare hide int   	blank       		= 0;
declare hide int	pd					= 1;
declare hide int	betFix_pd			= 2;
declare hide int	betFix    			= 3;
declare hide int	fix_bet_pd			= 4;
declare hide int	fix_bet				= 5;

											
// Timing variables which will be used to time task
declare hide float 	fix_spot_time; 					
declare hide float  betTarg_time; 					
declare hide float  fix_off_time; 					
declare hide float  saccade_time;
declare hide float 	aquire_fix_time;
declare hide float	aquire_bet_time;	



opposite = ((screenHeight/2)-pdBottom);														// Figure out angle and eccentricity of photodiode marker in pixels
adjacent = ((screenWidth/2)-pdLeft);                                                         // NOTE: I am assuming your pd is in the lower left quadrant of your screen
pdAmp = sqrt((opposite * opposite) + (adjacent * adjacent));
pdAngle = rad2deg(atan (opposite / adjacent));
pdAngle = pdAngle + 180; 																	//change this for different quadrent or write some code for flexibility


// Have to be reset on every iteration since 
// variable declaration only occurs at load time
trl_running 		= 1;
stage 				= need_fix;

// Tell the user what's up
printf(" \n");
printf(" ********   BET TRIAL   ********\n");
printf("# %d",nTrial);
printf(" (%d complete)\n",nTrialComplete);
printf("preBet Holdtime = %d\n",preBetHoldtime);


																		// HERE IS WHERE THE FUN BEGINS
Event_fifo[Set_event] = TrialStart_;									// queue TrialStart_ strobe
Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
dsendf("vp %d\n",betFix_pd);											// flip the pg to the fixation stim with pd marker
fix_spot_time = time();  													// record the time
Event_fifo[Set_event] = FixSpotOn_;										// queue strobe
Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
dsendf("XM RFRSH:\n"); 													// wait for one retrace
dsendf("vp %d\n",betFix);												// flip the pg to the fixation stim without pd marker
oSetAttribute(object_fix, aVISIBLE); 									// turn on the fixation point in animated graph


while (trl_running)														// trials ending will set trl_running = 0
	{	
	
//--------------------------------------------------------------------------------------------
// STAGE need_fix (the fixation point is on, but the subject hasn't looked at it)
	if (stage == need_fix)
		{		
		if (In_FixWin && time() > aquire_fix_time + 200)													// If the eyes have entered the fixation window (before time, see below)...
			{
			aquire_fix_time = time();									// ...function call to time to note current time and...
			trialStartTime = aquire_fix_time;							// Global output for timing iti
			Event_fifo[Set_event] = BetFixate_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = fixating;											// ...advance to the next stage.
			}
		else if (time() > fix_spot_time + allowFixTime)				// But if time runs out...
			{
			trialOutcome = noFix;    									// TRIAL OUTCOME ABORT (no fixation)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen,...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Aborted (no fixation)\n");							// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}			
		}
		
		

//--------------------------------------------------------------------------------------------
// STAGE fixating (the subject is looking at the fixation point waiting for target onset)		
	else if (stage == fixating)
		{
		if (!In_FixWin)													// If the eyes stray out of the fixation window...
			{
			trialOutcome = brokeFix;									// TRIAL OUTCOME ABORT (broke fixation)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}
		else if (In_FixWin && time() > aquire_fix_time + preBetHoldtime)	// But if the eyes are still in the window at end of holdtime...
			{
			dsendf("vp %d\n",fix_bet_pd);						// ...flip the pg to the target with pd marker...	
			betTarg_time = time(); 										// ...record the time...
			dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
			dsendf("vp %d\n",fix_bet);						// ...flip the pg to the target with pd marker...	
	
			oSetAttribute(object_highBet, aVISIBLE); 						// ...show target in animated graph...
			oSetAttribute(object_lowBet, aVISIBLE); 						// ...show target in animated graph...
													
			stage = bet_on;											// Advance to the next trial stage.				
			}
		}
		
		

	

//--------------------------------------------------------------------------------------------
// STAGE bet_on (the fixation spot has been extinguished but the masks are still visible)		
	else if (stage == bet_on)
		{		
		if (!In_FixWin)													// If the eyes leave the fixation window...
			{															// ...we have a saccade, so...
			saccade_time = time();										// ...record the time...
			Event_fifo[Set_event] = Saccade_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			// dsendf("vp %d\n",target);									// Flip the pg to the blank screen...
			printf("           rt = %d\n",saccade_time - betTarg_time);	// ...tell the user whats up...
			stage = in_flight;											// ...and advance to the next stage.
			}
		else if (In_FixWin &&  											// But if no saccade occurs...
			time() > betTarg_time + saccTimeMax)					// ...and time for a saccade runs out...
			{
			trialOutcome = betAbort;           							// TRIAL OUTCOME ERROR
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_highBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_lowBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (no saccade)\n");								// ...tell the user whats up...
			spawn SVR_BELL();
			trl_running = 0;											// ...and terminate the trial.
			}				
		}
		
		
		
//--------------------------------------------------------------------------------------------
// STAGE in_flight (eyes have left fixation window but have not entered either bet window)		
	else if (stage == in_flight)
		{
		if (In_HighBetWin)													// If the eyes get into the target window...
			{
			aquire_bet_time = time();									// ...record the time...
			Event_fifo[Set_event] = Decide_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = on_HighBet;											// ...and advance to the next stage of the trial.
			Event_fifo[Set_event] = HighBet_;					// ...queue strobe for Neuro Explorer
			Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.					
			}
		else if (In_LowBetWin)											// If the eyes get into the distractor window...
			{
			aquire_bet_time = time();									// ...record the time...
			Event_fifo[Set_event] = Decide_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = on_LowBet;										// ...and advance to the next stage of the trial.
			Event_fifo[Set_event] = LowBet_;					// ...queue strobe for Neuro Explorer
			Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.					
			}
		else if (time() > saccade_time + saccDurationMax)				// But, if the eyes are out of the target window and time runs out...
			{
			trialOutcome = betAbort;   									// TRIAL OUTCOME ERROR (innacurrate saccade)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_highBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_lowBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (inaccurate saccade)\n");						// ...tell the user whats up...
			spawn SVR_BELL();
			trl_running = 0; 											// ...and terminate the trial.
			}
		}
	
	
	
//--------------------------------------------------------------------------------------------
// STAGE on_HighBet (eyes have entered the target window.  will they remain there for duration?)	
	else if (stage == on_HighBet)
		{
		if (!In_HighBetWin)												// If the eyes left the target or distractor window...
			{			
			trialOutcome = brokeBet;									// TRIAL OUTCOME ERROR (broke target fixation)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_highBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_lowBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (broke bet target fixation)\n");					// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}		
		else if (In_HighBetWin  											// But if the eyes are still in the target window...
			&&  time() > aquire_bet_time + targHoldtime)				// ...and the target hold time is up...
			{
			betOutcome = highBet;								//TRIAL OUTCOME CORRECT (correct go trial)
			printf("High Bet (saccade)\n");							// ...tell the user whats up...
			dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
			oSetAttribute(object_highBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_lowBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			trl_running = 0;											// ...and terminate the trial.
			if (maskOutcome == saccTarg)
				{
				trialOutcome = targHighBet;
				}
			else if (maskOutcome == saccDist)
				{
				trialOutcome = distHighBet;
				}
			}			
		}
		

// STAGE on_LowBet (eyes have entered the distractor window.  will they remain there for duration?)	
	else if (stage == on_LowBet)
		{
		if (!In_LowBetWin)												// If the eyes left the distractor or distractor window...
			{			
			trialOutcome = brokeBet;									// TRIAL OUTCOME ERROR (broke target fixation)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_highBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_lowBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (broke bet target fixation)\n");				// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}		
		else if (In_LowBetWin  											// But if the eyes are still in the target window...
			&&  time() > aquire_bet_time + targHoldtime)				// ...and the target hold time is up...
			{
			betOutcome = lowBet;								//TRIAL OUTCOME CORRECT (correct go trial)
			printf("Low Bet (saccade)\n");	//pgm						// ...tell the user whats up...
			dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
			oSetAttribute(object_highBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_lowBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			trl_running = 0;											// ...and terminate the trial.
			if (maskOutcome == saccTarg)
				{
				trialOutcome = targLowBet;
				}
			else if (maskOutcome == saccDist)
				{
				trialOutcome = distLowBet;
				}
			}			
		}
		
	nexttick;
	}
}//--------------------------------------------------------------------------------------------------
// process CCM_PGS();
//
// Figure out all stimuli that will be needed on the next countermanding trial and
// place it all into video memory.
//
// 11-2011: Based on CMD_PGS, integrated choice countermanding task into ALL_PROS.pro. -pgm



declare CCM_PGS();                       										// see GRAPHS.pro

process CCM_PGS()                        										// see GRAPHS.pro
{										
										
// number the pgs that need to be drawn
declare hide int   	blank       = 0;										
// declare hide int	fixation_pd = 1;										
// declare hide int	fixation    = 2;										
declare hide int	target_pd   = 1;										
declare hide int	target      = 2;										
declare hide int	choice_pd   = 3;										
declare hide int	choice      = 4;										
declare hide int	signal_pd   = 5;										
declare hide int	signal      = 6;

declare int changeStimulus = 1;
declare int keepStimulus = 0;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Calculate screen coordinates for stimuli on this trial
if (AutoTargetSizeFlag)
	{
	targSize        	 	= targAmp * TargetSizeConversion;   			// Figure out the attributes of the current target
	}
else
	{
	targSize				= sizeArray[targIndex];
	}

targColor        = targIndex + 1;																// zero is reserved for black.  see SET_CLRS.pro

	
										

opposite = ((screenHeight/2)-pdBottom);											// Figure out angle and eccentricity of photodiode marker in pixels
adjacent = ((screenWidth/2)-pdLeft);                                        	// NOTE: I am assuming your pd is in the lower left quadrant of your screen
pdAmp = sqrt((opposite * opposite) + (adjacent * adjacent));
pdAngle = rad2deg(atan (opposite / adjacent));
pdAngle = pdAngle + 180; 														//change this for different quadrent or write some code for flexibility


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 1
// print("fixation with photodiode");
// dsendf("rw %d,%d;\n",fixation_pd,fixation_pd); 												// draw first pg of video memory
// dsendf("cl:\n");																			// clear screen
// spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
// spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 2	  
// print("fixation");
// dsendf("rw %d,%d;\n",fixation,fixation);   													// draw second pg of video memory                                       
// dsendf("cl:\n");																			// clear screen
// spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
// nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 1	 
// print("target with photodiode");
dsendf("rw %d,%d;\n",target_pd,target_pd);  												// draw pg 3                                        
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          // draw target
spawnwait DRW_SQR(targSize, distAngle, distAmp, targColor, fill, deg2pix_X, deg2pix_Y);    	// draw distractor
if (!Classic)																				// if we are doing stop-signal 2.0 (not classic)
	{
	spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y); // draw fixation point
	}
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 2	  
// print("target");
dsendf("rw %d,%d;\n",target,target);  														// draw pg 4                                        
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);         	// draw target
spawnwait DRW_SQR(targSize, distAngle, distAmp, targColor, fill, deg2pix_X, deg2pix_Y);     	// draw distractor
if (!Classic)																				// if we are doing stop-signal 2.0 (not classic)
	{
	spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
	}
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 3	 
// print("choice stim with photodiode");
dsendf("rw %d,%d;\n",choice_pd,choice_pd);  												// draw pg 3                                        
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          // draw target
spawnwait DRW_SQR(targSize, distAngle, distAmp, targColor, fill, deg2pix_X, deg2pix_Y);    	// draw distractor
if (!Classic)																				// if we are doing stop-signal 2.0 (not classic)
	{
	if (ccmDelayFlag)
		{
		spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y); // draw fixation point
		}
	else
		{
		spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, open, deg2pix_X, deg2pix_Y); // draw fixation point
		}
	}
spawnwait DRW_CHKR(changeStimulus);  														// draw checkered stimulus
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 4	  
// print("choice stim");
dsendf("rw %d,%d;\n",choice,choice);  														// draw pg 4                                        
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);         	// draw target
spawnwait DRW_SQR(targSize, distAngle, distAmp, targColor, fill, deg2pix_X, deg2pix_Y);     	// draw distractor
if (!Classic)																				// if we are doing stop-signal 2.0 (not classic)
	if (ccmDelayFlag)
		{
		spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y); // draw fixation point
		}
	else
		{
		spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, open, deg2pix_X, deg2pix_Y); // draw fixation point
		}
spawnwait DRW_CHKR(keepStimulus);  															// draw checkered stimulus
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 7 
// print("signal with photodiode");
dsendf("rw %d,%d;\n",signal_pd,signal_pd);    												// draw pg 5                                      
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);         	// draw target
spawnwait DRW_SQR(targSize, distAngle, distAmp, targColor, fill, deg2pix_X, deg2pix_Y);    	// draw distractor
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, open, deg2pix_X, deg2pix_Y); // draw fixation point
spawnwait DRW_SQR(fixSize*1, fixAngle, fixAmp, signalColor, fill, deg2pix_X, deg2pix_Y);   		// draw stop signal/ignore stim
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
	spawnwait DRW_CHKR(keepStimulus);  	
// if (!ccmDelayFlag)
	// {
	// }														// draw checkered stimulus
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 8	 
// print("signal");
dsendf("rw %d,%d;\n",signal,signal);   														// draw pg 6                                       					
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          // draw target
spawnwait DRW_SQR(targSize, distAngle, distAmp, targColor, fill, deg2pix_X, deg2pix_Y); 		// draw distractor
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, open, deg2pix_X, deg2pix_Y); // draw fixation point
spawnwait DRW_SQR(fixSize*1, fixAngle, fixAmp, signalColor, fill, deg2pix_X, deg2pix_Y);   		// draw stop signal/ignore stim
	spawnwait DRW_CHKR(keepStimulus);  	
// if (!ccmDelayFlag)
	// {
	// }														// draw checkered stimulus
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 0 (last is displayed first)	
// print("blank"); 																			
dsendf("rw %d,%d;\n",blank,blank);                                          				// draw the blank screen last so that it shows up first
dsendf("cl:\n");                                                                            // clear screen (that's all)


}
//--------------------------------------------------------------------------------------------
// Run a choice countermanding trial based on the variables calculated by SETCCTRL.pro and those 
// given by the user.
//
// 11-2011: Adapted from CMDTRIAL and integrated choice countermanding task into ALL_PROS.pro. -pgm

declare int nSuccess;

declare CCMTRIAL();			// animated graph object

process CCMTRIAL()        		// animated graph object
{


// Number the trial stages to make them easier to read below
declare hide int 	need_fix  		= 1;
declare hide int 	fixating  		= 2;
declare hide int 	targ_on   		= 3;
declare hide int 	choice_on  		= 4;
declare hide int 	in_flight 		= 5;
declare hide int 	on_target 		= 6;	
declare hide int 	on_distractor 	= 7;	// pgm
declare hide int 	choice_delay 	= 8;	// pgm
declare hide int 	stage;

// Number the stimuli pages to make reading easier
declare hide int   	blank       = 0;
// declare hide int	fixation_pd = 1;
// declare hide int	fixation    = 2;
declare hide int	target_pd   = 1;
declare hide int	target      = 2;
declare hide int	choice_pd   = 3;										
declare hide int	choice      = 4;										
declare hide int	signal_pd   = 5;										
declare hide int	signal      = 6;

											
// Timing variables which will be used to time task
declare hide float 	fix_spot_time; 					
declare hide float  targ_time; 					
declare hide float  cue_time; 					
declare hide float  saccade_time;
declare hide float 	aquire_fix_time;
declare hide float 	stop_sig_time;
declare hide float	aquire_targ_time;	
declare hide float	aquire_dist_time;	
declare hide float	aquire_chkr_time;
	
declare int			ssdMS;		// ssd in ms, not in screen flips	
declare int 		preSSDResponse;

// Have to be reset on every iteration since 
// variable declaration only occurs at load time
trl_running 		= 1;
stage 				= need_fix;
preSSDResponse 	= 0;
ssdMS = round(ssd * (1000.0/screenRefreshRate));


// Tell the user what's up
printf(" \n");
printf("# %d",nTrial);
printf(" (%d complete)\n",nTrialComplete);
if (trialType == goTrial)
	{
	printf("GO\n");
	// if (targ1targ2Flag == 0)
		// printf("BLUE\n");
	// else if (targ1targ2Flag == 1)
		// printf("RED\n");
	}
if (trialType == stopTrial)
	{
	printf("*** STOP ***\n");
	printf(" Successful stops: %d\n", nSuccess);
	// if (targ1targ2Flag == 0)
		// printf("BLUE\n");
	// else if (redBlueFlag == 1)
		// printf("RED\n");
	printf("                      ssd = %d\n", ssdMS);
	}
if (trialType == ignoreTrial)
	{
	printf("IGNORE\n");
	printf("               isd = %d\n", ssdMS);
	}
	// printf("   Target 1 Proportion = %.2d\n", psyValue);
	printf("pre-target holdtime = %d\n",preTargHoldtime);
	printf("post-target holdtime = %d\n",postTargHoldtime);
	printf("             Target 1 Pct = %d\n", targ1CheckerProp*100);
	
	printf("             Delay = %d\n", soa);


																		// HERE IS WHERE THE FUN BEGINS
Event_fifo[Set_event] = TrialStart_;									// queue TrialStart_ strobe
Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
// dsendf("vp %d\n",fixation_pd);											// flip the pg to the fixation stim with pd marker
// dsendf("rw %d,%d;\n",fixation_pd,fixation_pd); 												// draw first pg of video memory
// dsendf("cl:\n");																			// clear screen
spawn DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
dsendf("XM RFRSH:\n"); 													// wait one vertical retrace	
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,0,fill,unit2pix_X,unit2pix_Y);			// erase photodiode marker
fix_spot_time = time();  												// record the time
Event_fifo[Set_event] = FixSpotOn_;										// queue strobe
Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
// dsendf("XM RFRSH:\n"); 													// wait one vertical retrace	
// dsendf("vp %d\n",fixation);												// flip the pg to the fixation stim without pd marker
oSetAttribute(object_fix, aVISIBLE); 									// turn on the fixation point in animated graph


while (trl_running)														// trials ending will set trl_running = 0
	{	
	
//--------------------------------------------------------------------------------------------
// STAGE need_fix (the fixation point is on, but the subject hasn't looked at it)
	if (stage == need_fix)
		{		
		if (In_FixWin)													// If the eyes have entered the fixation window (before time, see below)...
			{
			aquire_fix_time = time();									// ...function call to time to note current time and...
			trialStartTime = aquire_fix_time;							// Global output
			Event_fifo[Set_event] = Fixate_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = fixating;											// ...advance to the next stage.
			}
		else if (time() > fix_spot_time + allowFixTime)				// But if time runs out...
			{
			trialOutcome = noFix;    									// TRIAL OUTCOME ERROR (no fixation)
			lastOutcome = noChange;								// Don't change SSD
			spawn DRW_SQR(fixSize, fixAngle, fixAmp, 0, fill, deg2pix_X, deg2pix_Y);   	// erase fixation point
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Aborted (no fixation)\n");							// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}			
		}
		
		

//--------------------------------------------------------------------------------------------
// STAGE fixating (the subject is looking at the fixation point waiting for target onset)		
	else if (stage == fixating)
		{
		if (!In_FixWin && time() > aquire_fix_time + 200)													// If the eyes stray out of the fixation window...
			{
			trialOutcome = brokeFix;									// TRIAL OUTCOME ERROR (broke fixation)
			lastOutcome = noChange;								// Don't change SSD
			spawn DRW_SQR(fixSize, fixAngle, fixAmp, 0, fill, deg2pix_X, deg2pix_Y);   	// erase fixation point
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}
		else if (In_FixWin && time() > aquire_fix_time + preTargHoldtime)	// But if the eyes are still in the window at end of holdtime...
			{
			dsendf("vp %d\n",target_pd);								// ...flip the pg to the target with pd marker...	
			targ_time = time(); 										// ...record the time...
			dsendf("XM RFRSH:\n"); 										// ...wait one vetical retrace...
			dsendf("vp %d\n",target);									// ...flip the pg to the target without pd marker.
			// Reset the blank page as blank so we can easily flip to it 																			
			dsendf("rw %d,%d;\n",blank,blank);                                          				// draw the blank screen last so that it shows up first
			dsendf("cl:\n");                                                                            // clear screen (that's all)
			

				
			Event_fifo[Set_event] = Target_;						// Queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			
																		// Now the animated graphs have to catch up (seperate so that stim timing stays tight)
			oSetAttribute(object_targ, aVISIBLE); 					// ...show target in animated graph...
				


				stage = targ_on;											// Advance to the next trial stage.				
			}
		}
		
		

//--------------------------------------------------------------------------------------------
// STAGE targ_on (the subject is looking at the fixation point waiting for checkerboard onset)		
	else if (stage == targ_on)
		{
		if (!In_FixWin)													// If the eyes stray out of the fixation window...
			{
			trialOutcome = brokeFix;									// TRIAL OUTCOME ERROR (broke fixation)
			lastOutcome = noChange;								// Don't change SSD
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			spawn SVR_BELL();
			printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}
		else if (In_FixWin && time() > targ_time + postTargHoldtime)	// But if the eyes are still in the window at end of holdtime...
			{
			dsendf("vp %d\n",choice_pd);								// ...flip the pg to the choice stim pd marker...	
			cue_time = time(); 										// ...record the time...
			dsendf("XM RFRSH:\n"); 										// ...wait one vetical retrace...
			dsendf("vp %d\n",choice);									// ...flip the pg to the choice stim without pd marker.
			Event_fifo[Set_event] = Choice_;						// Queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...

			// If delaying the cue to respond, just go to stage delay_on- else wait for stop signal, etc, here
			if (ccmDelayFlag)
				{
				// If we're doing choice countermanding with a delay, kludge here:
				// Reset the target pages to the page(s) that will cue monkey to respond (checker on, fix off)

/*				//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
					// Draw pg 5	 
					dsendf("rw %d,%d;\n",target_pd,target_pd);  												// draw pg 3                                        
					dsendf("cl:\n");																			// clear screen
					spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          // draw target
					spawnwait DRW_SQR(targSize, distAngle, distAmp, targColor, fill, deg2pix_X, deg2pix_Y);    	// draw distractor
					spawnwait DRW_CHKR(0);  														// draw checkered stimulus
					if (!Classic)																				// if we are doing stop-signal 2.0 (not classic)
						{
						spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, open, deg2pix_X, deg2pix_Y); // draw fixation point
						}
					spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
					// nexttick;
					//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
					// Draw pg 6	  
					dsendf("rw %d,%d;\n",target,target);  														// draw pg 4                                        
					dsendf("cl:\n");																			// clear screen
					spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);         	// draw target
					spawnwait DRW_SQR(targSize, distAngle, distAmp, targColor, fill, deg2pix_X, deg2pix_Y);     	// draw distractor
					spawnwait DRW_CHKR(0);  															// draw checkered stimulus
					if (!Classic)																				// if we are doing stop-signal 2.0 (not classic)
						{
						spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, open, deg2pix_X, deg2pix_Y);   	// draw fixation point
						}
*/				//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
					// Draw pg 5	 
					dsendf("rw %d,%d;\n",target_pd,target_pd);  												// draw pg 3                                        
					dsendf("cl:\n");																			// clear screen
					spawn DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          // draw target
					spawn DRW_SQR(targSize, distAngle, distAmp, targColor, fill, deg2pix_X, deg2pix_Y);    	// draw distractor
					if (!Classic)																				// if we are doing stop-signal 2.0 (not classic)
						{
						spawn DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, open, deg2pix_X, deg2pix_Y); // draw fixation point
						}
					spawn DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
					// spawn DRW_CHKR(0);  														// draw checkered stimulus
					nexttick;
					//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
					// Draw pg 6	  
					dsendf("rw %d,%d;\n",target,target);  														// draw pg 4                                        
					dsendf("cl:\n");																			// clear screen
					spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);         	// draw target
					spawn DRW_SQR(targSize, distAngle, distAmp, targColor, fill, deg2pix_X, deg2pix_Y);     	// draw distractor
					if (!Classic)																				// if we are doing stop-signal 2.0 (not classic)
						{
						spawn DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, open, deg2pix_X, deg2pix_Y);   	// draw fixation point
						}
					// spawn DRW_CHKR(0);  															// draw checkered stimulus
					nexttick;
				stage = choice_delay;
				}
			else
				{
				if (trialType == stopTrial ||									// If it is a stop or ignore trial present the signal.
					trialType == ignoreTrial)										// This happens here so that no overhead intervenes between commands.
					{														// That way the # of vertical retraces remains independant of incidental processing time.
																			// (Even so, sometimes we will accidentally wait n+1 retraces. Such is vdosync.)
					// dsendf("vw %d\n",ssd-1);							// Wait so many vertical retraces (one is waited implicitly b/c photodiode marker above)...
					while (time() <= cue_time + ssdMS - (1000.0/screenRefreshRate))   // Do nothing in a loop while waiting for stop signal to come on...
						{																// wait until one screen refresh before ssd, then send the commoand to present stop signal on next screen refresh
						if (!In_FixWin)													// If the eyes leave the fixation window...
							{															// ...we have a saccade, so...
							if (preSSDResponse == 0)
								{
								saccade_time = time();										// ...record the time...
								Event_fifo[Set_event] = Saccade_;							// ...queue strobe...
								Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
								// dsendf("vp %d\n",target);									// Flip the pg to the blank screen...
								printf("           rt = %d\n",saccade_time - cue_time);	// ...tell the user whats up...
								}
							preSSDResponse = 1;
							}
							nexttick;
						}
					dsendf("vp %d\n",signal_pd);							// ...flip the pg to the signal with the pd marker...
					
				
					stop_sig_time = cue_time + ssdMS; 		// ...record TEMPO time of presentation...
					dsendf("XM RFRSH:\n"); 									// ...wait 1 vertical retrace...
					dsendf("vp %d\n",signal);								// ...and flip the pg to the signal without pd marker.
					Event_fifo[Set_event] = StopSignal_;						// Queue strobe...
					Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
					}
					
				
																			// Now the animated graphs have to catch up (seperate so that stim timing stays tight)
				oSetAttribute(object_checker, aVISIBLE); 					// ...show target in animated graph...
				if (trialType == goTrial)										// If the trial is a go trial...
					{
					oSetAttribute(object_fix, aINVISIBLE); 					// ...remove fixation point from animated graph.
					}
					
				// If a response was made before stop signal came on, skip choice_on stage and go straight to in_flight	
				if (preSSDResponse == 0)
					stage = choice_on;											// Advance to the next trial stage.	
				else if (preSSDResponse == 1)
					stage = in_flight;			
				}
			}
		}
		


//--------------------------------------------------------------------------------------------
// STAGE choice_delay (the subject is looking at the fixation point waiting for cue onset)		
	else if (stage == choice_delay)
		{
		if (!In_FixWin)													// If the eyes stray out of the fixation window...
			{
			trialOutcome = brokeFix;									// TRIAL OUTCOME ERROR (broke fixation)
			lastOutcome = noChange;								// Don't change SSD
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			spawn SVR_BELL();
			printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}
		else if (In_FixWin && time() > cue_time + soa)	// But if the eyes are still in the window at end of holdtime...
			{
			dsendf("vp %d\n",target_pd);								// ...flip the pg to the choice stim pd marker...	
			cue_time = time(); 										// ...record the time...
			dsendf("XM RFRSH:\n"); 										// ...wait one vetical retrace...
			dsendf("vp %d\n",target);									// ...flip the pg to the choice stim without pd marker.
			Event_fifo[Set_event] = Cue_;						// Queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...


			if (trialType == stopTrial ||									// If it is a stop or ignore trial present the signal.
				trialType == ignoreTrial)										// This happens here so that no overhead intervenes between commands.
				{														// That way the # of vertical retraces remains independant of incidental processing time.
																		// (Even so, sometimes we will accidentally wait n+1 retraces. Such is vdosync.)
				// dsendf("vw %d\n",ssd-1);							// Wait so many vertical retraces (one is waited implicitly b/c photodiode marker above)...
				while (time() <= cue_time + ssdMS - (1000.0/screenRefreshRate))   // Do nothing in a loop while waiting for stop signal to come on...
					{																// wait until one screen refresh before ssd, then send the commoand to present stop signal on next screen refresh
					if (!In_FixWin)													// If the eyes leave the fixation window...
						{															// ...we have a saccade, so...
						if (preSSDResponse == 0)
							{
							saccade_time = time();										// ...record the time...
							Event_fifo[Set_event] = Saccade_;							// ...queue strobe...
							Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
							// dsendf("vp %d\n",target);									// Flip the pg to the blank screen...
							printf("           rt = %d\n",saccade_time - cue_time);	// ...tell the user whats up...
							}
						preSSDResponse = 1;
						}
						nexttick;
					}
				dsendf("vp %d\n",signal_pd);							// ...flip the pg to the signal with the pd marker...
				
			
				stop_sig_time = cue_time + ssdMS; 		// ...record TEMPO time of presentation...
				dsendf("XM RFRSH:\n"); 									// ...wait 1 vertical retrace...
				dsendf("vp %d\n",signal);								// ...and flip the pg to the signal without pd marker.
				Event_fifo[Set_event] = StopSignal_;						// Queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				}
				
			
																		// Now the animated graphs have to catch up (seperate so that stim timing stays tight)
			oSetAttribute(object_checker, aVISIBLE); 					// ...show target in animated graph...
			if (trialType == goTrial)										// If the trial is a go trial...
				{
				oSetAttribute(object_fix, aINVISIBLE); 					// ...remove fixation point from animated graph.
				}
				
			// If a response was made before stop signal came on, skip choice_on stage and go straight to in_flight	
			if (preSSDResponse == 0)
				stage = choice_on;											// Advance to the next trial stage.	
			else if (preSSDResponse == 1)
				stage = in_flight;			
			}
		}
		


//--------------------------------------------------------------------------------------------
// STAGE choice_on (the choice stimulus has been presented but the subject is still fixating)		
	else if (stage == choice_on)
		{		
		if (!In_FixWin)													// If the eyes leave the fixation window...
			{															// ...we have a saccade, so...
			saccade_time = time();										// ...record the time...
			Event_fifo[Set_event] = Saccade_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			// dsendf("vp %d\n",target);									// Flip the pg to the blank screen...
			printf("           rt = %d\n",saccade_time - cue_time);	// ...tell the user whats up...
			stage = in_flight;											// ...and advance to the next stage.
			}
		else if (In_FixWin &&  											// But if no saccade occurs...
			time() > cue_time + saccTimeMax && 					// ...and time for a saccade runs out...
			(trialType == goTrial || trialType == ignoreTrial))				// ...and a saccade was supposed to be made.
			{
			trialOutcome = goIncorrect;           							// TRIAL OUTCOME ERROR (incorrect go trial)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (no saccade)\n");								// ...tell the user whats up...
			spawn SVR_BELL();
			trl_running = 0;											// ...and terminate the trial.
			}				
		else if (In_FixWin &&											// But if no saccade occurs...
			time() > cue_time + ssdMS + holdStopDuration && 				// ...and time for a saccade runs out...
			trialType == stopTrial)										// ...and a saccade was NOT supposed to be made...
			{
			nTrialPsySSD[psyIndex, decideIndex] = nTrialPsySSD[psyIndex, decideIndex] + 1;  //tally the stop trial (for exporting to excel)
			trialOutcome = nogoCorrect;   								// TRIAL OUTCOME CORRECT (canceled trial)
			lastOutcome = success;				// set the global for staircasing...
			nSuccess = nSuccess + 1;
			dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			Event_fifo[Set_event] = Correct_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			printf("Correct (canceled)\n");								// ...tell the user whats up...
			trl_running = 0;  											// ...and terminate the trial.
			}		
		}
		
		
		
//--------------------------------------------------------------------------------------------
// STAGE in_flight (eyes have left fixation window but have not entered target window)		
	else if (stage == in_flight)
		{
		// if (trialType == stopTrial)
			// {
		// spawn TONE(300,toneDuration);							// present negative tone
			// }
		if (In_TargWin)													// If the eyes get into the target window...
			{
			aquire_targ_time = time();									// ...record the time...
			Event_fifo[Set_event] = Decide_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = on_target;											// ...and advance to the next stage of the trial.
			if (trialType == stopTrial)									// But if a saccade was the wrong thing to do...
				{												
				lastOutcome = failure;
				if (targIndex == targ1 || targIndex == targ1+2)
					{					
					nTarg1PsySSD[psyIndex, decideIndex] = nTarg1PsySSD[psyIndex, decideIndex] + 1;  //tally that it was a rightward response on stop trial (for exporting to excel)
					}
				nTrialPsySSD[psyIndex, decideIndex] = nTrialPsySSD[psyIndex, decideIndex] + 1;  //tally that it was a stop trial (for exporting to excel)
				nSaccPsySSD[psyIndex, decideIndex] = nSaccPsySSD[psyIndex, decideIndex] + 1;  //tally that it was a respond trial (for exporting to excel)
				Event_fifo[Set_event] = Error_sacc;						// ...queue strobe for Neuro Explorer
				Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.
				}
			else 														// Otherwise...
				{								
				Event_fifo[Set_event] = Correct_;					// ...queue strobe for Neuro Explorer
				Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.					
				}
			}
		else if (In_DistWin)											// If the eyes get into the distractor window...
			{
			aquire_dist_time = time();									// ...record the time...
			Event_fifo[Set_event] = Decide_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = on_distractor;										// ...and advance to the next stage of the trial.
			if (trialType == stopTrial)									// But if a saccade was the wrong thing to do...
				{												
				lastOutcome = failure;
				if (targIndex == targ2 || targIndex == targ2+2)
					{					
					nTarg1PsySSD[psyIndex, decideIndex] = nTarg1PsySSD[psyIndex, decideIndex] + 1;  //tally that it was a rightward response on stop trial (for exporting to excel)
					}
				nTrialPsySSD[psyIndex, decideIndex] = nTrialPsySSD[psyIndex, decideIndex] + 1;  //tally that it was a stop trial (for exporting to excel)
				nSaccPsySSD[psyIndex, decideIndex] = nSaccPsySSD[psyIndex, decideIndex] + 1;  //tally that it was a respond trial (for exporting to excel)
				Event_fifo[Set_event] = Error_sacc;						// ...queue strobe for Neuro Explorer
				Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.
				}
			else 														// Otherwise...
				{								
				Event_fifo[Set_event] = Distract_;					// ...queue strobe for Neuro Explorer
				Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.					
				}
			}
		else if (In_ChkrWin)											// If the eyes get into the checker stimulus window...
			{
			aquire_chkr_time = time();									// ...record the time...
			trialOutcome = checkerAbort;   								// TRIAL OUTCOME ERROR (innacurrate saccade)
			if (trialType == stopTrial)									// But if a saccade was the wrong thing to do...
				{												
				lastOutcome = noChange;							// ...make sure that the last outcome is cleared.						
				}
				// lastOutcome = failure;								// ...record the failure.
				// }
			// else 														// Otherwise...
				// {								
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			spawn SVR_BELL();
			printf("Error (looked at checker stimulus)\n");				// ...tell the user whats up...
			trl_running = 0; 											// ...and terminate the trial.
			}
		else if (time() > saccade_time + saccDurationMax)				// But, if the eyes are out of the target window and time runs out...
			{
			trialOutcome = saccOut;   									// TRIAL OUTCOME ERROR (innacurrate saccade)
			if (trialType == stopTrial)									// But if a saccade was the wrong thing to do...
				{												
				lastOutcome = noChange;							// ...make sure that the last outcome is cleared.						
				}
			// if (trialType == stopTrial)									// But if a saccade was the wrong thing to do...
				// {												
				// lastOutcome = failure;								// ...record the failure.
				// }
			// else 														// Otherwise...
				// {								
				// lastOutcome = noChange;							// ...make sure that the last outcome is cleared.						
				// }
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (inaccurate saccade)\n");						// ...tell the user whats up...
			spawn SVR_BELL();
			trl_running = 0; 											// ...and terminate the trial.
			}
		}
	
	
	
//--------------------------------------------------------------------------------------------
// STAGE on_target (eyes have entered the target window.  will they remain there for duration?)	
	else if (stage == on_target)
		{
		if (!In_TargWin)												// If the eyes left the target or distractor window...
			{			
			trialOutcome = brokeTarg;									// TRIAL OUTCOME ERROR (broke target fixation)
			// if (trialType == stopTrial)									// But if a saccade was the wrong thing to do...
				// {												
				// lastOutcome = failure;
				// }
			// else 														// Otherwise...
				// {								
				// lastOutcome = noChange;							// ...make sure that the last outcome is cleared.						
				// }
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (broke target fixation)\n");					// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}		
		else if (In_TargWin  											// But if the eyes are still in the target window...
			&&  time() > aquire_targ_time + targHoldtime)				// ...and the target hold time is up...
			{
			if (trialType == goTrial || trialType == ignoreTrial)			// ...and a saccade was the correct thing to do...
				{
				trialOutcome = goTarg;								//TRIAL OUTCOME CORRECT (correct go trial)
				Event_fifo[Set_event] = Correct_;						// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue...
				printf("Correct (saccade)\n");							// ...tell the user whats up...
				}
			else if (trialType == stopTrial)								// But if a saccade was the wrong thing to do...
				{
				trialOutcome = nogoTarg;								//TRIAL OUTCOME ERROR (noncanceled trial)
				printf("Error (noncanceled)\n");						// ...tell the user whats up...
				}														// Either way we are done, so...
			dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			trl_running = 0;											// ...and terminate the trial.
			}			
		}
		

// STAGE on_distractor (eyes have entered the distractor window.  will they remain there for duration?)	
	else if (stage == on_distractor)
		{
		if (!In_DistWin)												// If the eyes left the distractor or distractor window...
			{			
			trialOutcome = brokeDist;									// TRIAL OUTCOME ERROR (broke target fixation)
			// if (trialType == stopTrial)									// But if a saccade was the wrong thing to do...
				// {												
				// lastOutcome = failure;
				// }
			// else 														// Otherwise...
				// {								
				// lastOutcome = noChange;							// ...make sure that the last outcome is cleared.						
				// }
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (broke distractor fixation)\n");				// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}		
		else if (In_DistWin  											// But if the eyes are still in the target window...
			&&  time() > aquire_dist_time + targHoldtime)				// ...and the target hold time is up...
			{
			if (trialType == goTrial || trialType == ignoreTrial)			// ...and a saccade was the correct thing to do...
				{
				trialOutcome = goDist;								//TRIAL OUTCOME CORRECT (correct go trial)
				// Event_fifo[Set_event] = Correct_;// pgm need to change this?						// ...queue strobe...
				// Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue...
				printf("Error to distractor (saccade)\n");	//pgm						// ...tell the user whats up...
				}
			else if (trialType == stopTrial)								// But if a saccade was the wrong thing to do...
				{
				trialOutcome = nogoDist;							//TRIAL OUTCOME ERROR (noncanceled trial)
				printf("Error to distractor (noncanceled)\n");	//pgm					// ...tell the user whats up...
				}														// Either way we are done, so...
			dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			trl_running = 0;											// ...and terminate the trial.
			}			
		}
	

	if (Move_ct > 0)
		{
		trialOutcome = bodyMove;   									// TRIAL OUTCOME ABORTED (the body was moving)
		lastOutcome = noChange;								// ...make sure that the last outcome is cleared.	
		// lastStopArray[ampIndex] = failure;
		dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
		oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
		oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
		printf("Aborted (body movement)\n");							// ...tell the user whats up...
		trl_running = 0; 											// ...and terminate the trial.
		}

		
	nexttick;
	}
}#pragma declare = 1                     // require declarations of all variables

declare CHKRSTIM();	

declare int running = 1;
int stimPage = 0;
int changeStimulus = 1;
int State = 1;
int Monkey = 0;
int Room = 29;
int targIndex, targ1, targ2;

#include C:/TEMPO/ProcLib/pgm/RIGSETUP.pro  // declares a bunch of rig specific global variables
#include C:/TEMPO/ProcLib/pgm/EVENTDEF.pro	// event code definitions
#include C:/TEMPO/ProcLib/pgm/ALL_VARS.pro	// declares global variables needed to run protocols
#include C:/TEMPO/ProcLib/pgm/DEFAULT.pro	// sets all globals to their appropriate defaults for countermanding
#include C:/TEMPO/ProcLib/pgm/GOODVARS.pro	// do user defined variables make sense before starting the task?
#include C:/TEMPO/ProcLib/pgm/SET_CLRS.pro	// sets the stim colors up
#include C:/TEMPO/ProcLib/pgm/DIO.pro		// necessary for digital input output communication
#include C:/TEMPO/ProcLib/pgm/SET_COOR.pro  // set screen coordinates up and calculate some conversion factors
// #include C:/TEMPO/ProcLib/GRAPHS.pro    // required when using object graphs in cmanding protocol (modified from object.pro to include graph setup)
// #include C:/TEMPO/ProcLib/SET_INH.pro	// sets up the inhibition function graph used in cmanding
// // #include C:/TEMPO/ProcLib/WINDOWS.pro	// sets fixation and target window targSize (these valeus are needed in WATCHEYE.pro)
// #include C:/TEMPO/ProcLib/WATCHEYE.pro	// monitors eye position on each process cyle
// #include C:/TEMPO/ProcLib/TONE.pro      // does simple frequency conversion and presents tone accordingly
// #include C:/TEMPO/ProcLib/TONESWEP.pro	// a sweep through several tones for a sound which can be distinguished from pure tones
// #include C:/TEMPO/ProcLib/WATCHMTH.pro	// monitors mouth movement on each process cycle
// #include C:/TEMPO/ProcLib/WATCHBOD.pro	// monitors body movement on each process cycle
// #include C:/TEMPO/ProcLib/SVR_BELL.pro	// sounds speaker on server
// #include C:/TEMPO/ProcLib/SVR_BEL2.pro	// sounds speaker on server (different)
// #include C:/TEMPO/ProcLib/CMDTRIAL.pro	// runs a single countermanding trial based on input
// #include C:/TEMPO/ProcLib/CCMTRIAL.pro	// modified from CMDTRIAL, for choice countermanding
// #include C:/TEMPO/ProcLib/DRW_SQR.pro	// simple process for drawing stim
#include C:/TEMPO/ProcLib/pgm/DRW_CHKR.pro	// process for drawing checkered discriminatory stimulus
// #include C:/TEMPO/ProcLib/FIX_PGS.pro	// setup fixation stimuli
// #include C:/TEMPO/ProcLib/SETC_TRL.pro	// sets up all of the input to run a countermanding trial
// #include C:/TEMPO/ProcLib/SETM_TRL.pro	// sets up all input to run a mem guided trial
// #include C:/TEMPO/ProcLib/SETV_TRL.pro	// sets up all input to run a visually guided trial
// #include C:/TEMPO/ProcLib/SETA_TRL.pro	// sets up all input to run an amplitude trial
// #include C:/TEMPO/ProcLib/SETCCTRL.pro	// sets up all of the input to run a choice countermanding trial
// #include C:/TEMPO/ProcLib/MEMTRIAL.pro	// runs a single mem guided trial based on input
// #include C:/TEMPO/ProcLib/VISTRIAL.pro	// runs a single visually guided trial based on input
// #include C:/TEMPO/ProcLib/AMPTRIAL.pro	// runs a single amplitude trial based on input
// #include C:/TEMPO/ProcLib/UPD8_INH.pro	// updates inhibition function for cmanding
// #include C:/TEMPO/ProcLib/INFOS.pro		// queue up all trial event codes for strobing to plexon
// #include C:/TEMPO/ProcLib/END_TRL.pro	// ends a trial based on outcome
// #include C:/TEMPO/ProcLib/KEY_REWD.pro	// needed to give reward manually from keyboard (stupid)
// #include C:/TEMPO/ProcLib/KEY_TARG.pro	// see above
// #include C:/TEMPO/ProcLib/FIXATION.pro	// fixation control structure
// #include C:/TEMPO/ProcLib/CMANDING.pro	// countermanding control structure
// #include C:/TEMPO/ProcLib/MEMORY.pro	// mem guided sacc task control structure
// #include C:/TEMPO/ProcLib/VISGUIDE.pro	// visually guided sacc task control structure
// #include C:/TEMPO/ProcLib/AMPLTUDE.pro	// visually guided sacc task control structure
// #include C:/TEMPO/ProcLib/CHOICECM.pro	// choice countermanding task, modified from CMANDING
// #include C:/TEMPO/ProcLib/QUE_TTL.pro	// makes a ring buffer for sending TTL events


process CHKRSTIM() enabled					// When the clock is started the task is not yet running.
{

state = 4; // stateCCM, see ALL_VARS
		nCheckerColumn = 10;
		nCheckerRow = 10;
		nSquare = nCheckerColumn * nCheckerRow;

dsend("vi 256;");					// make sure vdosync is in correct config
dsend("ca");						// flush all vdosync memory
printf("flushing video memory please wait...\n");
wait 1000; 							// it can take up to 5 seconds to clear all vdo sync memory (pg 7-37)
dsend("DM RFRSH");                			// This code sets up a vdosync macro definition to wait a specified ...
	dsendf("vw %d:\n",2);
dsend("EM RFRSH");

spawn DEFAULT();	

spawn SET_COOR();				// set up screen coordinates based on globals defined in RIGSETUP.pro	

		iSquareSizePixels = 8;

while (running)
	{
	printf("what the hell\n");
	dsendf("rw %d,%d;\n",stimPage,stimPage);  												// draw pg 3                                        
	dsendf("cl:\n");																			// clear screen
	spawnwait DRW_CHKR(changeStimulus);  														// draw checkered stimulus
	wait 1000;
	dsendf("vp %d\n",stimPage);							// ...flip the pg to the signal with the pd marker...
	wait 5000;
	dsendf("cl:\n");																			// clear screen
	}
dsend("ca");						// flush all vdosync memory

}

                >  	                                       	                \ p   Matt Nelson                                                                                                  B  a     =                         =  x < LJr38     X@        "              1          VA r i a l 1          VA r i a l 1          VA r i a l 1          VA r i a l 1        VA r i a l 1          VA r i a l 1         VA r i a l 1          VA r i a l 1          VA r i a l 1         VA r i a l 1         VA r i a l 1          VA r i a l 1          VA r i a l 1         VA r i a l 1         VA r i a l 1          VA r i a l 1          VA r i a l 1         VA r i a l 1         VA r i a l 1          VA r i a l 1          VA r i a l 1         VA r i a l 1         VA r i a l 1          VA r i a l 1          VA r i a l 1         VA r i a l 1         VA r i a l 1          VA r i a l 1          VA r i a l 1         VA r i a l 1         VA r i a l 1          VA r i a l 1          VA r i a l 1         VA r i a l 1          VA r i a l     "$"#,##0_);\("$"#,##0\)!    "$"#,##0_);[Red]\("$"#,##0\)"    "$"#,##0.00_);\("$"#,##0.00\)'  "  "$"#,##0.00_);[Red]\("$"#,##0.00\)7 * 2  _("$"* #,##0_);_("$"* \(#,##0\);_("$"* "-"_);_(@_). ) )  _(* #,##0_);_(* \(#,##0\);_(* "-"_);_(@_)? , :  _("$"* #,##0.00_);_("$"* \(#,##0.00\);_("$"* "-"??_);_(@_)6 + 1  _(* #,##0.00_);_(* \(#,##0.00\);_(* "-"??_);_(@_)                                                                                                                                                                                                                                                                                                  +                )                ,                *                	                                          @ @                  @                 @                @                                                        @                                                   `     C    
 LinkedData       Psychometric  7    
 Inhibition         
  TEMPOexpr# $      nSaccPsySSD[0,0]           # $      nSaccPsySSD[0,1]           # $      nSaccPsySSD[0,2]         5@# $      nSaccPsySSD[0,3]         N@# $      nSaccPsySSD[0,4]         @# $      nSaccPsySSD[0,5]           # $      nSaccPsySSD[0,6]           # $      nSaccPsySSD[0,7]           # $      nSaccPsySSD[0,8]           # $      nSaccPsySSD[0,9]           # $      nSaccPsySSD[1,0]           # $      nSaccPsySSD[1,1]         ?# $      nSaccPsySSD[1,2]         &@# $      nSaccPsySSD[1,3]        E@# $      nSaccPsySSD[1,4]         7@# $      nSaccPsySSD[1,5]         @# $      nSaccPsySSD[1,6]           # $      nSaccPsySSD[1,7]           # $      nSaccPsySSD[1,8]           # $      nSaccPsySSD[1,9]           # $      nSaccPsySSD[2,0]           # $      nSaccPsySSD[2,1]         *@# $      nSaccPsySSD[2,2]        D@# $      nSaccPsySSD[2,3]         3@# $      nSaccPsySSD[2,4]         @# $      nSaccPsySSD[2,5]           # $      nSaccPsySSD[2,6]           # $      nSaccPsySSD[2,7]           # $      nSaccPsySSD[2,8]           # $      nSaccPsySSD[2,9]           # $      nSaccPsySSD[3,0]           # $      nSaccPsySSD[3,1]         C@# $      nSaccPsySSD[3,2]         =@# $      nSaccPsySSD[3,3]         @# $      nSaccPsySSD[3,4]         ?# $      nSaccPsySSD[3,5]           # $      nSaccPsySSD[3,6]           # $      nSaccPsySSD[3,7]           # $      nSaccPsySSD[3,8]           # $      nSaccPsySSD[3,9]           # $      nSaccPsySSD[4,0]           # $      nSaccPsySSD[4,1]           # $      nSaccPsySSD[4,2]           # $      nSaccPsySSD[4,3]           # $      nSaccPsySSD[4,4]           # $      nSaccPsySSD[4,5]           # $      nSaccPsySSD[4,6]           # $      nSaccPsySSD[4,7]           # $      nSaccPsySSD[4,8]           # $      nSaccPsySSD[4,9]           # $      nSaccPsySSD[5,0]           # $      nSaccPsySSD[5,1]           # $      nSaccPsySSD[5,2]           # $      nSaccPsySSD[5,3]           # $      nSaccPsySSD[5,4]           # $      nSaccPsySSD[5,5]           # $      nSaccPsySSD[5,6]           # $      nSaccPsySSD[5,7]           # $      nSaccPsySSD[5,8]           # $      nSaccPsySSD[5,9]           # $      nSaccPsySSD[6,0]           # $      nSaccPsySSD[6,1]           # $      nSaccPsySSD[6,2]           # $      nSaccPsySSD[6,3]           # $      nSaccPsySSD[6,4]           # $      nSaccPsySSD[6,5]           # $      nSaccPsySSD[6,6]           # $      nSaccPsySSD[6,7]           # $      nSaccPsySSD[6,8]           # $      nSaccPsySSD[6,9]           # $      nSaccPsySSD[7,0]           # $      nSaccPsySSD[7,1]           # $      nSaccPsySSD[7,2]           # $      nSaccPsySSD[7,3]           # $      nSaccPsySSD[7,4]           # $      nSaccPsySSD[7,5]           # $      nSaccPsySSD[7,6]           # $      nSaccPsySSD[7,7]           # $      nSaccPsySSD[7,8]           # $      nSaccPsySSD[7,9]           # $      nSaccPsySSD[8,0]           # $      nSaccPsySSD[8,1]           # $      nSaccPsySSD[8,2]           # $      nSaccPsySSD[8,3]           # $      nSaccPsySSD[8,4]           # $      nSaccPsySSD[8,5]           # $      nSaccPsySSD[8,6]           # $      nSaccPsySSD[8,7]           # $      nSaccPsySSD[8,8]           # $      nSaccPsySSD[8,9]           # $      nSaccPsySSD[9,0]           # $      nSaccPsySSD[9,1]           # $      nSaccPsySSD[9,2]           # $      nSaccPsySSD[9,3]           # $      nSaccPsySSD[9,4]           # $      nSaccPsySSD[9,5]           # $      nSaccPsySSD[9,6]           # $      nSaccPsySSD[9,7]           # $      nSaccPsySSD[9,8]           # $      nSaccPsySSD[9,9]           # %      nTarg1PsySSD[0,0]           # %      nTarg1PsySSD[0,1]           # %      nTarg1PsySSD[0,2]           # %      nTarg1PsySSD[0,3]           # %      nTarg1PsySSD[0,4]           # %      nTarg1PsySSD[0,5]           # %      nTarg1PsySSD[0,6]           # %      nTarg1PsySSD[0,7]           # %      nTarg1PsySSD[0,8]           # %      nTarg1PsySSD[0,9]           # %      nTarg1PsySSD[1,0]           # %      nTarg1PsySSD[1,1]         ?# %      nTarg1PsySSD[1,2]           # %      nTarg1PsySSD[1,3]           # %      nTarg1PsySSD[1,4]           # %      nTarg1PsySSD[1,5]           # %      nTarg1PsySSD[1,6]           # %      nTarg1PsySSD[1,7]           # %      nTarg1PsySSD[1,8]           # %      nTarg1PsySSD[1,9]           # %      nTarg1PsySSD[2,0]           # %      nTarg1PsySSD[2,1]         @# %      nTarg1PsySSD[2,2]         "@# %      nTarg1PsySSD[2,3]         @# %      nTarg1PsySSD[2,5]           # %      nTarg1PsySSD[2,6]           # %      nTarg1PsySSD[2,7]           # %      nTarg1PsySSD[2,8]           # %      nTarg1PsySSD[2,9]           # %      nTarg1PsySSD[3,0]           # %      nTarg1PsySSD[3,1]         @# %      nTarg1PsySSD[3,2]         @# %      nTarg1PsySSD[3,3]          @# %      nTarg1PsySSD[3,4]         ?# %      nTarg1PsySSD[3,5]           # %      nTarg1PsySSD[3,6]           # %      nTarg1PsySSD[3,7]           # %      nTarg1PsySSD[3,8]           # %      nTarg1PsySSD[3,9]           # %      nTarg1PsySSD[4,0]           # %      nTarg1PsySSD[4,1]           # %      nTarg1PsySSD[4,2]           # %      nTarg1PsySSD[4,3]           # %      nTarg1PsySSD[4,4]           # %      nTarg1PsySSD[4,5]           # %      nTarg1PsySSD[4,6]           # %      nTarg1PsySSD[4,7]           # %      nTarg1PsySSD[4,8]           # %      nTarg1PsySSD[4,9]           # %      nTarg1PsySSD[5,0]           # %      nTarg1PsySSD[5,1]           # %      nTarg1PsySSD[5,2]           # %      nTarg1PsySSD[5,3]           # %      nTarg1PsySSD[5,4]           # %      nTarg1PsySSD[5,5]           # %      nTarg1PsySSD[5,6]           # %      nTarg1PsySSD[5,7]           # %      nTarg1PsySSD[5,8]           # %      nTarg1PsySSD[5,9]           # %      nTarg1PsySSD[6,0]           # %      nTarg1PsySSD[6,1]           # %      nTarg1PsySSD[6,2]           # %      nTarg1PsySSD[6,3]           # %      nTarg1PsySSD[6,4]           # %      nTarg1PsySSD[6,5]           # %      nTarg1PsySSD[6,6]           # %      nTarg1PsySSD[6,7]           # %      nTarg1PsySSD[6,8]           # %      nTarg1PsySSD[6,9]           # %      nTarg1PsySSD[7,0]           # %      nTarg1PsySSD[7,1]           # %      nTarg1PsySSD[7,2]           # %      nTarg1PsySSD[7,3]           # %      nTarg1PsySSD[7,4]           # %      nTarg1PsySSD[7,5]           # %      nTarg1PsySSD[7,6]           # %      nTarg1PsySSD[7,7]           # %      nTarg1PsySSD[7,8]           # %      nTarg1PsySSD[7,9]           # %      nTarg1PsySSD[8,0]           # %      nTarg1PsySSD[8,1]           # %      nTarg1PsySSD[8,2]           # %      nTarg1PsySSD[8,3]           # %      nTarg1PsySSD[8,4]           # %      nTarg1PsySSD[8,5]           # %      nTarg1PsySSD[8,6]           # %      nTarg1PsySSD[8,7]           # %      nTarg1PsySSD[8,8]           # %      nTarg1PsySSD[8,9]           # %      nTarg1PsySSD[9,0]           # %      nTarg1PsySSD[9,1]           # %      nTarg1PsySSD[9,2]           # %      nTarg1PsySSD[9,3]           # %      nTarg1PsySSD[9,4]           # %      nTarg1PsySSD[9,5]           # %      nTarg1PsySSD[9,6]           # %      nTarg1PsySSD[9,7]           # %      nTarg1PsySSD[9,8]           # %      nTarg1PsySSD[9,9]           # %      nTrialPsySSD[0,0]           # %      nTrialPsySSD[0,1]         4@# %      nTrialPsySSD[0,2]        @T@# %      nTrialPsySSD[0,3]        P@# %      nTrialPsySSD[0,4]         @# %      nTrialPsySSD[0,5]           # %      nTrialPsySSD[0,6]           # %      nTrialPsySSD[0,7]           # %      nTrialPsySSD[0,8]           # %      nTrialPsySSD[0,9]           # %      nTrialPsySSD[1,0]         ?# %      nTrialPsySSD[1,1]         (@# %      nTrialPsySSD[1,2]         K@# %      nTrialPsySSD[1,3]        P@# %      nTrialPsySSD[1,4]         ;@# %      nTrialPsySSD[1,5]         @# %      nTrialPsySSD[1,6]           # %      nTrialPsySSD[1,7]           # %      nTrialPsySSD[1,8]           # %      nTrialPsySSD[1,9]           # %      nTrialPsySSD[2,0]         *@# %      nTrialPsySSD[2,1]         K@# %      nTrialPsySSD[2,2]        N@# %      nTrialPsySSD[2,3]         8@# %      nTrialPsySSD[2,4]         @# %      nTrialPsySSD[2,5]           # %      nTrialPsySSD[2,6]           # %      nTrialPsySSD[2,7]           # %      nTrialPsySSD[2,8]           # %      nTrialPsySSD[2,9]           # %      nTrialPsySSD[3,0]         C@# %      nTrialPsySSD[3,1]        P@# %      nTrialPsySSD[3,2]        A@# %      nTrialPsySSD[3,3]         @# %      nTrialPsySSD[3,4]         ?# %      nTrialPsySSD[3,5]           # %      nTrialPsySSD[3,6]           # %      nTrialPsySSD[3,7]           # %      nTrialPsySSD[3,8]           # %      nTrialPsySSD[3,9]           # %      nTrialPsySSD[4,0]           # %      nTrialPsySSD[4,1]           # %      nTrialPsySSD[4,2]           # %      nTrialPsySSD[4,3]           # %      nTrialPsySSD[4,4]           # %      nTrialPsySSD[4,5]           # %      nTrialPsySSD[4,6]           # %      nTrialPsySSD[4,7]           # %      nTrialPsySSD[4,8]           # %      nTrialPsySSD[4,9]           # %      nTrialPsySSD[5,0]           # %      nTrialPsySSD[5,1]           # %      nTrialPsySSD[5,2]           # %      nTrialPsySSD[5,3]           # %      nTrialPsySSD[5,4]           # %      nTrialPsySSD[5,5]           # %      nTrialPsySSD[5,6]           # %      nTrialPsySSD[5,7]           # %      nTrialPsySSD[5,8]           # %      nTrialPsySSD[5,9]           # %      nTrialPsySSD[6,0]           # %      nTrialPsySSD[6,1]           # %      nTrialPsySSD[6,2]           # %      nTrialPsySSD[6,3]           # %      nTrialPsySSD[6,4]           # %      nTrialPsySSD[6,5]           # %      nTrialPsySSD[6,6]           # %      nTrialPsySSD[6,7]           # %      nTrialPsySSD[6,8]           # %      nTrialPsySSD[6,9]           # %      nTrialPsySSD[7,0]           # %      nTrialPsySSD[7,1]           # %      nTrialPsySSD[7,2]           # %      nTrialPsySSD[7,3]           # %      nTrialPsySSD[7,4]           # %      nTrialPsySSD[7,5]           # %      nTrialPsySSD[7,6]           # %      nTrialPsySSD[7,7]           # %      nTrialPsySSD[7,8]           # %      nTrialPsySSD[7,9]           # %      nTrialPsySSD[8,0]           # %      nTrialPsySSD[8,1]           # %      nTrialPsySSD[8,2]           # %      nTrialPsySSD[8,3]           # %      nTrialPsySSD[8,4]           # %      nTrialPsySSD[8,5]           # %      nTrialPsySSD[8,6]           # %      nTrialPsySSD[8,7]           # %      nTrialPsySSD[8,8]           # %      nTrialPsySSD[8,9]           # %      nTrialPsySSD[9,0]           # %      nTrialPsySSD[9,1]           # %      nTrialPsySSD[9,2]           # %      nTrialPsySSD[9,3]           # %      nTrialPsySSD[9,4]           # %      nTrialPsySSD[9,5]           # %      nTrialPsySSD[9,6]           # %      nTrialPsySSD[9,7]           # %      nTrialPsySSD[9,8]           # %      nTrialPsySSD[9,9]           #       ssdArray[0]         @#       ssdArray[1]         1@#       ssdArray[2]         ;@#       ssdArray[3]        B@#       ssdArray[4]        G@#       ssdArray[5]        L@#       ssdArray[6]           #       ssdArray[7]           #       ssdArray[8]           #       ssdArray[9]           #       StdDocumentName# %      targ1PropArray[0]   zG?# %      targ1PropArray[1]   Gz?# %      targ1PropArray[2]   (\?# %      targ1PropArray[3]   (\?# %      targ1PropArray[4]           # %      targ1PropArray[5]           # %      targ1PropArray[6]           # %      targ1PropArray[7]           # %      targ1PropArray[8]           # %      targ1PropArray[9]                        "     z     @                             	                     3       A  @  @                     nTrial  nGoRight  nSaccade  P(go right)
  P(saccade)  SSD  Target 1 Proportion  Total Stop Proprtion:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      total            em   q=     =  {   c c                 
   	               3   E    G       d          MbP?_   *    +                 %                    M n  M i c r o s o f t   O f f i c e   D o c u m e n t   I m a g e      /        d   ,  ,   L e t t e r                                                                                                           widm                                                                                                                                         "  d     ,,      ?      ? U   }             3                                                                                                         	            
                                                                                                                                                                                                                                                
          
            zG?  (  Y 7       Gz?    Y 8       (\?    Y 9       (\?    Y :                   Y ;                   Y <                   Y =     	              Y >     
             	 Y ?                  
 Y @   
                   @    Y ,                      !       Y               ?  %  Y               *@    Y               C@  "  Y                   !  Y                     Y                   %  Y      	             
 Y      
              Y                   	 Y "   #         @    %               1@    Y -             4@  #  Y               (@    Y               K@  "  Y              P@  !  Y                     Y                     Y                   $  Y      	             
 Y      
              Y                   	 Y #   
        1          ?    % (   %              ;@    Y .            @T@  $  Y               K@  #  Y              N@    Y              A@    Y                   %  Y                   "  Y                   #  Y      	             
 Y      
              Y                   	 Y $            B@    Y /            P@  !  Y              P@    Y               8@  !  Y               @    Y                     Y                     Y                   "  Y      	             
 Y      
              Y                   	 Y %            G@    Y 0             @    Y               ;@  #  Y               @  '  Y               ?  "  Y                      Y                   !  Y                   %  Y      	             
 Y      
              Y                    Y &            L@    Y 1                   Y               @  #  Y                   !  Y                    	 Y                   %  Y                     Y                     Y 	     	             
 Y      
              Y                  	  Y '    	               Y 2    	             #  Y      	               Y      	             '  Y      	             $  Y      	               Y      	             &  Y      	             	 	 Y 
    	 	            	 
 Y     	 
            	  Y     	             
  Y (    
             	  Y 3    
             '  Y      
             
  Y      
             
  Y      
             &  Y      
             
 	 Y      
             %  Y     
             #  Y     
 	            
 
 Y     
 
            
  Y     
               Y )                 
  Y 4                 $  Y                   $  Y                     Y                   &  Y                    	 Y                   '  Y                  '  Y      	             
 Y      
              Y                     Y *                   Y 5                   Y                     Y                     Y                     Y                     Y                     Y                   	 Y      	             
 Y      
              Y !                   Y +   
    	    #         e@    %              d@(         	 -              c@(               `b@(                  (                  (                  (  	      	          (  
      
          (                  (      1                %  $% (       ?(     %    	 -  $-        AA?(          #u)?(          UUUU(              (          (  	        (  
        3333(          m(      
         
            zG?    Y 7       Gz?    Y 8       (\?    Y 9       (\?    Y :                   Y ;                   Y <                   Y =     	              Y >     
             	 Y ?                  
 Y @       zG?    Y 7       Gz?    Y 8       (\?    Y 9       (\?    Y :                   Y ;                   Y <                   Y =                   Y >                   Y ?                   Y @   
                   @    Y ,                   Y e                    Y o                    Y y                    Y                     Y                     Y                     Y       	             	 Y       
             
 Y                     Y     /          Y@    D Gz,@@   A            @    Y ,   !            D D              (         	 L  L             (                  (              (              (              (              (          UUUU(              (                1@    Y -                   Y f              ?    Y p              @    Y z              @    Y                     Y                     Y                     Y       	             	 Y       
             
 Y                     Y              `n@(     #    	 L  Gz,@@   A            1@    Y -               (         	 L  L     UUUUUU?(         	 L  L     qq?(         	 L  L     eM6d?(         	 L  L         (         	 L  L     q(         	 L  L         (         	 L  L         (         	 L  L         (         	 L  L         (         	 L  L           ;@    Y .                   Y g                    Y q              "@    Y {              @    Y                     Y                     Y                     Y       	             	 Y       
             
 Y                     Y               x@(                ;@    Y .               (                  (          uy?(          ?(              (              (          (              (              (              (               B@    Y /                   Y h                    Y r              @    Y |               @    Y                     Y                     Y                     Y       	             	 Y       
             
 Y                     Y              @(               B@    Y /               (                  (          UUUUUU?(          $I$I?(              (              (              (              (          (          UUUU(               G@    Y 0                   Y i                    Y s                    Y i              ?    Y                     Y                     Y                     Y       	             	 Y       
             
 Y                     Y               @(               G@    Y 0               (                  (                  (                ?(              (              (              (              (          UUUU(              (               L@    Y 1                   Y j                    Y t                    Y }                    Y                     Y                     Y                     Y       	             	 Y       
             
 Y                     Y              x@(               L@    Y 1           (                  (              (              (              (              (              (              (              (              (                      Y 2                   Y k                    Y u                    Y ~                    Y                     Y                     Y                     Y       	             	 Y       
             
 Y                     Y                 (                      Y 2           (              (              (              (          UUUU(              (              (              (              (              (                      Y 3                   Y l                    Y v                    Y                     Y                     Y                     Y                     Y       	             	 Y       
             
 Y                     Y                 (                      Y 3           (              (              (          UUUU(              (          UUUU(              (              (              (              (                      Y 4                   Y m                    Y w                    Y                     Y                     Y                     Y                     Y       	             	 Y       
             
 Y                     Y                 (                      Y 4           (              (              (              (              (              (              (              (              (              (                      Y 5                   Y n                    Y x                    Y                     Y                     Y                     Y                     Y       	              Y       
              Y                     Y                 (                      Y 5           (              (              (              (              (              (              (              (              (              (      
         
            zG?    Y 7       Gz?    Y 8       (\?    Y 9       (\?    Y :                   Y ;                   Y <                   Y =     	              Y >     
             	 Y ?                  
 Y @       zG?    Y 7       Gz?    Y 8       (\?    Y 9       (\?    Y :                   Y ;                   Y <                   Y =                   Y >                   Y ?                   Y @   
                   @    Y ,                     !       Y                     Y                     Y                     Y                     Y )                    Y 3                   	 Y =      	             
 Y G      
              Y Q                     Y [              @    Y ,   !          Q* D D              (         	 L  L             (                  (              (              (              (              (          UUUU(              (      1                 %    %              1@    Y -                     Y                ?     Y                *@     Y                C@  &  Y                        Y *                      Y 4                     	 Y >       	              
 Y H       
               Y R                   ! 	 Y \               1@     Y -                (          (  	 L  L      UUUUUU?(          (  	 L  L      	%?(          (  	 L  L      m&l?(          (  	 L  L          (          (  	 L  L      q(          (  	 L  L          (          (  	 L  L          (          (  	 L  L          (          (  	 L  L          ( !        (  	 L  L      Q^Cy?( !     %   (  	 -      - > @  0 Jkkkkkkkk " ; !           "           #           $           %           &           '           (           .           2 	 
          !         ;@     Y .    !         5@    Y      !         &@    Y      !        D@    Y      !         =@  "  Y !     !               Y +     !               Y 5     !             !  Y ?     ! 	            ! 
 Y I     ! 
            !  Y S     !             " 	 Y ]     !         ;@  !  Y .    !   {	%?( !       !   /?( !       !   ).?( !       !   ;:?( !       !   UUUU( !       !       ( !       !   p
( !       !       ( !       !       ( !       !       ( "       !   	qV~B?( "       "        B@  !  Y /    "         N@    Y      "        E@    Y      "         3@    Y      "         @    Y "     "               Y ,     "               Y 6     "               Y @     " 	            " 
 Y J     " 
            "  Y T     "             # 	 Y ^     "        B@  "  Y /    "   ]tE?( "       "   dM6?( "       "   UUUUUU?( "       "   mm?( "       "       ( "       "       ( "       "       ( "       "       ( "       "   ( "       "   UUUU( #       "   )I ?( #       #        G@  "  Y 0    #         @    Y      #         7@    Y      #         @    Y      #         ?    Y #     #               Y -     #               Y 7     #               Y A     # 	            # 
 Y K     # 
            #  Y U     #             $  Y _     #        G@  #  Y 0    #         ?( #       #   &^B?( #       #         ?( #       #         ?( #       #       ( #       #       ( #       #       ( #       #       ( #       #   UUUU( #       #       ( $       #   }|?( $       $        L@  #  Y 1    $               Y      $         @    Y      $               Y      $             $ 	 Y $     $               Y .     $             "  Y 8     $               Y B     $ 	            $ 
 Y L     $ 
            $  Y V     $             %  Y `     $        L@  $  Y 1    $   UUUU( $       $   ?( $       $       ( $       $       ( $       $       ( $       $       ( $       $       ( $       $       ( $       $       ( $       $       ( %       $   ?( %       %             $  Y 2    %             	  Y      %             	  Y      %             	  Y      %             	  Y %     %             	  Y /     %             	  Y 9     %             % 	 Y C     % 	            % 
 Y M     % 
            %  Y W     %             &  Y a     %             %  Y 2    %       ( %       %       ( %       %       ( %       %       ( %       %       ( %       %       ( %       %       ( %       %       ( %       %       ( %       %       ( &       %       ( &       &             %  Y 3    &             
  Y      &             &  Y      &             &  Y      &             
  Y &     &             & 	 Y 0     &             
  Y :     &             
  Y D     & 	            & 
 Y N     & 
            &  Y X     &             '  Y b     &             &  Y 3    &       ( &       &       ( &       &       ( &       &       ( &       &       ( &       &       ( &       &       ( &       &       ( &       &       ( &       &       ( '       &       ( '       '             &  Y 4    '               Y 	     '               Y      '             '  Y      '               Y '     '             ' 	 Y 1     '               Y ;     '               Y E     ' 	            ' 
 Y O     ' 
            '  Y Y     '             (  Y c     '             '  Y 4    '       ( '       '       ( '       '       ( '       '       ( '       '       ( '       '       ( '       '       ( '       '       ( '       '       ( '       '       ( (       '       ( (       (             '  Y 5    (             (  Y 
     (             (  Y      (             (  Y      (             (  Y (     (             (  Y 2     (             (  Y <     (             ( 	 Y F     ( 	            ( 
 Y P     ( 
            (  Y Z     (              	 Y d     (             (  Y 5    (       ( (       (       ( (       (       ( (       (       ( (       (       ( (       (       ( (       (       ( (       (       ( (       (       ( (       (       (        (       (       
 .   
    
 2 	           >      @                       7   
   	                    R       d          MbP?_   *    +                 %                     "               ?      ? U                                       (    	                    
          j   
      
   0       N  M    M    ?            p   Z 	          ]      `            	                       "                ?      ? 3   `
 #   `
 #   `
 #   	 `
 #   "      P  H               0    (    	                    
                     B3      d       2    3         	 M 
        N M 4     
 
    3  Q        Q      ;      Q      ;      Q              3  _          M 
        N M    	                 4  E   4  D 
   $  %                M P(  3  O                   & 	 Q        4  $  %                M P(  3  O                   &  Q        4  F  A     ~    
  3  O          G                     3  * {Gz?(\?       @?                              # M   4                    3  *               ?                                              # M   !         	 M 4  %         \         M     3  O                 &  Q        
   P s y '      4  %       H          M   Z 3  O              2   &  Q           P ( r i g h t ) '      4  5  2    3           
          O 4                       3   d    "
             q        3  O     q          %                M *  3  O                   Q        4  4         3  _          M 
        N M    	           M M <   4  4  4  %         L   f
     M P  3  O                & " Q        j   3P s y c h o m e t r i c   o n   F a i l e d   S t o p   T r i a l s   ( c o l l a p s e d   S S D s ) '      4  4        
        e         zG?      Gz?      (\?      (\?                                                                       	             e         ?                    UUUUUU?      mm?                                                                       	             e  
                     >      @                       7   
   	               (     u         d          MbP?_   *    +                 %                     "              ?      ?  U        (                                         
        
    
    
        
 f   (    '           
 '        "          0              (    	                    
          p   
      
   6       N  M    M       ?            0   -    i       ]      `            	                       "                ?      ? 3   `
 #   
 `
 #   `
 #   `
 #    `
 ^   #           @              (    	                    
             
      
   B    )          
 @  A     A        ?                        ]       )d                 $              <    <    #    h a r             X  3      d       2    3         	 M 
        N M 4     
 
    3  Q           P s y 1 Q      ;   (   Q      ;      Q              3  _          M 
        N M    	                 4  E   4     
 
    3  Q           P s y 2 Q      ;   (   Q      ;      Q            3  _          M 
        N M    	        ! !    4  E   4  D    $  %                M P(  3  O                   &  Q        4  $  %                M P(  3  O                   &  Q        4  F  A     %    <
  3  O       C  F                     3  *                                       ?                      # M   4                    3  *               ?                                              # M   !         	 M 4  %              (   M     3  O                 &  Q        
   S S D '      4  %       b   d       M   Z 3  O              D   &  Q           
P ( R e s p o n d ) '      4  5  2    3           
           4                       3   d    "
               u     3  O               %                M *  3  O                   Q        4  4         3  _          M 
        N M    	           M M <   4  4  4  %         U     (   M P  3  O           7      & 
 Q           
I n h i b i t i o n '      4  4        
        e               Y@            Y@           `n@          `n@            x@           x@           @          @            @           @           x@          x@                                                                                  	              	            e                                                  UUUUUU?      {	%?     /?      ]tE?     dM6?            ?     &^B?                   ?                                                                                  	              	            e  
    x  p   
      
   6       N  M    M       ?           `  -   Z       ]      `            	                       "                ?      ? 3   `
 #    `
 #   `
 #   `
 #                    R 3      d       2    3         	 M 
        N M 4     
 
    3  Q           P s y 3 Q      ;   (   Q      ;      Q              3  _          M 
        N M    	                 4  E   4     
 
    3  Q           P s y 4 Q      ;   (   Q      ;      Q            3  _          M 
        N M    	        ! !    4  E   4  D    $  %                M P(  3  O                   &  Q        4  $  %                M P(  3  O                   &  Q        4  F  A     '    7
  3  O   "    <  C                     3  *                                                               # M   4                    3  *               ?                                              # M   !         	 M 4  %              )   M     3  O                 &  Q        
   S S D '      4  %       d   [       M   Z 3  O              D   &  Q           
P ( R e s p o n d ) '      4  5  2    3           
           4                       3   d    "
               |     3  O               %                M *  3  O                   Q        4  4         3  _          M 
        N M    	           M M <   4  4  4  %         U     )   M P  3  O           7      &  Q           
I n h i b i t i o n '      4  4        
        e               Y@            Y@           `n@          `n@            x@           x@           @          @            @           @           x@          x@                                                                                  	              	            e                                     	%?     m&l?      ).?     ;:?      UUUUUU?     mm?            ?           ?                                                                                                             	              	            e  
    x  p   
      
   6       N  M    M       ?            0     #        ]      `    X        	                      M n  M i c r o s o f t   O f f i c e   D o c u m e n t   I m a g e      /        d   ,  ,   L e t t e r                                                                                                           widm                                                                                                                                         "  d      ,,      ?      ? 3   `
 #    `
 #   `
 #   `
 #         P  H   P          0    (    	                    
                      @X  3      d       2    3         	 M 
        N M 4     
 
    3  Q           P s y 5 Q      ;   (   Q      ;      Q              3  _          M 
        N M    	                 4  E   4     
 
    3  Q           P s y 6 Q      ;   (   Q      ;      Q            3  _          M 
        N M    	        ! !    4  E   4  D    $  %                M P(  3  O                   &  Q        4  $  %                M P(  3  O                   &  Q        4  F  A         f
  3  O       B  _                     3  *                                                               # M   4                    3  *               ?                                              # M   !         	 M 4  %                 M     3  O                 &  Q        
   S S D '      4  %       b   }       M   Z 3  O              D   &  Q           
P ( R e s p o n d ) '      4  5  2    3           
           4                       3   d    "
               v     3  O               %                M *  3  O                   Q        4  4         3  _          M 
        N M    	           M M <   4  4  4  %         Q        M P  3  O           7      &  Q           
I n h i b i t i o n '      4  4        
        e               Y@            Y@           `n@          `n@            x@           x@           @          @            @           @           x@          x@                                                                                  	              	            e                                                                                                                                                                                                                                                        	              	            e  
    x  p   
      
   6       N  M    M       ?            x  # i       ]      `    T        	                       "          T      ?      ? 3   `
 #    `
 #   `
 #   `
 #         P  H   `          0    (    	                    
                      @X  3      d       2    3         	 M 
        N M 4     
 
    3  Q           P s y 7 Q      ;   (   Q      ;      Q              3  _          M 
        N M    	                 4  E   4     
 
    3  Q           P s y 8 Q      ;   (   Q      ;      Q            3  _          M 
        N M    	        ! !    4  E   4  D    $  %                M P(  3  O                   &  Q        4  $  %                M P(  3  O                   &  Q        4  F  A         f
  3  O       B  ^                     3  *                                                               # M   4                    3  *               ?                                              # M   !         	 M 4  %                 M     3  O                 &  Q        
   S S D '      4  %       b   }       M   Z 3  O              D   &  Q           
P ( R e s p o n d ) '      4  5  2    3           
           4                       3   d    "
               v     3  O               %                M *  3  O                   Q        4  4         3  _          M 
        N M    	           M M <   4  4  4  %         Q        M P  3  O           7      &  Q           
I n h i b i t i o n '      4  4        
        e               Y@            Y@           `n@          `n@            x@           x@           @          @            @           @           x@          x@                                                                                  	              	            e                                                                                                                                                                                                                                                        	              	            e  
    x  p   
      
   6       N  M    M       ?            p #    5         ]      `            	                       "                ?      ? 3   `
 #    `
 #   `
 #   `
 #                    W? 3      d       2    3         	 M 
        N M 4     
 
    3  Q           P s y 9 Q      ;   (   Q        Q              3  _          M 
        N M    	                 4  E   4     
 
    3  Q           P s y 1 0 Q      ;   (   Q        Q            3  _          M 
        N M    	        ! !    4  E   4  D    $  %                M P(  3  O                   &  Q        4  $  %                M P(  3  O                   &  Q        4  F  A     #    A
  3  O       A  G                     3  *       ?      $@                                              # M   4                    3  *               ?                                              # M   !         	 M 4  %              '   M     3  O                 &  Q        
   S S D '      4  %       b   _       M   Z 3  O              D   &  Q           
P ( R e s p o n d ) '      4  5  2    3           
           4                       3   d    "
                    3  O               %                M *  3  O                   Q        4  4         3  _          M 
        N M    	           M M <   4  4  4  %         T     '   M P  3  O           7      &  Q           
I n h i b i t i o n '      4  4        
        e  e                                                                                                                                                                                                                                                        	              	            e  
    x  p   
      
   6       N  M    M       ?              @( <       ]      `            	                       "                ?      ? 3   `
 #    `
 #   `
 #    `
 #   !                  @X 3      d       2    3         	 M 
        N M 4     
 
    3  Q            C o l l a p s e d   P s y s Q      ;   (   Q      ;      Q              3  _          M 
        N M    	               4  E   4  D    $  %                M P(  3  O                   & ! Q        4  $  %                M P(  3  O                   &   Q        4  F  A     !    E
  3  O       B  J                     3  *                                                               # M   4                    3  *               ?                                              # M   !         	 M 4  %              &   M     3  O                 &  Q        
   S S D '      4  %       b   i       M   Z 3  O              D   &  Q           
P ( R e s p o n d ) '      4  5  2    3           
           4                       3   d    "
           .  
  4  
   3  O   .  
          %                M *  3  O                   Q        4  4         3  _          M 
        N M    	           M M <   4  4  4  %         T     &   M P  3  O           7      &  Q           
I n h i b i t i o n '      4  4        
        e               Y@           `n@            x@           @            @           x@                                           	             e                       Q^Cy?      	qV~B?      )I ?      }|?      ?                                           	             e  
   >     @             (     ( (    7   
                                      Oh +'0            @      H      \      p                                Matt Nelson       Matt Nelson       Microsoft Excel @    Q=@                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         . +,0      	      P      X      x                                                  Vanderbilt University                                           LinkedData    Psychometric    Inhibition            Worksheets                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     	   
                                                                      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /   0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?   @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _   `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   w   x   y   z   {   |   }                        R o o t   E n t r y                                                             F            9        W o r k b o o k                                                                                                 S u m m a r y I n f o r m a t i o n                           (                                           v           D o c u m e n t S u m m a r y I n f o r m a t i o n           8                                     ~                          >  	               R                  Q   	                \ p   Matt Nelson                                                                                                  B  a     =                        =  x < LJr38     X@        "              1          VA r i a l 1          VA r i a l 1          VA r i a l 1          VA r i a l 1        VA r i a l 1          VA r i a l 1         VA r i a l 1         VA r i a l 1          VA r i a l 1          VA r i a l 1         VA r i a l 1         VA r i a l 1          VA r i a l 1          VA r i a l     "$"#,##0_);\("$"#,##0\)!    "$"#,##0_);[Red]\("$"#,##0\)"    "$"#,##0.00_);\("$"#,##0.00\)'  "  "$"#,##0.00_);[Red]\("$"#,##0.00\)7 * 2  _("$"* #,##0_);_("$"* \(#,##0\);_("$"* "-"_);_(@_). ) )  _(* #,##0_);_(* \(#,##0\);_(* "-"_);_(@_)? , :  _("$"* #,##0.00_);_("$"* \(#,##0.00\);_("$"* "-"??_);_(@_)6 + 1  _(* #,##0.00_);_(* \(#,##0.00\);_(* "-"??_);_(@_)                                                                                                                                                                                                                                                                                                  +                )                ,                *                	                                          @ @                  @                 @                @                                                        @                                                   `     A1    
 LinkedData  xl    
 Inhibition         
  TEMPOexpr#       eccentricityArray[0]#       eccentricityArray[1]#       eccentricityArray[2]#       eccentricityArray[3]# $       nSaccPsySSD[0,0]           # $       nSaccPsySSD[0,1]           # $       nSaccPsySSD[0,2]           # $       nSaccPsySSD[0,3]         ?# $       nSaccPsySSD[0,4]          @# $       nSaccPsySSD[0,5]           # $       nSaccPsySSD[0,6]          @# $       nSaccPsySSD[0,7]         ?# $       nSaccPsySSD[0,8]         ?# $       nSaccPsySSD[0,9]         ?# $       nSaccPsySSD[1,0]           # $       nSaccPsySSD[1,1]           # $       nSaccPsySSD[1,2]           # $       nSaccPsySSD[1,3]          @# $       nSaccPsySSD[1,4]         @# $       nSaccPsySSD[1,5]         ?# $       nSaccPsySSD[1,6]           # $       nSaccPsySSD[1,7]           # $       nSaccPsySSD[1,8]           # $       nSaccPsySSD[1,9]           # $       nSaccPsySSD[2,0]           # $       nSaccPsySSD[2,1]           # $       nSaccPsySSD[2,2]           # $       nSaccPsySSD[2,3]           # $       nSaccPsySSD[2,4]          @# $       nSaccPsySSD[2,5]         ?# $       nSaccPsySSD[2,6]         @# $       nSaccPsySSD[2,7]           # $       nSaccPsySSD[2,8]           # $       nSaccPsySSD[2,9]           # $       nSaccPsySSD[3,0]           # $       nSaccPsySSD[3,1]           # $       nSaccPsySSD[3,2]           # $       nSaccPsySSD[3,3]         ?# $       nSaccPsySSD[3,4]          @# $       nSaccPsySSD[3,5]           # $       nSaccPsySSD[3,6]         ?# $       nSaccPsySSD[3,7]           # $       nSaccPsySSD[3,8]           # $       nSaccPsySSD[3,9]           # $       nSaccPsySSD[4,0]           # $       nSaccPsySSD[4,1]           # $       nSaccPsySSD[4,2]           # $       nSaccPsySSD[4,3]           # $       nSaccPsySSD[4,4]          @# $       nSaccPsySSD[4,5]         @# $       nSaccPsySSD[4,6]          @# $       nSaccPsySSD[4,7]         ?# $       nSaccPsySSD[4,8]           # $       nSaccPsySSD[4,9]           # $       nSaccPsySSD[5,0]           # $       nSaccPsySSD[5,1]           # $       nSaccPsySSD[5,2]           # $       nSaccPsySSD[5,3]         ?# $       nSaccPsySSD[5,4]          @# $       nSaccPsySSD[5,5]           # $       nSaccPsySSD[5,6]           # $       nSaccPsySSD[5,7]           # $       nSaccPsySSD[5,8]           # $       nSaccPsySSD[5,9]           # $       nSaccPsySSD[6,0]           # $       nSaccPsySSD[6,1]           # $       nSaccPsySSD[6,2]           # $       nSaccPsySSD[6,3]         ?# $       nSaccPsySSD[6,4]          @# $       nSaccPsySSD[6,5]         ?# $       nSaccPsySSD[6,6]         ?# $       nSaccPsySSD[6,7]           # $       nSaccPsySSD[6,8]           # $       nSaccPsySSD[6,9]           # $       nSaccPsySSD[7,0]           # $       nSaccPsySSD[7,1]           # $       nSaccPsySSD[7,2]           # $       nSaccPsySSD[7,3]           # $       nSaccPsySSD[7,4]           # $       nSaccPsySSD[7,5]           # $       nSaccPsySSD[7,6]           # $       nSaccPsySSD[7,7]           # $       nSaccPsySSD[7,8]           # $       nSaccPsySSD[7,9]           # $       nSaccPsySSD[8,0]           # $       nSaccPsySSD[8,1]           # $       nSaccPsySSD[8,2]           # $       nSaccPsySSD[8,3]           # $       nSaccPsySSD[8,4]           # $       nSaccPsySSD[8,5]           # $       nSaccPsySSD[8,6]           # $       nSaccPsySSD[8,7]           # $       nSaccPsySSD[8,8]           # $       nSaccPsySSD[8,9]           # $       nSaccPsySSD[9,0]           # $       nSaccPsySSD[9,1]           # $       nSaccPsySSD[9,2]           # $       nSaccPsySSD[9,3]           # $       nSaccPsySSD[9,4]           # $       nSaccPsySSD[9,5]           # $       nSaccPsySSD[9,6]           # $       nSaccPsySSD[9,7]           # $       nSaccPsySSD[9,8]           # $       nSaccPsySSD[9,9]           # %       nTrialPsySSD[0,0]           # %       nTrialPsySSD[0,1]         ?# %       nTrialPsySSD[0,2]         ?# %       nTrialPsySSD[0,3]         @# %       nTrialPsySSD[0,4]         @# %       nTrialPsySSD[0,5]          @# %       nTrialPsySSD[0,6]         @# %       nTrialPsySSD[0,7]          @# %       nTrialPsySSD[0,8]         ?# %       nTrialPsySSD[0,9]         ?# %       nTrialPsySSD[1,0]           # %       nTrialPsySSD[1,1]           # %       nTrialPsySSD[1,2]         @# %       nTrialPsySSD[1,3]         @# %       nTrialPsySSD[1,4]         @# %       nTrialPsySSD[1,5]         ?# %       nTrialPsySSD[1,6]           # %       nTrialPsySSD[1,7]           # %       nTrialPsySSD[1,8]           # %       nTrialPsySSD[1,9]           # %       nTrialPsySSD[2,0]           # %       nTrialPsySSD[2,1]           # %       nTrialPsySSD[2,2]         ?# %       nTrialPsySSD[2,3]           # %       nTrialPsySSD[2,4]         @# %       nTrialPsySSD[2,5]         ?# %       nTrialPsySSD[2,6]         @# %       nTrialPsySSD[2,7]           # %       nTrialPsySSD[2,8]           # %       nTrialPsySSD[2,9]           # %       nTrialPsySSD[3,0]           # %       nTrialPsySSD[3,1]           # %       nTrialPsySSD[3,2]         ?# %       nTrialPsySSD[3,3]         ?# %       nTrialPsySSD[3,4]         @# %       nTrialPsySSD[3,5]         ?# %       nTrialPsySSD[3,6]         ?# %       nTrialPsySSD[3,7]           # %       nTrialPsySSD[3,8]           # %       nTrialPsySSD[3,9]           # %       nTrialPsySSD[4,0]           # %       nTrialPsySSD[4,1]           # %       nTrialPsySSD[4,2]         ?# %       nTrialPsySSD[4,3]          @# %       nTrialPsySSD[4,4]         @# %       nTrialPsySSD[4,5]         @# %       nTrialPsySSD[4,6]          @# %       nTrialPsySSD[4,7]         ?# %       nTrialPsySSD[4,8]           # %       nTrialPsySSD[4,9]           # %       nTrialPsySSD[5,0]           # %       nTrialPsySSD[5,1]           # %       nTrialPsySSD[5,2]         @# %       nTrialPsySSD[5,3]         ?# %       nTrialPsySSD[5,4]          @# %       nTrialPsySSD[5,5]           # %       nTrialPsySSD[5,6]           # %       nTrialPsySSD[5,7]           # %       nTrialPsySSD[5,8]           # %       nTrialPsySSD[5,9]           # %       nTrialPsySSD[6,0]           # %       nTrialPsySSD[6,1]         ?# %       nTrialPsySSD[6,2]          @# %       nTrialPsySSD[6,3]         ?# %       nTrialPsySSD[6,4]         @# %       nTrialPsySSD[6,5]         ?# %       nTrialPsySSD[6,6]         ?# %       nTrialPsySSD[6,7]           # %       nTrialPsySSD[6,8]           # %       nTrialPsySSD[6,9]           # %       nTrialPsySSD[7,0]           # %       nTrialPsySSD[7,1]           # %       nTrialPsySSD[7,2]           # %       nTrialPsySSD[7,3]           # %       nTrialPsySSD[7,4]           # %       nTrialPsySSD[7,5]           # %       nTrialPsySSD[7,6]           # %       nTrialPsySSD[7,7]           # %       nTrialPsySSD[7,8]           # %       nTrialPsySSD[7,9]           # %       nTrialPsySSD[8,0]           # %       nTrialPsySSD[8,1]           # %       nTrialPsySSD[8,2]           # %       nTrialPsySSD[8,3]           # %       nTrialPsySSD[8,4]           # %       nTrialPsySSD[8,5]           # %       nTrialPsySSD[8,6]           # %       nTrialPsySSD[8,7]           # %       nTrialPsySSD[8,8]           # %       nTrialPsySSD[8,9]           # %       nTrialPsySSD[9,0]           # %       nTrialPsySSD[9,1]           # %       nTrialPsySSD[9,2]           # %       nTrialPsySSD[9,3]           # %       nTrialPsySSD[9,4]           # %       nTrialPsySSD[9,5]           # %       nTrialPsySSD[9,6]           # %       nTrialPsySSD[9,7]           # %       nTrialPsySSD[9,8]           # %       nTrialPsySSD[9,9]           #       ssdArray[0]#       ssdArray[1]#       ssdArray[2]#       ssdArray[3]#       ssdArray[4]#       ssdArray[5]#       ssdArray[6]#       ssdArray[7]#       ssdArray[8]#       ssdArray[9]#       StdDocumentName# +       targ1ProportionArray[0]   ffffff?# +       targ1ProportionArray[1]   zG?# +       targ1ProportionArray[2]   Gz?# +       targ1ProportionArray[3]         ?# +       targ1ProportionArray[4]   (\?# +       targ1ProportionArray[5]   (\?# +       targ1ProportionArray[6]   ?# +       targ1ProportionArray[7]           # +       targ1ProportionArray[8]           # +       targ1ProportionArray[9]                        "  r   j     0                               	         3       A  @  @             	        nTrial  nSaccade
  P(saccade)  SSD  Total Stop Proprtion:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      total  Eccentricity 
  :+     c c                 
   	                  o3  l       d          MbP?_   *    +                 %                    M n  M i c r o s o f t   O f f i c e   D o c u m e n t   I m a g e      /        d   ,  ,   L e t t e r                                                                                                           widm                                                                                                                                         "  d     ,,      ?      ? U   }                                                                                                                      	            
                                                                                                                                                                                                
          
                    Y                 Y                 Y                 Y         (\?    Y         (\?    Y         ?    Y       	              Y       
             	 Y                    
 Y     
                     Y                       !       Y i                    Y s                    Y }                    Y                     Y                     Y                     Y       	             	 Y       
             
 Y                     Y     #         S@    %                 Y               ?    Y j                    Y t                    Y ~                    Y                   
  Y                     Y               ?    Y       	             	 Y       
             
 Y                     Y     
        >    ?   (  %    %  @@              Y               ?    Y k              @    Y u              ?    Y               ?    Y               ?    Y               @    Y                @    Y       	             	 Y       
             
 Y                     Y                 Y               @    Y l              @    Y v                  	  Y               ?    Y                @    Y               ?  	  Y               ?  	  Y       	             	 Y       
             
 Y                     Y                 Y               @    Y m              @  	  Y w              @    Y               @  
  Y               @    Y                @    Y               @    Y       	             	 Y       
             
 Y                     Y                 Y                @    Y n              ?    Y x              ?    Y               ?    Y               @    Y                   
  Y               ?    Y       	            	 	 Y       
            	 
 Y                   	  Y      	           Y      	         @    Y o     	             
  Y y     	         @    Y      	         ?    Y      	          @    Y      	               Y      	         ?    Y      	 	            
 	 Y      	 
            
 
 Y      	             
  Y      
         	  Y      
          @  	  Y p     
               Y z     
               Y      
             	  Y      
         ?    Y      
               Y      
               Y      
 	             	 Y      
 
             
 Y      
               Y               
  Y               ?  
  Y q                    Y {                    Y                     Y                     Y                     Y                     Y       	             	 Y       
             
 Y                     Y                 Y               ?    Y r                    Y |                  
  Y                     Y                   	  Y                     Y                   
  Y       	             	 Y       
             
 Y                     Y     
        #          1@    %               ,@         	 -               (@(                @                *@                @                "@  	      	            
      
                                  1            +  `%    1            +   %   1        +   %   1            +   %   1            +   %   1            +   %   1            +   %   1    Moz    +  		 %  		 1        +  

 %  

 1    C5    +   %   
         
                    Y                 Y                 Y                 Y         (\?    Y         (\?    Y         ?    Y       	              Y       
             	 Y                    
 Y         ffffff?    Y         zG?    Y         Gz?    Y               ?    Y         (\?    Y         (\?    Y         ?    Y                     Y                     Y                     Y     
                     Y                       !       Y                     Y                     Y                     Y #                   	 Y -                    Y 7                    Y A      	             
 Y K      
              Y U                    Y _                Y     !      h' D D  !            D D  !            D D  !            D D  !    UUUU    D D  !    ;;    D D  !            D D  !        D 	D 	 !    UUUU    D 
D 
 !            D D  1    ffff    %    %               Y                     Y                     Y                     Y                     Y $                   	 Y .                    Y 8                    Y B      	             
 Y L      
              Y V                   	 Y `                Y     !                D D  !            D D  !            D D  !    UUUU    D D  !    UUUU    D D  !    mm    D D  !                D D  !            D 	D 	 !            D 
D 
 !            D D  1                %    %               Y                     Y                     Y                     Y                     Y %                    Y /                    Y 9                    Y C      	             
 Y M      
              Y W                   	 Y a                Y     !                D D  !                D D  !                D D  !                D D  !                D D  !                D D  !                D D  !            D 	D 	 !    UUUU    D 
D 
 !            D D  1                %    %               Y               ?    Y                @    Y                     Y               ?    Y &                    Y 0              ?    Y :              ?    Y D      	             
 Y N      
              Y X                   	 Y b                Y     !    UUUUUU?    D D  !    UUUUUU?    D D  !            D D  !          ?    D D  !                D D  !          ?    D D  !          ?    D D  !            D 	D 	 !            D 
D 
 !            D D  1    tE]t?    %    %               Y                @    Y 	              @    Y                @    Y                @    Y '               @    Y 1               @    Y ;               @    Y E      	             
 Y O      
              Y Y                   	 Y c                Y     !    UUUUUU?    D D  !          ?    D D  !    UUUUUU?    D D  !    UUUUUU?    D D  !    UUUUUU?    D D  !          ?    D D  !    UUUUUU?    D D  !            D 	D 	 !            D 
D 
 !            D D  1    UUUUUU?    %    %               Y                     Y 
              ?    Y               ?    Y                     Y (              @    Y 2                    Y <              ?    Y F      	             
 Y P      
              Y Z                    Y d                Y     !                D D  !          ?    D D  !          ?    D D  !                D D  !          ?    D D  !            D D  !          ?    D D  !            D 	D 	 !            D 
D 
 !            D D  1    333333?    %    %               Y                @    Y                     Y               @   	 Y               ?    Y )               @    Y 3                    Y =              ?    Y G      	             
 Y Q      
              Y [                    Y e                Y     !    UUUUUU?    D D	  !            D D	  !          ?    D D	  !          ?    D D	  !          ?    D D	  !            D D	  !          ?    D D	  !            D 	D	 	 !            D 
D	 
 !            D D	  1    ]tE?    %    %	 	              Y               ?    Y                     Y                     Y                      Y *              ?    Y 4                   	 Y >                    Y H      	             
 Y R      
              Y \                    Y f                Y     !          ?    D D
  !            D D
  !            D D
  !            D D
  !          ?    D D
  !            D D
  !    UUUU    D D
  !    3333    D 	D
 	 !            D 
D
 
 !            D D
  1    UUUUUU?    %    %
 
              Y               ?    Y                     Y                     Y !                    Y +                    Y 5                   	 Y ?                    Y I      	             
 Y S      
              Y ]                    Y g                Y     !          ?    D D  !            D D  !            D D  !            D D  !            D D  !            D D  !            D D  !            D 	D 	 !            D 
D 
 !            D D  1          ?    %    %               Y               ?    Y                     Y                     Y "                    Y ,                    Y 6                    Y @                   	 Y J      	             
 Y T      
              Y ^                    Y h                Y     !          ?    D D  !            D D  !            D D  !            D D  !            D D  !            D D  !            D D  !            D 	D 	 !            D 
D 
 !            D D  1          ?    %    %   6 p8   Jkkkkkkkky X33333333>      @                       7   
   	                  4m  nm       d          MbP?_   *    +                 %                     "               ?      ?U                           
         "        8  0              (    	                    
          p   
      
   6       N  M    M       ?            0   -   i       ]      `    F        	                       "          F      ?      ? 3   `
 #    `
 #   `
 #  	 `
 #   
                 .  3      d       2    3         	 M 
        N M 4      
    3  Q           P s y 1 Q      ;      Q      =      Q              3  _          M 
        N M    	                 4  E   4      
    3  Q           P s y 2 Q      ;      Q      =      Q            3  _          M 
        N M    	        ! !    4  E   4  D    $  %                M P(  3  O                   & 
 Q        4  $  %                M P(  3  O                   & 	 Q        4  F  A      %  j  <
  3  O          F                     3  *                                       ?                      # M   4                    3  *               ?                                              # M   !         	 M 4  %       P       (   M     3  O                 &  Q        
   S S D '      4  %       <   d  r     M   Z 3  O              D   &  Q           
P ( R e s p o n d ) '      4  5  2    3           
           4                       3   d    "
           >          3  O   @            %                M *  3  O                   Q        4  4         3  _          M 
        N M    	           M M <   4  4  4  %       :  U   +  (   M P  3  O           7      &  Q           
I n h i b i t i o n '      4  4        
        e               ?            ?e                                                                                           UUUUUU?     UUUUUU?      UUUUUU?           ?                         ?      UUUUUU?                         ?                         ?              	           ? 	            e  
    x  p   
      
   6       N  M    M       ?            p    #        ]      `    *        	                       "          *      ?      ? 3   `
 #    `
 #   `
 #   `
 #                    ?- 3      d       2    3         	 M 
        N M 4      
    3  Q           P s y 3 Q      ;      Q      =      Q              3  _          M 
        N M    	                 4  E   4      
    3  Q           P s y 4 Q      ;      Q      =      Q            3  _          M 
        N M    	        ! !    4  E   4  D    $  %                M P(  3  O                   &  Q        4  $  %                M P(  3  O                   &  Q        4  F  A   7  '    7
  3  O          C                     3  *                                                               # M   4                    3  *               ?                                              # M   !         	 M 4  %       {       )   M     3  O                 &  Q        
   S S D '      4  %       <   [  s     M   Z 3  O              D   &  Q           
P ( R e s p o n d ) '      4  5  2    3           
           4                       3   d    "
           =          3  O   =            %                M *  3  O                   Q        4  4         3  _          M 
        N M    	           M M <   4  4  4  %       :  U   ,  )   M P  3  O           7      &  Q           
I n h i b i t i o n '      4  4        
        e               ?            ?e                                                                                                              ?      UUUUUU?     UUUUUU?            ?                         ?           ?                                                       	              	            e  
                     >     @                       7   
                                                                                                                                                                                                                           Oh +'0            @      H      \      p                                Matt Nelson       Matt Nelson       Microsoft Excel @    Q=@    /&                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      . +,0      	      P      X      x                                                  Vanderbilt University                                           LinkedData    Inhibition            Worksheets                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      	   
                                                                      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /   0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?   @   B   C   D   E   F   G   H   J   K   L   M   N   O   P   R o o t   E n t r y                                                             F            |        W o r k b o o k                                                                                          ?       S u m m a r y I n f o r m a t i o n                           (                                           A           D o c u m e n t S u m m a r y I n f o r m a t i o n           8                                     I          //--------------------------------------------------------------------------------------------------
// process CMD_PGS();
//
// Figure out all stimuli that will be needed on the next countermanding trial and
// place it all into video memory.
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011


declare CMD_PGS();                       										// see GRAPHS.pro

process CMD_PGS()                        										// see GRAPHS.pro
{										
										
// number the pgs that need to be drawn
declare hide int   	blank       = 0;										
declare hide int	fixation_pd = 1;										
declare hide int	fixation    = 2;										
declare hide int	target_pd   = 3;										
declare hide int	target      = 4;										
declare hide int	signal_pd   = 5;										
declare hide int	signal      = 6;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Calculate screen coordinates for stimuli on this trial								
targSize         = sizeArray[targIndex];   													// Figure out the attributes of the current target 
targColor        = targIndex + 1;																// zero is reserved for black.  see SET_CLRS.pro							
												

opposite = ((screenHeight/2)-pdBottom);														// Figure out angle and eccentricity of photodiode marker in pixels
adjacent = ((screenWidth/2)-pdLeft);                                                         // NOTE: I am assuming your pd is in the lower left quadrant of your screen
pdAmp = sqrt((opposite * opposite) + (adjacent * adjacent));
pdAngle = rad2deg(atan (opposite / adjacent));
pdAngle = pdAngle + 180; 																	//change this for different quadrent or write some code for flexibility


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 1
// print("fixation with photodiode");
dsendf("rw %d,%d;\n",fixation_pd,fixation_pd); 												// draw first pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 2	  
// print("fixation");
dsendf("rw %d,%d;\n",fixation,fixation);   													// draw second pg of video memory                                       
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 3	 
// print("target with photodiode");
dsendf("rw %d,%d;\n",target_pd,target_pd);  												// draw pg 3                                        
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
if (!Classic)																				// if we are doing stop-signal 2.0 (not classic)
	{
	spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, open, deg2pix_X, deg2pix_Y); // draw fixation point
	}
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 4	  
// print("target");
dsendf("rw %d,%d;\n",target,target);  														// draw pg 4                                        
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);         	// draw target
if (!Classic)																				// if we are doing stop-signal 2.0 (not classic)
	{
	spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, open, deg2pix_X, deg2pix_Y);   	// draw fixation point
	}
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 5 
// print("signal with photodiode");
dsendf("rw %d,%d;\n",signal_pd,signal_pd);    												// draw pg 5                                      
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);         	// draw target
if (Classic)
spawnwait DRW_SQR(fixSize*1, fixAngle, fixAmp, signalColor, fill, deg2pix_X, deg2pix_Y);   		// draw stop signal/ignore stim
if (!Classic)																				// if we are doing stop-signal 2.0 (not classic)
	{
	spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, open, deg2pix_X, deg2pix_Y); // draw fixation point
	}
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 6	 
// print("signal");
dsendf("rw %d,%d;\n",signal,signal);   														// draw pg 6                                       					
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
spawnwait DRW_SQR(fixSize*1, fixAngle, fixAmp, signalColor, fill, deg2pix_X, deg2pix_Y);   		// draw stop signal/ignore stim
if (!Classic)																				// if we are doing stop-signal 2.0 (not classic)
	{
	spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, open, deg2pix_X, deg2pix_Y); // draw fixation point
	}
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 0 (last is displayed first)	
// print("blank"); 																			
dsendf("rw %d,%d;\n",blank,blank);                                          				// draw the blank screen last so that it shows up first
dsendf("cl:\n");                                                                            // clear screen (that's all)


}
//--------------------------------------------------------------------------------------------
// Run a countermanding trial based on the variables calculated by SETC_TRL.pro and those 
// given by the user.
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011


declare CMDTRIAL();			// animated graph object

process CMDTRIAL()        		// animated graph object
{


// Number the trial stages to make them easier to read below
declare hide int 	need_fix  	= 1;
declare hide int 	fixating  	= 2;
declare hide int 	targ_on   	= 3;
declare hide int 	in_flight 	= 4;
declare hide int 	on_target 	= 5;	
declare hide int 	stage;

// Number the stimuli pages to make reading easier
declare hide int   	blank       = 0;
declare hide int	fixation_pd = 1;
declare hide int	fixation    = 2;
declare hide int	target_pd   = 3;
declare hide int	target      = 4;
declare hide int	signal_pd   = 5;
declare hide int	signal      = 6;


										
// Timing variables which will be used to time task
declare hide float 	fix_spot_time; 					
declare hide float  targ_time; 					
declare hide float  saccade_time;
declare hide float 	aquire_fix_time;
declare hide float 	stop_sig_time;
declare hide float	aquire_targ_time;	
declare int			ssdMS;		// ssd in ms, not in screen flips	

// Have to be reset on every iteration since 
// variable declaration only occurs at load time
trl_running 		= 1;
stage 				= need_fix;
ssdMS = round(ssd * (1000.0/screenRefreshRate));

// Tell the user what's up
printf(" \n");
printf("# %d",nTrial);
printf(" (%d",nTrialComplete);
printf(" correct)\n");
if (trialType == goTrial)
	{
	printf("GO\n");
	printf("holdtime = %d\n",preTargHoldtime);
	}
if (trialType == stopTrial)
	{
	printf("STOP\n");
	printf("holdtime = %d\n",preTargHoldtime);
	printf("               ssd = %d\n", ssdMS);
	}
if (trialType == ignoreTrial)
	{
	printf("IGNORE\n");
	printf("holdtime = %d\n",preTargHoldtime);
	printf("               isd = %d\n", ssdMS);
	}


																		// HERE IS WHERE THE FUN BEGINS
Event_fifo[Set_event] = TrialStart_;									// queue TrialStart_ strobe
Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
dsendf("vp %d\n",fixation_pd);											// flip the pg to the fixation stim with pd marker
fix_spot_time = time();  												// record the time
Event_fifo[Set_event] = FixSpotOn_;										// queue strobe
Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
dsendf("XM RFRSH:\n"); 													// wait one vertical retrace
dsendf("vp %d\n",fixation);												// flip the pg to the fixation stim without pd marker
oSetAttribute(object_fix, aVISIBLE); 									// turn on the fixation point in animated graph


while (trl_running)														// trials ending will set trl_running = 0
	{	
	
//--------------------------------------------------------------------------------------------
// STAGE need_fix (the fixation point is on, but the subject hasn't looked at it)
	if (stage == need_fix)
		{		
		if (In_FixWin)													// If the eyes have entered the fixation window (before time, see below)...
			{
			aquire_fix_time = time();									// ...function call to time to note current time and...
			trialStartTime = aquire_fix_time;							// Global output
			Event_fifo[Set_event] = Fixate_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = fixating;											// ...advance to the next stage.
			}
		else if (time() > fix_spot_time + allowFixTime)				// But if time runs out...
			{
			trialOutcome = noFix;    									// TRIAL OUTCOME ERROR (no fixation)
			lastOutcome = noChange;								// Don't change SSD
			lastStopArray[ampIndex] = noChange;
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen,...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Aborted (no fixation)\n");							// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}			
		}
		
		

//--------------------------------------------------------------------------------------------
// STAGE fixating (the subject is looking at the fixation point waiting for target onset)		
	else if (stage == fixating)
		{
		if (!In_FixWin && time() > aquire_fix_time + 100)													// If the eyes stray out of the fixation window...
			{
			trialOutcome = brokeFix;									// TRIAL OUTCOME ERROR (broke fixation)
			lastOutcome = noChange;								// Don't change SSD
			lastStopArray[ampIndex] = noChange;
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}
		else if (In_FixWin && time() > aquire_fix_time + preTargHoldtime)	// But if the eyes are still in the window at end of holdtime...
			{
			dsendf("vp %d\n",target_pd);								// ...flip the pg to the target with pd marker...	
			targ_time = time(); 										// ...record the time...
			dsendf("XM RFRSH:\n"); 										// ...wait one vetical retrace...
			dsendf("vp %d\n",target);									// ...flip the pg to the target without pd marker.
			
			if (trialType == stopTrial ||									// If it is a stop or ignore trial present the signal.
			trialType == ignoreTrial)										// This happens here so that no overhead intervenes between commands.
				{														// That way the # of vertical retraces remains independant of incidental processing time.
																		// (Even so, sometimes we will accidentally wait n+1 retraces. Such is vdosync.)
				dsendf("vw %d\n",ssd-1);							// Wait so many vertical retraces (one is waited implicitly b/c photodiode marker above)...
				dsendf("vp %d\n",signal_pd);							// ...flip the pg to the signal with the pd marker...
				stop_sig_time = targ_time + ssdMS; 		// ...record TEMPO time of presentation...
				dsendf("XM RFRSH:\n"); 									// ...wait 1 vertical retrace...
				dsendf("vp %d\n",signal);								// ...and flip the pg to the signal without pd marker.
				}
				
			Event_fifo[Set_event] = FixSpotOff_;						// Queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			
																		// Now the animated graphs have to catch up (seperate so that stim timing stays tight)
			if (trialType == goTrial)										// If the trial is a go trial...
				{
				oSetAttribute(object_targ, aVISIBLE); 					// ...show target in animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 					// ...remove fixation point from animated graph.
				}
			else if (trialType == ignoreTrial)							// But if the trial is an ignore trial
				{
				oSetAttribute(object_targ, aVISIBLE); 					// ...just show target in animated graph (fixation point stays on).
				}														// If it is a stop trial the target just never comes up in the animated graph.
				
			stage = targ_on;											// Advance to the next trial stage.				
			}
		}
		
		

//--------------------------------------------------------------------------------------------
// STAGE targ_on (the target has been presented but the subject is still fixating)		
	else if (stage == targ_on)
		{		
		if (!In_FixWin)													// If the eyes leave the fixation window...
			{															// ...we have a saccade, so...
			saccade_time = time();										// ...record the time...
			Event_fifo[Set_event] = Saccade_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			printf("                          rt = %d\n",saccade_time - targ_time);	// ...tell the user whats up...
			stage = in_flight;											// ...and advance to the next stage.
			}
		else if (In_FixWin &&  											// But if no saccade occurs...
			time() > targ_time + saccTimeMax && 					// ...and time for a saccade runs out...
			(trialType == goTrial || trialType == ignoreTrial))				// ...and a saccade was supposed to be made.
			{
			trialOutcome = goIncorrect;           							// TRIAL OUTCOME ERROR (incorrect go trial)
			lastOutcome = noChange;								// Don't change SSD
			lastStopArray[ampIndex] = noChange;
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (no saccade)\n");								// ...tell the user whats up...
			spawn SVR_BELL();
			trl_running = 0;											// ...and terminate the trial.
			}				
		else if (In_FixWin &&											// But if no saccade occurs...
			time() > targ_time + ssdMS + holdStopDuration && 				// ...and time for a saccade runs out...
			trialType == stopTrial)										// ...and a saccade was NOT supposed to be made...
			{
			trialOutcome = nogoCorrect;   								// TRIAL OUTCOME CORRECT (canceled trial)
			lastOutcome = success;									// set the global for staircasing...
			lastStopArray[ampIndex] = success;
			nTrialAmpSSD[ampIndex, decideIndex] = nTrialAmpSSD[ampIndex, decideIndex] + 1;  //tally that it was a stop trial (for exporting to excel)
			dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			Event_fifo[Set_event] = Correct_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			printf("Correct (canceled)\n");								// ...tell the user whats up...
			if (Canc_alert)
				{
				spawn SVR_BEL2();										// for training purposes
				}
			trl_running = 0;  											// ...and terminate the trial.
			}		
		}
		
		
		
//--------------------------------------------------------------------------------------------
// STAGE in_flight (eyes have left fixation window but have not entered target window)		
	else if (stage == in_flight)
		{
		if (In_TargWin)													// If the eyes get into the target window...
			{
			aquire_targ_time = time();									// ...record the time...
			Event_fifo[Set_event] = Decide_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = on_target;											// ...and advance to the next stage of the trial.
			if (trialType == stopTrial)									// But if a saccade was the wrong thing to do...
				{												
				Event_fifo[Set_event] = Error_sacc;						// ...queue strobe for Neuro Explorer
				Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.
				nTrialAmpSSD[ampIndex, decideIndex] = nTrialAmpSSD[ampIndex, decideIndex] + 1;  //tally that it was a stop trial (for exporting to excel)
				nSaccAmpSSD[ampIndex, decideIndex] = nSaccAmpSSD[ampIndex, decideIndex] + 1;  //tally that it was a respond trial (for exporting to excel)
				}
			else 														// Otherwise...
				{								
				Event_fifo[Set_event] = Correct_;					// ...queue strobe for Neuro Explorer
				Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.					
				}
			}
		else if (time() > saccade_time + saccDurationMax)				// But, if the eyes are out of the target window and time runs out...
			{
			trialOutcome = saccOut;   									// TRIAL OUTCOME ERROR (innacurrate saccade)
			if (trialType == stopTrial)									// But if a saccade was the wrong thing to do...
				{												
				lastOutcome = failure;								// ...record the failure.
				lastStopArray[ampIndex] = failure;
				}
			else 														// Otherwise...
				{								
				lastOutcome = noChange;							// ...make sure that the last outcome is cleared.						
				lastStopArray[ampIndex] = noChange;
				}
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (inaccurate saccade)\n");						// ...tell the user whats up...
			trl_running = 0; 											// ...and terminate the trial.
			}
		}
	
	
	
//--------------------------------------------------------------------------------------------
// STAGE on_target (eyes have entered the target window.  will they remain there for duration?)	
	else if (stage == on_target)
		{
		if (!In_TargWin)												// If the eyes left the target window...
			{			
			trialOutcome = brokeTarg;									// TRIAL OUTCOME ERROR (broke target fixation)
			if (trialType == stopTrial)									// But if a saccade was the wrong thing to do...
				{												
				lastOutcome = failure;
				lastStopArray[ampIndex] = failure;
				}
			else 														// Otherwise...
				{								
				lastOutcome = noChange;							// ...make sure that the last outcome is cleared.						
				lastStopArray[ampIndex] = noChange;
				}
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (broke target fixation)\n");					// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}		
		else if (In_TargWin  											// But if the eyes are still in the target window...
			&&  time() > aquire_targ_time + targHoldtime)				// ...and the target hold time is up...
			{
			if (trialType == goTrial || trialType == ignoreTrial)			// ...and a saccade was the correct thing to do...
				{
				trialOutcome = goTarg;								//TRIAL OUTCOME CORRECT (correct go trial)
				lastOutcome = noChange;							// Don't change SSD
				lastStopArray[ampIndex] = noChange;
				Event_fifo[Set_event] = Correct_;						// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue...
				printf("Correct (saccade)\n");							// ...tell the user whats up...
				}
			else if (trialType == stopTrial)								// But if a saccade was the wrong thing to do...
				{
				trialOutcome = nogoTarg;								//TRIAL OUTCOME ERROR (noncanceled trial)
				lastOutcome = failure;
				lastStopArray[ampIndex] = failure;				
				printf("Error (noncanceled)\n");						// ...tell the user whats up...
				}														// Either way we are done, so...
			dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			trl_running = 0;											// ...and terminate the trial.
			}			
		}
		
	if (Move_ct > 0)
		{
		trialOutcome = bodyMove;   									// TRIAL OUTCOME ABORTED (the body was moving)
		lastOutcome = noChange;								// ...make sure that the last outcome is cleared.	
		lastStopArray[ampIndex] = failure;
		dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
		oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
		oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
		printf("Aborted (body movement)\n");							// ...tell the user whats up...
		trl_running = 0; 											// ...and terminate the trial.
		}
		
	nexttick;
	}
}// This sets all of the user defined global variables.
// It is needed because of the loop structure which allows multiple tasks to run 
// from the same protocol.  If multiple protocols use the same variables, we may 
// run into problems if we don't specifically reset them at the beginning of each
// task change.
//
// written by david.c.godlove@vanderbilt.edu 	July, 2011
// 11-2011: Integrated choice countermanding task. -pgm
// 11-2011: Integrated visually guided saccade task. -pgm
// 11-2011: Integrated amplitude saccade task. -pgm

declare DEFAULT();

process DEFAULT()
{



declare int i;
declare hide int r_, g_, b_;		
r_ = 0; g_ = 1; b_ = 2;	


// Once DEFAULT is run, don't run it again unless loadDefault gets set back to 1;
loadDefault = 0;
//----------------------------------------------------------------------------------------------------------------
// Task-specific rewards:
if (state == stateFIX ||
	state == stateVIS ||
	state == stateAMP)
	{
	baseRewardDuration = 40;
	}
else if (state == stateMEM)
	{
	baseRewardDuration = 55;
	}
else if (state == stateDEL)
	{
	baseRewardDuration = 55;
	}
else if (state == stateCMD)
	{
	baseRewardDuration = 60;
	}
else if (state == stateCCM)
	{
	baseRewardDuration = 70;
	}
else if (state == stateGNG)    // monkey can complete these trials quicker, so they should earn less reward per trial (than countermanding or choice countermanding)
	{
	baseRewardDuration = 70;
	}
else if (state == stateMCM)    // monkey can complete these trials quicker, so they should earn less reward per trial (than countermanding or choice countermanding)
	{
	baseRewardDuration = 60;
	}


//----------------------------------------------------------------------------------------------------------------
// Trial type distributions (MUST SUM TO 100)
if (state == stateCMD)
	{
	goPct				= 65.0;
	stopPct				= 35.0;
	ignorePct			= 0;
	}
else if (state == stateCCM)
	{
	goPct				= 57.0;
	stopPct				= 43;
	ignorePct			= 0;
	}
else if (state == stateGNG)
	{
	goPct				= 50.0;
	NogoPct				= 50.0;
	}

Bonus_weight			= 0.0;	// percentage of time that the subject is wrong but gets rewarded anyway.
Dealer_wins_weight		= 0.0;	// percentage of time that the subject is right but gets punished anyway.

BigR_weight				= 33.33;// weights for random changes of reward targSize
MedR_weight				= 33.34;// weights for random changes of reward targSize
SmlR_weight				= 33.33;// weights for random changes of reward targSize
SmlP_weight				= 33.33;// weights for random changes of punsiment targSize
MedP_weight				= 33.34;// weights for random changes of punsiment targSize
BigP_weight				= 33.33;// weights for random changes of punsiment targSize



//----------------------------------------------------------------------------------------------------------------
// Stimulus properties
// White iso luminant value is 35,33,27;
// Red iso luminant value is is 63,0,0;
// Green iso luminant value is 0,36,0;
// Blue iso luminant value is 0,0,59;
Classic					= 0;

stopColorArray[r_]		= 45;	
stopColorArray[g_]		= 45;	
stopColorArray[b_]		= 0;	

ignoreColorArray[r_]	= 0;	
ignoreColorArray[g_]	= 36;	
ignoreColorArray[b_]	= 0;	
				
fixColorArray[r_]		= 35;	
fixColorArray[g_]		= 33;	
fixColorArray[b_]		= 27;	

								
// targColorArray[0,r_]		= 35;	// targColor of each target individually
// targColorArray[0,g_]		= 33;	// targColor of each target individually
// targColorArray[0,b_]		= 27;	// targColor of each target individually
				
// targColorArray[1,r_]		= 35;
// targColorArray[1,g_]		= 33;
// targColorArray[1,b_]		= 27;
				
// targColorArray[2,r_]		= 35;
// targColorArray[2,g_]		= 33;
// targColorArray[2,b_]		= 27;
						
// targColorArray[3,r_]		= 35;
// targColorArray[3,g_]		= 33;
// targColorArray[3,b_]		= 27;
				
// targColorArray[4,r_]		= 35;
// targColorArray[4,g_]		= 33;
// targColorArray[4,b_]		= 27;
						
// targColorArray[5,r_]		= 35;
// targColorArray[5,g_]		= 33;
// targColorArray[5,b_]		= 27;
						
// targColorArray[6,r_]		= 35;
// targColorArray[6,g_]		= 33;
// targColorArray[6,b_]		= 27;
						
// targColorArray[7,r_]		= 35;
// targColorArray[7,g_]		= 33;
// targColorArray[7,b_]		= 27;

			
targColorArray[0,r_]		= 40;	// targColor of each target individually
targColorArray[0,g_]		= 40;	// targColor of each target individually
targColorArray[0,b_]		= 40;	// targColor of each target individually
				
targColorArray[1,r_]		= 40;
targColorArray[1,g_]		= 40;
targColorArray[1,b_]		= 40;
				
targColorArray[2,r_]		= 40;
targColorArray[2,g_]		= 40;
targColorArray[2,b_]		= 40;
						
targColorArray[3,r_]		= 40;
targColorArray[3,g_]		= 40;
targColorArray[3,b_]		= 40;
				
targColorArray[4,r_]		= 40;
targColorArray[4,g_]		= 40;
targColorArray[4,b_]		= 40;
						
targColorArray[5,r_]		= 40;
targColorArray[5,g_]		= 40;
targColorArray[5,b_]		= 40;
						
targColorArray[6,r_]		= 40;
targColorArray[6,g_]		= 40;
targColorArray[6,b_]		= 40;
						
targColorArray[7,r_]		= 40;
targColorArray[7,g_]		= 40;
targColorArray[7,b_]		= 40;

sizeArray[0]			= 0.7;	// targSize of each target individually (degrees)
sizeArray[1]			= 0.7;
sizeArray[2]			= 0;
sizeArray[3]			= 0;
sizeArray[4]			= 0;
sizeArray[5]			= 0;
sizeArray[6]			= 0;
sizeArray[7]			= 0;

angleArray[0]			= 0;	// angle of each target individually (degrees)
angleArray[1]			= 180;
angleArray[2]			= 90;
angleArray[3]			= 135;
angleArray[4]			= 180;
angleArray[5]			= -135;
angleArray[6]			= -90;
angleArray[7]			= -45;

ampDefault		= 13;
ampArray[0]	= ampDefault;	// distance of each target from center of screen individually (degrees)
ampArray[1]	= ampDefault;
ampArray[2]	= ampDefault;
ampArray[3]	= ampDefault;
ampArray[4]	= ampDefault;
ampArray[5]	= ampDefault;
ampArray[6]	= ampDefault;
ampArray[7]	= ampDefault;

fixSize			= .5;	// targSize of the fixatoin point (degrees)	
fixAmp			= 0;
fixAngle 		= 0;

Set_tones = 1;

Success_Tone_bigR		= 800;	// positive secondary reinforcer in Hz (large reward)
Success_Tone_medR		= 1600;	// positive secondary reinforcer in Hz (medium reward)
Success_Tone_smlR		= 3200;	// positive secondary reinforcer in Hz (small reward)		
Failure_Tone_smlP		= 100;	// negative secondary reinforcer in Hz (short timeout)
Failure_Tone_medP		= 200;	// negative secondary reinforcer in Hz (medium timeout)
Failure_Tone_bigP		= 400;	// negative secondary reinforcer in Hz (long timeout)	
toneChoiceSuccess		= 3200;
toneChoiceFailure		= 800;
toneStopSuccess			= 1600;
toneStopFailure			= 200;
toneAbort 				= 1000;
toneTargHigh 			= 3800;
toneTargLow 			= 2600;
toneDistHigh 			= 200;
toneDistLow 			= 1400;



nTrialPerTarget 		= 20;
nTrialRemain 			= 6000; // initialize this to a really high number for protocols that don't depend on trial numbers (it gets reset for protocols that do)

nTrialArray[0] 			= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
nTrialArray[1] 			= 0;
nTrialArray[2] 			= 0;
nTrialArray[3] 			= 0;
nTrialArray[4] 			= 0;
nTrialArray[5] 			= 0;
nTrialArray[6] 			= 0;
nTrialArray[7] 			= 0;

//----------------------------------------------------------------------------------------------------------------
// May want target targSize to depend on its eccentricity. Create a flag for that condition and a conversion factor
AutoTargetSizeFlag		= 0;	// Default is for the user to set the target targSize.
TargetSizeConversion 	= 0.1;	// 1 degree target targSize per 10 degrees eccentricity

//----------------------------------------------------------------------------------------------------------------
// Eye related variables
fixWinSize			= 4.0;	// targSize of fixation window (degrees)
targWinSize			= 10;	// targSize of target window (degrees)
// chkrWinSize			= 3.2; //round(iSquareSizePixels * nCheckerColumn / Deg2Pix_X);	// targSize of checkered stimulus window (degrees)
chkrWinSize			= 2.5; //round(iSquareSizePixels * nCheckerColumn / Deg2Pix_X);	// targSize of checkered stimulus window (degrees)
betWinSize 		= round(targWinSize * .9);


//----------------------------------------------------------------------------------------------------------------
// Task timing paramaters (all times in ms unless otherwise specified)
allowFixTime			= 2500;	// subject has this long to acquire fixation before a new trial is initiated
expoJitterFlag			= 1;	// defines if exponential holdtime is used or if holdtime is sampled from rectanglular dist.
expoJitterFlag_soa		= 0;	// defines if exponential holdtime is used or if holdtime is sampled from rectanglular dist.
holdtimeMin				= 500;  // minimum time after fixation before target presentation
holdtimeMax				= 1500; // maximum time after fixation before target presentation
soa 					= 0;    // reset this every time protocols get loaded so it's zero for protocols that don't use it
soaMin					= 1150; //500	// minimum time between target onset and fixation offset (mem guided only)
soaMax					= 1350;	//1200 // maximum time between target onset and fixation offset (mem guided only)
saccTimeMax				= 1000;	// subject has this long to saccade to the target
saccDurationMax			= 75;	// once the eyes leave fixation they must be in the target before this time is up
targHoldtime			= 400; 	// after saccade subject must hold fixation at target for this long
Staircase				= 1;	// do we select the next SSD based on a staircasing algorithm?


holdStopDuration		= 1000; //round(saccTimeMax * .8);	// subject must hold fixation for this long on a stop trial to be deemed canceled
toneDuration			= 150;	// how long should the error and success tones be presented?
rewardDelay				= 500;	// how long after tone before juice is given (needed to seperate primary and secondary reinforcement)
basePunishDuration		= 1100;	// medium time out for messing up (monkeys care less for this one)
Max_move_ct				= 5;	// for training to be still with a motion detector
Bmove_tout				= 1000;	// for training to be still with a motion detector
TrainingStill			= 0;	// Indicates that we are using motion detector to train the monk to be still
Canc_alert				= 0;	// Alert operator that the monk has canceled a trial (during training)
fixedTrialDuration		= 0;	// 1 for fixed trial length, 0 for fixed inter trial intervals




	//--------------------------------------------------------------------------------------------------------------------
// Fixation task
if (state == stateFIX)
	{
	loadDefault				= 1;    // set load default back to 1 for the other tasks
	nTarg				= 9;	// number of target positions (this is calculated below based on user input)

	targColorArray[0,r_]		= 35;	// targColor of each target individually
	targColorArray[0,g_]		= 33;	// targColor of each target individually
	targColorArray[0,b_]		= 27;	// targColor of each target individually
							  
	targColorArray[1,r_]		= 35;
	targColorArray[1,g_]		= 33;
	targColorArray[1,b_]		= 27;
							  
	targColorArray[2,r_]		= 35;
	targColorArray[2,g_]		= 33;
	targColorArray[2,b_]		= 27;
							  
	targColorArray[3,r_]		= 35;
	targColorArray[3,g_]		= 33;
	targColorArray[3,b_]		= 27;
							  
	targColorArray[4,r_]		= 35;
	targColorArray[4,g_]		= 33;
	targColorArray[4,b_]		= 27;
							  
	targColorArray[5,r_]		= 35;
	targColorArray[5,g_]		= 33;
	targColorArray[5,b_]		= 27;
							  
	targColorArray[6,r_]		= 35;
	targColorArray[6,g_]		= 33;
	targColorArray[6,b_]		= 27;
							  
	targColorArray[7,r_]		= 35;
	targColorArray[7,g_]		= 33;
	targColorArray[7,b_]		= 27;
	
	targColorArray[8,r_]		= 35;
	targColorArray[8,g_]		= 33;
	targColorArray[8,b_]		= 27;
	
	sizeArray[0]			= 0.5;	// targSize of each target individually (degrees)
	sizeArray[1]			= 0.5;
	sizeArray[2]			= 0.5;
	sizeArray[3]			= 0.5;
	sizeArray[4]			= 0.5;
	sizeArray[5]			= 0.5;
	sizeArray[6]			= 0.5;
	sizeArray[7]			= 0.5;
	sizeArray[8]			= 0.5;
	
	angleArray[0]			= 0;	// angle of each target individually (degrees)
	angleArray[1]			= 90;
	angleArray[2]			= -90;
	angleArray[3]			= 180;
	angleArray[4]			= 0;
	angleArray[5]			= 135;
	angleArray[6]			= 45;
	angleArray[7]			= -135;
	angleArray[8]			= -45;
	
	ampArray[0]	= 0.0;	// distance of each target from center of screen individually (degrees)
	ampArray[1]	= 11.0;
	ampArray[2]	= 11.0;
	ampArray[3]	= 11.0;
	ampArray[4]	= 11.0;
	ampArray[5]	= 15.6;
	ampArray[6]	= 15.6;
	ampArray[7]	= 15.6;
	ampArray[8]	= 15.6;
	
	fixWinSize			= 2.5;	// targSize of fixation window (degrees)
	targWinSize			= 0.0;	// targSize of target window (degrees)
	
	allowFixTime		= 1200;	// subject has this long to acquire fixation (or target fixation protocol) before a new trial is initiated
	saccTimeMax		= 800;	// subject has this long to saccade to the target
	targHoldtime			= 600; 	// after saccade subject must hold fixation at target for this long
	
	}




// AMPLITUDE TASK
if (state == stateAmp)
	{
	ampArray[0]		= 2.5; // amplitude of saccades to make during amplitude task
	ampArray[1]		= 5.0; 
	ampArray[2]		= 7.5; 
	ampArray[3]		= 10.0; 
	ampArray[4]		= 12.5; 
	ampArray[5]		= 15.0; 
	ampArray[6]		= 20.0; 
	ampArray[7]		= 25.0; 
	}












if (state == stateVIS ||
	state == stateAMP ||
	state == stateMEM ||
	state == stateCCM ||
	state == stateGNG ||
	state == stateMCM ||
	state == stateDEL)
	{
	fixedTrialDuration 	= 0;
	}
// else
	// {
	// fixedTrialDuration 	= 1;
	// }
trialDuration			= 2200; 	// fixed at this value (only works if fixedTrialDuration == 1) must figure out max time for this variable and include it in comments
interTrialDuration			= 1050;	// how long between trials (only works if fixedTrialDuration == 0)





// MEMORY/VISUAL/DELAYED SACCADE TASK SPECIFIC----------------------------------------------------------------------------
if (state == stateVIS)
	{	
	
	sizeArray[0]			= .5;	// targSize of each target individually (degrees)
	sizeArray[1]			= .5;
	sizeArray[2]			= .5;
	sizeArray[3]			= .5;
	sizeArray[4]			= .5;
	sizeArray[5]			= .5;
	sizeArray[6]			= .5;
	sizeArray[7]			= .5;
	
	angleArray[0]			= 0;	// angle of each target individually (degrees)
	angleArray[1]			= 45;
	angleArray[2]			= 90;
	angleArray[3]			= 135;
	angleArray[4]			= 180;
	angleArray[5]			= -135;
	angleArray[6]			= -90;
	angleArray[7]			= -45;
	
	}
	


// SIMPLE COUNTERMANDING TASK SPECIFIC----------------------------------------------------------------------------
if (state == stateCMD)
	{
	interTrialDuration			= 800;	// how long between trials (only works if fixedTrialDuration == 0)
	targHoldtime				= 400;
	
	targetRightRate = .5;
	
	ssdArray[0]				= 3;	// needs to be in vertical retrace units
	ssdArray[1]				= 6;
	ssdArray[2]				= 9;
	ssdArray[3]				= 12;
	ssdArray[4]				= 15;
	ssdArray[5]				= 18;
	ssdArray[6]				= 21;
	ssdArray[7]				= 24;
	ssdArray[8]				= 27;
	ssdArray[9]				= 30;
	ssdArray[10]			= 33;
	ssdArray[11]			= 36;
	
	
	ampArray[0]	= 5;	// If varying the eccentricity of the targets
	ampArray[1]	= 10;   // If want more eccentricities, add them here and increase the random number generator in SETTRIAL.pro
	ampArray[2]	= 15;
	ampArray[3]	= 20;
	
	lastStopArray[0]  		= success;   // initialize to "success", will staircase SSD based on these array data
	lastStopArray[1]  		= success;
	lastStopArray[2]  		= success;
	lastStopArray[3]  		= success;

	decideSSDArray[0] 		= -1;  // initialize to -1 (see decideSSD variable)
	decideSSDArray[1] 		= -1; 
	decideSSDArray[2] 		= -1; 
	decideSSDArray[3] 		= -1; 
	}






//----------------------------------------------------------------------------------------------------------------
// CHOICE_CM (choice countermanding) task

if (state == stateCCM)
	{
	holdtimeMin				= 500;  // minimum time after fixation before target presentation
	holdtimeMax				= 1200; // maximum time after fixation before target presentation

	nCheckerColumn = 10;
	nCheckerRow = nCheckerColumn;
	nSquare = nCheckerColumn * nCheckerRow;
	if (checkerIsTarg == 0)
		{
		checkerAmp = 4;
		checkerAngle = 90;
		}
	else if (checkerIsTarg == 1)
		{
		checkerAmp = ampDefault;
		checkerAngle 		= angleArray[0]; 
		checkerTargRate 	= .5;
		chkrWinSize 		= 0;
		}
		
	iSquareSizePixels = 2;
	targetRightRate = .5;
	fiftyPercentRate = .5; // How often to run 50% checkered stimulus RELATIVE TO ITS ALREADY RANDOM CHANCE AMONG THE OTHER TRIAL PROPORTIONS
	targ1ExtraPct = 0;  // Percent of theb base reward time to add for the right target
	targ2ExtraPct = 0; // and for the left target

	ssdArray[0]				= 6;	// needs to be in vertical retrace units
	ssdArray[1]				= 9;
	ssdArray[2]				= 12;
	ssdArray[3]				= 15;
	ssdArray[4]				= 18;
	ssdArray[5]				= 21;
	ssdArray[6]				= 24;
	ssdArray[7]				= 27;
	ssdArray[8]				= 30;
	ssdArray[9]				= 33;
	ssdArray[10]			= 0;
	ssdArray[11]			= 0;


	targ1PropArray[0] = .41;
	targ1PropArray[1] = .45;
	targ1PropArray[2] = .48;
	targ1PropArray[3] = .50;
	targ1PropArray[4] = .52;
	targ1PropArray[5] = 0.55;
	targ1PropArray[6] = 0.59;
	targ1PropArray[7] = 0.0;
	targ1PropArray[8] = 0.0;
	targ1PropArray[9] = 0.0;
	
	// targ1PropArray[0] = 0.35;
	// targ1PropArray[1] = 0.42;
	// targ1PropArray[2] = 0.47;
	// targ1PropArray[3] = 0.5;
	// targ1PropArray[4] = 0.53;
	// targ1PropArray[5] = 0.58;
	// targ1PropArray[6] = 0.65;
	// targ1PropArray[7] = 0.0;
	// targ1PropArray[8] = 0.0;
	// targ1PropArray[9] = 0.0;

	// targ1PropArray[0] = 0.0;
	// targ1PropArray[1] = 1.0;
	// targ1PropArray[2] = 0.0;
	// targ1PropArray[3] = 0.0;
	// targ1PropArray[4] = 0.0;
	// targ1PropArray[5] = 0.0;
	// targ1PropArray[6] = 0.0;
	// targ1PropArray[7] = 0.0;
	// targ1PropArray[8] = 0.0;
	// targ1PropArray[9] = 0.0;


	
	trialDist[0] = 1.0; 	// Set these values relative to 1.0 to determine the relative rate of each trial type
	trialDist[1] = 1.0;
	trialDist[2] = 1.0;
	trialDist[3] = 1.0;
	trialDist[4] = 1.0;
	trialDist[5] = 1.0;
	trialDist[6] = 1.0;
	trialDist[7] = 0.0;
	trialDist[8] = 0.0;
	trialDist[9] = 0.0;
	

	// Red is Right
	// Targ1SquareColor[r_]		= 54;	
	// Targ1SquareColor[g_]		= 0;	
	// Targ1SquareColor[b_]		= 54;	
	
	// Targ2SquareColor[r_]	= 0;	
	// Targ2SquareColor[g_]	= 30;	
	// Targ2SquareColor[b_]	= 30;	

	// Blue is Right
	Targ1SquareColor[r_]		= 0;	
	Targ1SquareColor[g_]		= 30;	
	Targ1SquareColor[b_]		= 30;	
	
	Targ2SquareColor[r_]	= 54;	
	Targ2SquareColor[g_]	= 0;	
	Targ2SquareColor[b_]	= 54;	


	
	lastStopArray[0]  		= success;   // initialize to "success"
	lastStopArray[1]  		= success;
	lastStopArray[2]  		= success;
	lastStopArray[3]  		= success;
	lastStopArray[4]  		= success;
	lastStopArray[5]  		= success;
	lastStopArray[6]  		= success;
	lastStopArray[7]  		= success;
	lastStopArray[8]  		= success;
	lastStopArray[9]  		= success;
	
	decideSSDArray[0] 		= -1;  // initialize to -1 (see decideSSD variable)
	decideSSDArray[1] 		= -1; 
	decideSSDArray[2] 		= -1; 
	decideSSDArray[3] 		= -1; 
	decideSSDArray[4] 		= -1; 
	decideSSDArray[5] 		= -1; 
	decideSSDArray[6] 		= -1; 
	decideSSDArray[7] 		= -1; 
	decideSSDArray[8] 		= -1; 
	decideSSDArray[9] 		= -1; 

	soaMin					= 400; //500	// minimum time between checker onset and fixation offset (delay version)
	soaMax					= 1400;	//1200 // maximum time 

	}




// GO NO-GO SACCADE TASK SPECIFIC----------------------------------------------------------------------------
if (state == stateGNG)
	{
	staircase = 0;
	nCheckerColumn = 10;
	nCheckerRow = 10;
	nSquare = nCheckerColumn * nCheckerRow;
	checkerAmp = 0;
	checkerAngle = 90;	
	iSquareSizePixels = 1;
	
	targetRightRate = .5;
	fiftyPercentRate = .5; // How often to run 50% checkered stimulus RELATIVE TO ITS ALREADY RANDOM CHANCE AMONG THE OTHER TRIAL PROPORTIONS

	//----------------------------------------------------------------------------------------------------------------
	// Checkered stimulus properties for GONOGO.pro (go/no-go) task

	 // goPropArray[0] = 0;
	 // goPropArray[1] = 1;
	 // goPropArray[2] = 0;
	 // goPropArray[3] = 0;
	 // goPropArray[4] = 0;
	 // goPropArray[5] = 0;
	 // goPropArray[6] = 0;
	 // goPropArray[7] = 0;
	 // goPropArray[8] = 0.0;
	 // goPropArray[9] = 0.0;
	goPropArray[0] = 0.15;
	goPropArray[1] = 0.35;
	goPropArray[2] = 0.45;
	goPropArray[3] = 0.50;
	goPropArray[4] = 0.55;
	goPropArray[5] = 0.65;
	goPropArray[6] = 0.85;
	goPropArray[7] = 0.0;
	goPropArray[8] = 0.0;
	goPropArray[9] = 0.0;

	
	GoSquareColor[r_]		= 0;	
	GoSquareColor[g_]		= 55;	
	GoSquareColor[b_]		= 0;	
	
	NoGoSquareColor[r_]	= 72;	
	NoGoSquareColor[g_]	= 42;	
	NoGoSquareColor[b_]	= 0;	
	}







// METACOG SACCADE TASKS SPECIFIC----------------------------------------------------------------------------
if (state == stateMCM)
	{
	fixWinSize			= 4.0;	// targSize of fixation window (degrees)
	targWinSize			= 10;	// targSize of target window (degrees)

	// Trial type distributions (may want to mix up the proportions of eachtrial type)
	maskPct 			= 25;
	betPct				= 0;
	retroPct			= 75;
	proPct 				= 0;
	
	
	highBetRightRate 	= .5;				// proportion of trials when high bet target appears in right hemifield
	targetRightRate 	= .5;				// proportion of trials when high bet target appears in right hemifield
	fakeCorrectRate		= .5;
	
	maskAngleArray[0]	= -30;
	maskAngleArray[1]	= 30;
	maskAngleArray[2]	= 150;
	maskAngleArray[3]	= -150;

	maskAmpArray[0]	= ampDefault;
	maskAmpArray[1]	= ampDefault;
	maskAmpArray[2]	= ampDefault;
	maskAmpArray[3]	= ampDefault;

	maskSize 			= 1.5;
	betSize				= 1.5;
	targSize 			= .5;
	
	
	i = 0;
	while (i < 9)
		{
		// targColorArray[i, r_] = 8;			
		// targColorArray[i, g_] = 0;
		// targColorArray[i, b_] = 2;
		targColorArray[i, r_] = 12;			
		targColorArray[i, g_] = 0;
		targColorArray[i, b_] = 3;
		targColorArray[i, r_] = 9;			
		targColorArray[i, g_] = 0;
		targColorArray[i, b_] = 3;
		i = i + 1;
		}	

	maskColorArray[r_] = 40;			// GLOBAL ALERT; fixColor is an array so it cannot be passed
	maskColorArray[g_] = 40;
	maskColorArray[b_] = 40;

	highBetColorArray[r_] = 50;			// Need to make these isoluminant
	highBetColorArray[g_] = 0;
	highBetColorArray[b_] = 0;

	lowBetColorArray[r_] = 0;		// Need to make these isoluminant
	lowBetColorArray[g_] = 0;
	lowBetColorArray[b_] = 100;

	betFixColorArray[r_] = 0;		// Need to make these isoluminant
	betFixColorArray[g_] = 40;
	betFixColorArray[b_] = 40;

	proFixColorArray[r_] = 40;		// Need to make these isoluminant
	proFixColorArray[g_] = 40;
	proFixColorArray[b_] = 0;

	staircase = 1;
	// soaArray[0]				= 1;	// in screen refresh units
	// soaArray[1]				= 2;
	// soaArray[2]				= 3;
	// soaArray[3]				= 4;
	// soaArray[4]				= 5;
	// soaArray[5]				= 6;
	// soaArray[6]				= 7;
	// soaArray[7]				= 8;
	// soaArray[8]				= 9;
	// soaArray[9]				= 10;
	soaArray[0]				= 3;	// in screen refresh units
	soaArray[1]				= 5;
	soaArray[2]				= 7;
	soaArray[3]				= 9;
	soaArray[4]				= 11;
	soaArray[5]				= 13;
	soaArray[6]				= 15;
	soaArray[7]				= 17;
	soaArray[8]				= 19;
	soaArray[9]				= 21;
	}
	






	
	
	
	
	
	
	

	
	
	
	
	
// ************************************************************************************
// ************************************************************************************
// BROCA
// ************************************************************************************
// ************************************************************************************
if(monkey == broca)
	{		
	
	// GENERAL ACROSS ALL TASKS---------------------------------------------------------------------------------------
	// distance from center of subjects eyeball to screen
	if(room == 28)
		{
		subjDist	= 475.0; 				
		}
	else if (room == 29)
		{
		subjDist	= 465.0;
		}
	// else if (room == 23)
		// {
		// }
		
	Set_tones = 1;
	
	// fixWinSize			= 4;
	// targWinSize			= 6;	
	
	// allowFixTime		= 1000;
	// saccTimeMax		= 1200;
	basePunishDuration		= 1100;
	
	// Task-specific rewards:
	if (state == stateFIX ||
		state == stateVIS ||
		state == stateAMP)
		{
		baseRewardDuration = 30;
		}
	else if (state == stateMEM)
		{
		baseRewardDuration = 40;
		}
	else if (state == stateDEL)
		{
		baseRewardDuration = 40;
		}
	else if (state == stateCMD)
		{
		baseRewardDuration = 50;
		}
	else if (state == stateCCM)
		{
		baseRewardDuration = 75;
		}
	else if (state == stateGNG)    // monkey can complete these trials quicker, so they should earn less reward per trial (than countermanding or choice countermanding)
		{
		baseRewardDuration = 50;
		}
	else if (state == stateMCM)    // monkey can complete these trials quicker, so they should earn less reward per trial (than countermanding or choice countermanding)
		{
		baseRewardDuration = 60;
		}

	
// MEMORY/VISUAL/DELAYED SACCADE TASK SPECIFIC----------------------------------------------------------------------------
if (state == stateMEM ||
	state == stateDEL)
	{	
	targDuration 			= 10;    // number of screen refreshes to wait before turning target off in memory-guided saccade task
	soaMin = 500;//500
	soaMax = 1500;//2000
	
	// sizeArray[0]			= .5;	// targSize of each target individually (degrees)
	// sizeArray[1]			= .5;
	// sizeArray[2]			= .5;
	// sizeArray[3]			= .5;
	// sizeArray[4]			= .5;
	// sizeArray[5]			= .5;
	// sizeArray[6]			= .5;
	// sizeArray[7]			= .5;
	
	// angleArray[0]			= 0;	// angle of each target individually (degrees)
	// angleArray[1]			= 45;
	// angleArray[2]			= 90;
	// angleArray[3]			= 135;
	// angleArray[4]			= 180;
	// angleArray[5]			= -135;
	// angleArray[6]			= -90;
	// angleArray[7]			= -45;
	
	
	sizeArray[0]			= .5;	// targSize of each target individually (degrees)
	sizeArray[1]			= .5;
	angleArray[0]			= 0;	// angle of each target individually (degrees)
	angleArray[1]			= 180;

	}
	//----------------------------------------------------------------------------------------------------------------
	// Trial type distributions (MUST SUM TO 100)
	if (state == stateCMD)
		{
		goPct				= 65.0;
		stopPct				= 35.0;
		ignorePct			= 0;
		}
	else if (state == stateCCM)
		{
		goPct				= 58.0;
		stopPct				= 42;
		// goPct				= 100;
		// stopPct				= 0;
		ignorePct			= 0;
		}
	else if (state == stateGNG)
		{
		goPct				= 50.0;
		NogoPct				= 50.0;
		}
	
	// STOP SIGNAL TASK SPECIFIC--------------------------------------------------------------------------------------
	if (state == stateCMD)
		{
		// goPct				= 25.0;
		// stopPct				= 50.0;
		// ignorePct			= 25.0;
		
		// stopColorArray[r_]		= 0;	
		// stopColorArray[g_]		= 36;	
		// stopColorArray[b_]		= 0;					
				
		// ignoreColorArray[r_]	= 63;	
		// ignoreColorArray[g_]	= 0;	
		// ignoreColorArray[b_]	= 0;
		
		ssdArray[0]				= 3;	// needs to be in vertical retrace units
		ssdArray[1]				= 6;
		ssdArray[2]				= 9;
		ssdArray[3]				= 12;
		ssdArray[4]				= 20;
		ssdArray[5]				= 23;
		ssdArray[6]				= 26;
		ssdArray[7]				= 29;
		ssdArray[8]				= 32;
		ssdArray[9]				= 35;
		ssdArray[10]			= 38;
		ssdArray[11]			= 41;
		}
		
		
	// MEMORY GUIDED SACCADE TASK SPECIFIC----------------------------------------------------------------------------
	// if (state == stateMEM)
		// {			
		// }
	
	// CHOICE COUNTERMANDING TASK SPECIFIC----------------------------------------------------------------------------
	if (state == stateCCM)
		{
		targetRightRate = .5;
		fiftyPercentRate = .8 * 4 / 7; // How often to run 50% checkered stimulus RELATIVE TO ITS ALREADY RANDOM CHANCE AMONG THE OTHER TRIAL PROPORTIONS
		targ1ExtraPct = 0;  // Percent of theb base reward time to add for the right target
		targ2ExtraPct = 0; // and for the left target
		checkerIsTarg = 0;
		basePunishDuration		= 1200;
		
		// ssdArray[0]				= 3;	// needs to be in vertical retrace units
		// ssdArray[1]				= 7;
		// ssdArray[2]				= 11;
		// ssdArray[3]				= 15;
		// ssdArray[4]				= 19;
		// ssdArray[5]				= 23;
		// ssdArray[6]				= 27;
		// ssdArray[7]				= 31;
		// ssdArray[8]				= 35;
		// ssdArray[9]				= 39;
		// ssdArray[10]			= 43;
		// ssdArray[11]			= 47;
		
		// ssdArray[0]				= 4;	// needs to be in vertical retrace units
		// ssdArray[1]				= 12;
		// ssdArray[2]				= 20;
		// ssdArray[3]				= 28;
		// ssdArray[4]				= 36;
		// ssdArray[5]				= 44;
		// ssdArray[6]				= 52;
		// ssdArray[7]				= 60;
		// ssdArray[8]				= 61;
		// ssdArray[9]				= 62;
		// ssdArray[10]			= 63;
		// ssdArray[11]			= 64;

		ssdArray[0]				= 7;	// needs to be in vertical retrace units
		ssdArray[1]				= 17;
		ssdArray[2]				= 27;
		ssdArray[3]				= 37;
		ssdArray[4]				= 47;
		ssdArray[5]				= 57;
		ssdArray[6]				= 0;
		ssdArray[7]				= 0;
		ssdArray[8]				= 0;
		ssdArray[9]				= 0;
		ssdArray[10]			= 0;
		ssdArray[11]			= 0;



		


		// targ1PropArray[0] = .43;
		// targ1PropArray[1] = .45;
		// targ1PropArray[2] = .47;
		// targ1PropArray[3] = .53;
		// targ1PropArray[4] = .55;
		// targ1PropArray[5] = .57;
		// targ1PropArray[6] = 0.0;
		// targ1PropArray[7] = 0.0;
		// targ1PropArray[8] = 0.0;
		// targ1PropArray[9] = 0.0;

		// targ1PropArray[0] = .35;
		// targ1PropArray[1] = .42;
		// targ1PropArray[2] = .47;
		// targ1PropArray[3] = .53;
		// targ1PropArray[4] = .58;
		// targ1PropArray[5] = .65;
		// targ1PropArray[6] = 0.0;
		// targ1PropArray[7] = 0.0;
		// targ1PropArray[8] = 0.0;
		// targ1PropArray[9] = 0.0;

		targ1PropArray[0] = .42;
		targ1PropArray[1] = .47;
		targ1PropArray[2] = .53;
		targ1PropArray[3] = .58;
		targ1PropArray[4] = 0.0;
		targ1PropArray[5] = 0.0;
		targ1PropArray[6] = 0.0;
		targ1PropArray[7] = 0.0;
		targ1PropArray[8] = 0.0;
		targ1PropArray[9] = 0.0;

		
		// trialDist[0] = 1.0; 	// Set these values relative to 1.0 to determine the relative rate of each trial type
		// trialDist[1] = 1.0;
		// trialDist[2] = 1.0;
		// trialDist[3] = 1.0;
		// trialDist[4] = 1.0;
		// trialDist[5] = 1.0;
		// trialDist[6] = 0.0;
		// trialDist[7] = 0.0;
		// trialDist[8] = 0.0;
		// trialDist[9] = 0.0;

		trialDist[0] = 1.0; 	// Set these values relative to 1.0 to determine the relative rate of each trial type
		trialDist[1] = 1.0;
		trialDist[2] = 1.0;
		trialDist[3] = 1.0;
		trialDist[4] = 0.0;
		trialDist[5] = 0.0;
		trialDist[6] = 0.0;
		trialDist[7] = 0.0;
		trialDist[8] = 0.0;
		trialDist[9] = 0.0;
		
		// trialDist[0] = 1.0; 	// Set these values relative to 1.0 to determine the relative rate of each trial type
		// trialDist[1] = 1.0;
		// trialDist[2] = 0;
		// trialDist[3] = 0;
		// trialDist[4] = 0;
		// trialDist[5] = 0;
		// trialDist[6] = 0.0;
		// trialDist[7] = 0.0;
		// trialDist[8] = 0.0;
		// trialDist[9] = 0.0;

	// Red is Right
		Targ1SquareColor[r_]		= 54;	// Isoluminant cyan/magenta at 30 cd/m^2  (29.7 to be more precise)
		Targ1SquareColor[g_]		= 0;	
		Targ1SquareColor[b_]		= 54;	
		
		Targ2SquareColor[r_]	= 0;	
		Targ2SquareColor[g_]	= 31;	
		Targ2SquareColor[b_]	= 31;	


		// Red is Right
		// Targ1SquareColor[r_]		= 20;	// Isoluminant cyan/magenta at 12 cd/m^2 
		// Targ1SquareColor[g_]		= 0;	
		// Targ1SquareColor[b_]		= 20;	
		
		// Targ2SquareColor[r_]	= 0;	
		// Targ2SquareColor[g_]	= 12;	
		// Targ2SquareColor[b_]	= 12;	

		// Red is Right: Further reduce discriminability by reducing pure cynan/magenta composition of each checker:
		// red goes 19 - 0, green goes 0 - 12, blue goes 12 to 12... assume 20 steps from min to max
		// isoluminant at 13 cd/m^2
		// Targ1SquareColor[r_]		= 20;	// full red
		// Targ1SquareColor[g_]		= 8;	// green * 13steps / 20 = 7.8
		// Targ1SquareColor[b_]		= 12;	// full blue 
		
		// Targ2SquareColor[r_]	= 7;	// red * 7steps / 20 = 6.7
		// Targ2SquareColor[g_]	= 12;	// full green 
		// Targ2SquareColor[b_]	= 12;	// full blue
		
		soaMin = 400;
		soaMax = 1000;
		
		}

	}   // BROCA Section
	
	
	
	
	
		
	
	
	
	
	
// ************************************************************************************
// ************************************************************************************
// CAJAL
// ************************************************************************************
// ************************************************************************************
if(monkey == cajal)
	{		
	
	fixwinsize =4;
	
	// allowFixTime		= 1000;
	// saccTimeMax		= 1200;
holdtimeMin				= 500;  // minimum time after fixation before target presentation
holdtimeMax				= 1500; // maximum time after fixation before target presentation
	basePunishDuration		= 1100;
	
	// Task-specific rewards:
	if (state == stateFIX ||
		state == stateVIS ||
		state == stateAMP)
		{
		baseRewardDuration = 40;
		}
	else if (state == stateMEM)
		{
		baseRewardDuration = 55;
		}
	else if (state == stateDEL)
		{
		baseRewardDuration = 55;
		}
	else if (state == stateCMD)
		{
		baseRewardDuration = 80;
		}
	else if (state == stateCCM)
		{
		baseRewardDuration = 100;
		}
	else if (state == stateGNG)    // monkey can complete these trials quicker, so they should earn less reward per trial (than countermanding or choice countermanding)
		{
		baseRewardDuration = 80;
		}
	else if (state == stateMCM)    // monkey can complete these trials quicker, so they should earn less reward per trial (than countermanding or choice countermanding)
		{
		baseRewardDuration = 80;
		}

	

	// MEMORY/VISUAL/DELAYED SACCADE TASK SPECIFIC----------------------------------------------------------------------------
	if (state == stateMEM ||
		state == stateDEL)
		{	
		targDuration 			= 10;    // number of screen refreshes to wait before turning target off in memory-guided saccade task
		soaMin = 500;//500
		soaMax = 1500;//2000
		
		sizeArray[0]			= .5;	// targSize of each target individually (degrees)
		sizeArray[1]			= .5;
		sizeArray[2]			= .5;
		sizeArray[3]			= .5;
		sizeArray[4]			= .5;
		sizeArray[5]			= .5;
		sizeArray[6]			= .5;
		sizeArray[7]			= .5;
		
		angleArray[0]			= 0;	// angle of each target individually (degrees)
		angleArray[1]			= 45;
		angleArray[2]			= 90;
		angleArray[3]			= 135;
		angleArray[4]			= 180;
		angleArray[5]			= -135;
		angleArray[6]			= -90;
		angleArray[7]			= -45;
		
		// sizeArray[0]			= .5;	// targSize of each target individually (degrees)
		// sizeArray[1]			= .5;
		// angleArray[0]			= 0;	// angle of each target individually (degrees)
		// angleArray[1]			= 180;

		}
		

	if (state == stateMEM)
		{
		targwinSize = 9;
		}

		
		
		
	// CHOICE COUNTERMANDING TASK SPECIFIC----------------------------------------------------------------------------
	if (state == stateCCM)
		{
		checkerAmp = 4;

		targetRightRate = .5;
		fiftyPercentRate = .8 * 4 / 7; // How often to run 50% checkered stimulus RELATIVE TO ITS ALREADY RANDOM CHANCE AMONG THE OTHER TRIAL PROPORTIONS
		targ1ExtraPct = 0;  // Percent of theb base reward time to add for the right target
		targ2ExtraPct = 0; // and for the left target
		checkerIsTarg = 0;
		basePunishDuration		= 700;
		
		// ssdArray[0]				= 3;	// needs to be in vertical retrace units
		// ssdArray[1]				= 7;
		// ssdArray[2]				= 11;
		// ssdArray[3]				= 15;
		// ssdArray[4]				= 19;
		// ssdArray[5]				= 23;
		// ssdArray[6]				= 27;
		// ssdArray[7]				= 31;
		// ssdArray[8]				= 35;
		// ssdArray[9]				= 39;
		// ssdArray[10]			= 43;
		// ssdArray[11]			= 47;
		

		ssdArray[0]				= 7;	// needs to be in vertical retrace units
		ssdArray[1]				= 17;
		ssdArray[2]				= 27;
		ssdArray[3]				= 37;
		ssdArray[4]				= 47;
		ssdArray[5]				= 0;
		ssdArray[6]				= 0;
		ssdArray[7]				= 0;
		ssdArray[8]				= 0;
		ssdArray[9]				= 0;
		ssdArray[10]			= 0;
		ssdArray[11]			= 0;


		// targ1PropArray[0] = 0.40;
		// targ1PropArray[1] = .43;
		// targ1PropArray[2] = .47;
		// targ1PropArray[3] = .53;
		// targ1PropArray[4] = 0.57;
		// targ1PropArray[5] = 0.60;
		// targ1PropArray[6] = 0.0;
		// targ1PropArray[7] = 0.0;
		// targ1PropArray[8] = 0.0;
		// targ1PropArray[9] = 0.0;

		// targ1PropArray[0] = 0.1;
		// targ1PropArray[1] = .3;
		// targ1PropArray[2] = .7;
		// targ1PropArray[3] = .9;
		// targ1PropArray[4] = 0.0;
		// targ1PropArray[5] = 0.0;
		// targ1PropArray[6] = 0.0;
		// targ1PropArray[7] = 0.0;
		// targ1PropArray[8] = 0.0;
		// targ1PropArray[9] = 0.0;

		targ1PropArray[0] = 0.1;
		targ1PropArray[1] = .9;
		targ1PropArray[2] = 0;
		targ1PropArray[3] = 0;
		targ1PropArray[4] = 0.0;
		targ1PropArray[5] = 0.0;
		targ1PropArray[6] = 0.0;
		targ1PropArray[7] = 0.0;
		targ1PropArray[8] = 0.0;
		targ1PropArray[9] = 0.0;

		
		// trialDist[0] = 1.0; 	// Set these values relative to 1.0 to determine the relative rate of each trial type
		// trialDist[1] = 1.2;
		// trialDist[2] = 1.4;
		// trialDist[3] = 1.4;
		// trialDist[4] = 1.2;
		// trialDist[5] = 1.0;
		// trialDist[6] = 0.0;
		// trialDist[7] = 0.0;
		// trialDist[8] = 0.0;
		// trialDist[9] = 0.0;

		// trialDist[0] = 1.0; 	// Set these values relative to 1.0 to determine the relative rate of each trial type
		// trialDist[1] = 1.2;
		// trialDist[2] = 1.2;
		// trialDist[3] = 1.0;
		// trialDist[4] = 0.0;
		// trialDist[5] = 0.0;
		// trialDist[6] = 0.0;
		// trialDist[7] = 0.0;
		// trialDist[8] = 0.0;
		// trialDist[9] = 0.0;

		trialDist[0] = 1.0; 	// Set these values relative to 1.0 to determine the relative rate of each trial type
		trialDist[1] = 1.0;
		trialDist[2] = 0;
		trialDist[3] = 0;
		trialDist[4] = 0.0;
		trialDist[5] = 0.0;
		trialDist[6] = 0.0;
		trialDist[7] = 0.0;
		trialDist[8] = 0.0;
		trialDist[9] = 0.0;


		
		// Right is for Right target		
		Targ1SquareColor[r_]	= 43;	
		Targ1SquareColor[g_]	= 18;	
		Targ1SquareColor[b_]	= 27;	

		Targ2SquareColor[r_]		= 11;
		Targ2SquareColor[g_]		= 18;	
		Targ2SquareColor[b_]		= 18;	

		soaMin = 400;
		soaMax = 1000;

		}

		
	// Task-specific rewards:
	if (state == stateVWM)
		{
		
		allowFixTime = 3000;
		fixwinsize = 5;
		targwinsize = 8;
		baseRewardDuration = 100;
		nTrialPerTarget 		= 20;
		nTrialRemain 			= 6000; // initialize this to a really high number for protocols that don't depend on trial numbers (it gets reset for protocols that do)

		//setsize setup
		setSizeArray[0] 			= 1;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[1] 			= 1;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[2] 			= 2;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[3] 			= 2;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[4] 			= 3;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[5] 			= 3;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[6] 			= 4;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[7] 			= 4;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[8] 			= 5;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[9] 			= 5;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[10] 			= 6;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[11] 			= 6;   // These get reset to zero each time so new tasks start at zero trials per location.

		//samediff set up!
		sameDiffArray[0] 				= 1;   // These get reset to zero each time so new tasks start at zero trials per location.
		sameDiffArray[1] 				= 2;
		sameDiffArray[2] 				= 1;
		sameDiffArray[3] 				= 2;
		sameDiffArray[4] 				= 1;
		sameDiffArray[5] 				= 2;
		sameDiffArray[6] 				= 1;
		sameDiffArray[7] 				= 2;
		sameDiffArray[8] 				= 1;   // These get reset to zero each time so new tasks start at zero trials per location.
		sameDiffArray[9] 				= 2;
		sameDiffArray[10] 			= 1;
		sameDiffArray[11] 			= 2;		
		
		
		//counter set up!
		nTrialsArray[0] 				= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		nTrialsArray[1] 				= 0;
		nTrialsArray[2] 				= 0;
		nTrialsArray[3] 				= 0;
		nTrialsArray[4] 				= 0;
		nTrialsArray[5] 				= 0;
		nTrialsArray[6] 				= 0;
		nTrialsArray[7] 				= 0;
		nTrialsArray[8] 				= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		nTrialsArray[9] 				= 0;
		nTrialsArray[10] 			= 0;
		nTrialsArray[11] 			= 0;	
		//COLOR set up! [r,g,bl,m,w,cy,br,yl,bk]
		vwmColorArray[0,r_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[0,g_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[0,b_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		
		vwmColorArray[1,r_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[1,g_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[1,b_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		
		vwmColorArray[2,r_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[2,g_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[2,b_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		
		vwmColorArray[3,r_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[3,g_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[3,b_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		
		vwmColorArray[4,r_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[4,g_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[4,b_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		
		vwmColorArray[5,r_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[5,g_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[5,b_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		
		vwmColorArray[6,r_] 		= 42;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[6,g_] 		= 21;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[6,b_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		
		vwmColorArray[7,r_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[7,g_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
	    vwmColorArray[7,b_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		
		vwmColorArray[8,r_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[8,g_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
	    vwmColorArray[8,b_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		
		vwmAngleArray[0]			= 225.0;//45.0	// 0// angle of each target individually (degrees)
		vwmAngleArray[1]			= 315.0;//135.0   //45
		vwmAngleArray[2]			= 225.0;   //90
		vwmAngleArray[3]			= 315.0;  //135
		// vwmAngleArray[4]			= 0;  //180
		// vwmAngleArray[5]			= 0; //-135
		// vwmAngleArray[6]			= 0;  //-90
		// vwmAngleArray[7]			= 0;  //-45
		
		//original 8locs
		// vwmAngleArray[0]			= 22.5;	// 0// angle of each target individually (degrees)
		// vwmAngleArray[1]			= 67.5;   //45
		// vwmAngleArray[2]			= 112.5;   //90
		// vwmAngleArray[3]			= 157.5;  //135
		// vwmAngleArray[4]			= -157.5;  //180
		// vwmAngleArray[5]			= -112.5; //-135
		// vwmAngleArray[6]			= -67.5;  //-90
		// vwmAngleArray[7]			= -22.5;  //-45
		
		// vwmAngleArray[0]			= 67.5;	// 0// angle of each target individually (degrees)
		// vwmAngleArray[1]			= 67.5;   //45
		// vwmAngleArray[2]			= 67.5;   //90
		// vwmAngleArray[3]			= 67.5;  //135
		// vwmAngleArray[4]			= 67.5;  //180
		// vwmAngleArray[5]			= 22.5; //-135
		// vwmAngleArray[6]			= 67.5;  //-90
		// vwmAngleArray[7]			= 157.5;  //-45
		
		// vwmAngleArray[0]			= 22.5;	// 0// angle of each target individually (degrees)
		// vwmAngleArray[1]			= 67.5;   //45
		// vwmAngleArray[2]			= 67.5;   //90
		// vwmAngleArray[3]			= 67.5;  //135
		// vwmAngleArray[4]			= -157.5;  //180
		// vwmAngleArray[5]			= -112.5; //-135
		// vwmAngleArray[6]			= -112.5;  //-90
		// vwmAngleArray[7]			= -112.5;  //-45
		
		// vwmAngleArray[0]			= 67.5;	// 0// angle of each target individually (degrees)
		// vwmAngleArray[1]			= 67.5;   //45
		// vwmAngleArray[2]			= 67.5;   //90
		// vwmAngleArray[3]			= 67.5;  //135
		// vwmAngleArray[4]			= -112.5;  //180
		// vwmAngleArray[5]			= -112.5; //-135
		// vwmAngleArray[6]			= -112.5;  //-90
		// vwmAngleArray[7]			= -112.5;  //-45
		
		// vwmAngleArray[0]			= 90;	// 0// angle of each target individually (degrees)
		// vwmAngleArray[1]			= 90;   //45
		// vwmAngleArray[2]			= 90;   //90
		// vwmAngleArray[3]			= 90;  //135
		// vwmAngleArray[4]			= 90;  //180
		// vwmAngleArray[5]			= 90; //-135
		// vwmAngleArray[6]			= 90;  //-90
		// vwmAngleArray[7]			= 90;  //-45
		
		// vwmAngleArray[0]			= 0;	// 0// angle of each target individually (degrees)
		// vwmAngleArray[1]			= 45;   //45
		// vwmAngleArray[2]			= 90;   //90
		// vwmAngleArray[3]			= 135;  //135
		// vwmAngleArray[4]			= 180;  //180
		// vwmAngleArray[5]			= -135; //-135
		// vwmAngleArray[6]			= -90;  //-90
		// vwmAngleArray[7]			= -45;  //-45
		
		//for removing rightward bias...
		// vwmAngleArray[0]			= 90;	// 0// angle of each target individually (degrees)
		// vwmAngleArray[1]			= 45;   //45
		// vwmAngleArray[2]			= 0;   //90
		// vwmAngleArray[3]			= -45;  //135
		// vwmAngleArray[4]			= -90;  //180
		// vwmAngleArray[5]			= -45; //-135
		// vwmAngleArray[6]			= 0;  //-90
		// vwmAngleArray[7]			= 45;  //-45
	
		
		}
		}
// ************************************************************************************
// ************************************************************************************
// EULER
// ************************************************************************************
// ************************************************************************************
if(monkey == euler)
	{		
	
	fixwinsize =4;
	
	// allowFixTime		= 1000;
	// saccTimeMax		= 1200;
holdtimeMin				= 500;  // minimum time after fixation before target presentation
holdtimeMax				= 1500; // maximum time after fixation before target presentation
	basePunishDuration		= 1100;
	
	// Task-specific rewards:
	if (state == stateFIX ||
		state == stateVIS ||
		state == stateAMP)
		{
		baseRewardDuration = 40;
		}
	else if (state == stateMEM)
		{
		baseRewardDuration = 55;
		}
	else if (state == stateDEL)
		{
		baseRewardDuration = 55;
		}
	else if (state == stateCMD)
		{
		baseRewardDuration = 80;
		}
	else if (state == stateCCM)
		{
		baseRewardDuration = 100;
		}
	else if (state == stateGNG)    // monkey can complete these trials quicker, so they should earn less reward per trial (than countermanding or choice countermanding)
		{
		baseRewardDuration = 80;
		}
	else if (state == stateMCM)    // monkey can complete these trials quicker, so they should earn less reward per trial (than countermanding or choice countermanding)
		{
		baseRewardDuration = 80;
		}

	

	// MEMORY/VISUAL/DELAYED SACCADE TASK SPECIFIC----------------------------------------------------------------------------
	if (state == stateMEM ||
		state == stateDEL)
		{	
		targDuration 			= 10;    // number of screen refreshes to wait before turning target off in memory-guided saccade task
		soaMin = 3000;//500
		soaMax = 4000;//2000
		
		sizeArray[0]			= .5;	// targSize of each target individually (degrees)
		sizeArray[1]			= .5;
		sizeArray[2]			= .5;
		sizeArray[3]			= .5;
		sizeArray[4]			= .5;
		sizeArray[5]			= .5;
		sizeArray[6]			= .5;
		sizeArray[7]			= .5;
		
		angleArray[0]			= 0;	// angle of each target individually (degrees)
		angleArray[1]			= 45;
		angleArray[2]			= 90;
		angleArray[3]			= 135;
		angleArray[4]			= 180;
		angleArray[5]			= -135;
		angleArray[6]			= -90;
		angleArray[7]			= -45;
		
		// sizeArray[0]			= .5;	// targSize of each target individually (degrees)
		// sizeArray[1]			= .5;
		// angleArray[0]			= 0;	// angle of each target individually (degrees)
		// angleArray[1]			= 180;

		}
		

	if (state == stateMEM)
		{
		targwinSize = 9;
		}

		
		
		
	// CHOICE COUNTERMANDING TASK SPECIFIC----------------------------------------------------------------------------
	if (state == stateCCM)
		{
		checkerAmp = 0; //6;
		chkrWinSize			= 0; //2.5; //round(iSquareSizePixels * nCheckerColumn / Deg2Pix_X);	// targSize of checkered stimulus window (degrees)

		stopPct				= 0;
		goPct				= 100 - stopPct;

	targetRightRate = .5;
		fiftyPercentRate = .8 * 4 / 7; // How often to run 50% checkered stimulus RELATIVE TO ITS ALREADY RANDOM CHANCE AMONG THE OTHER TRIAL PROPORTIONS
		targ1ExtraPct = 0;  // Percent of theb base reward time to add for the right target
		targ2ExtraPct = 0; // and for the left target
		checkerIsTarg = 0;
		basePunishDuration		= 700;
		
		// ssdArray[0]				= 3;	// needs to be in vertical retrace units
		// ssdArray[1]				= 7;
		// ssdArray[2]				= 11;
		// ssdArray[3]				= 15;
		// ssdArray[4]				= 19;
		// ssdArray[5]				= 23;
		// ssdArray[6]				= 27;
		// ssdArray[7]				= 31;
		// ssdArray[8]				= 35;
		// ssdArray[9]				= 39;
		// ssdArray[10]			= 43;
		// ssdArray[11]			= 47;
		

		ssdArray[0]				= 7;	// needs to be in vertical retrace units
		ssdArray[1]				= 17;
		ssdArray[2]				= 27;
		ssdArray[3]				= 37;
		ssdArray[4]				= 47;
		ssdArray[5]				= 0;
		ssdArray[6]				= 0;
		ssdArray[7]				= 0;
		ssdArray[8]				= 0;
		ssdArray[9]				= 0;
		ssdArray[10]			= 0;
		ssdArray[11]			= 0;


		// targ1PropArray[0] = 0.40;
		// targ1PropArray[1] = .43;
		// targ1PropArray[2] = .47;
		// targ1PropArray[3] = .53;
		// targ1PropArray[4] = 0.57;
		// targ1PropArray[5] = 0.60;
		// targ1PropArray[6] = 0.0;
		// targ1PropArray[7] = 0.0;
		// targ1PropArray[8] = 0.0;
		// targ1PropArray[9] = 0.0;

		// targ1PropArray[0] = 0.1;
		// targ1PropArray[1] = .3;
		// targ1PropArray[2] = .42;
		// targ1PropArray[3] = .58;
		// targ1PropArray[4] = 0.7;
		// targ1PropArray[5] = 0.9;
		// targ1PropArray[6] = 0.0;
		// targ1PropArray[7] = 0.0;
		// targ1PropArray[8] = 0.0;
		// targ1PropArray[9] = 0.0;

		targ1PropArray[0] = 0.0;
		targ1PropArray[1] = 1.0;
		targ1PropArray[2] = 0;
		targ1PropArray[3] = 0;
		targ1PropArray[4] = 0.0;
		targ1PropArray[5] = 0.0;
		targ1PropArray[6] = 0.0;
		targ1PropArray[7] = 0.0;
		targ1PropArray[8] = 0.0;
		targ1PropArray[9] = 0.0;

		
		// trialDist[0] = 1.0; 	// Set these values relative to 1.0 to determine the relative rate of each trial type
		// trialDist[1] = 1.2;
		// trialDist[2] = 1.4;
		// trialDist[3] = 1.4;
		// trialDist[4] = 1.2;
		// trialDist[5] = 1.0;
		// trialDist[6] = 0.0;
		// trialDist[7] = 0.0;
		// trialDist[8] = 0.0;
		// trialDist[9] = 0.0;

		// trialDist[0] = 1.0; 	// Set these values relative to 1.0 to determine the relative rate of each trial type
		// trialDist[1] = 1.2;
		// trialDist[2] = 1.2;
		// trialDist[3] = 1.0;
		// trialDist[4] = 0.0;
		// trialDist[5] = 0.0;
		// trialDist[6] = 0.0;
		// trialDist[7] = 0.0;
		// trialDist[8] = 0.0;
		// trialDist[9] = 0.0;

		trialDist[0] = 1.0; 	// Set these values relative to 1.0 to determine the relative rate of each trial type
		trialDist[1] = 1.0;
		trialDist[2] = 0.0;
		trialDist[3] = 0.0;
		trialDist[4] = 0.0;
		trialDist[5] = 0.0;
		trialDist[6] = 0.0;
		trialDist[7] = 0.0;
		trialDist[8] = 0.0;
		trialDist[9] = 0.0;


		
		// Blue is for Right target		
		Targ1SquareColor[r_]	= 11;	
		Targ1SquareColor[g_]	= 18;	
		Targ1SquareColor[b_]	= 18;	

		Targ2SquareColor[r_]		= 45;
		Targ2SquareColor[g_]		= 18;	
		Targ2SquareColor[b_]		= 27;	
		
		Targ1SquareColor[r_]	= 16.5;	
		Targ1SquareColor[g_]	= 27;	
		Targ1SquareColor[b_]	= 27;	

		Targ2SquareColor[r_]		= 67.5;
		Targ2SquareColor[g_]		= 27;	
		Targ2SquareColor[b_]		= 40.5;	


		// Targ1SquareColor[r_]	= 18;	
		// Targ1SquareColor[g_]	= 20;	
		// Targ1SquareColor[b_]	= 20;	

		// Targ2SquareColor[r_]		= 80;
		// Targ2SquareColor[g_]		= 28;	
		// Targ2SquareColor[b_]		= 40;	

		soaMin = 400;
		soaMax = 1000;

		}

		
	// Task-specific rewards:
	if (state == stateVWM)
		{
		
		allowFixTime = 3000;
		fixwinsize = 5;
		targwinsize = 6.5;
		baseRewardDuration = 80;
		testDuration = 600;
		testRefresh = 70; //70
		testHoldDuration = 1000;//400 1000
		nTrialPerTarget 		= 20;
		nTrialRemain 			= 6000; // initialize this to a really high number for protocols that don't depend on trial numbers (it gets reset for protocols that do)

		//setsize setup
		setSizeArray[0] 			= 1;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[1] 			= 1;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[2] 			= 2;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[3] 			= 2;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[4] 			= 3;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[5] 			= 3;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[6] 			= 4;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[7] 			= 4;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[8] 			= 5;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[9] 			= 5;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[10] 			= 6;   // These get reset to zero each time so new tasks start at zero trials per location.
		setSizeArray[11] 			= 6;   // These get reset to zero each time so new tasks start at zero trials per location.

		//samediff set up!
		sameDiffArray[0] 				= 1;   // These get reset to zero each time so new tasks start at zero trials per location.
		sameDiffArray[1] 				= 2;
		sameDiffArray[2] 				= 1;
		sameDiffArray[3] 				= 2;
		sameDiffArray[4] 				= 1;
		sameDiffArray[5] 				= 2;
		sameDiffArray[6] 				= 1;
		sameDiffArray[7] 				= 2;
		sameDiffArray[8] 				= 1;   // These get reset to zero each time so new tasks start at zero trials per location.
		sameDiffArray[9] 				= 2;
		sameDiffArray[10] 			= 1;
		sameDiffArray[11] 			= 2;		
		
		
		//counter set up!
		nTrialsArray[0] 				= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		nTrialsArray[1] 				= 0;
		nTrialsArray[2] 				= 0;
		nTrialsArray[3] 				= 0;
		nTrialsArray[4] 				= 0;
		nTrialsArray[5] 				= 0;
		nTrialsArray[6] 				= 0;
		nTrialsArray[7] 				= 0;
		nTrialsArray[8] 				= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		nTrialsArray[9] 				= 0;
		nTrialsArray[10] 			= 0;
		nTrialsArray[11] 			= 0;	
		//COLOR set up! [r,g,bl,m,w,cy,br,yl,bk]
		vwmColorArray[0,r_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[0,g_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[0,b_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		
		vwmColorArray[1,r_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[1,g_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[1,b_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		
		vwmColorArray[2,r_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[2,g_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[2,b_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		
		vwmColorArray[3,r_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[3,g_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[3,b_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		
		vwmColorArray[4,r_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[4,g_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[4,b_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		
		vwmColorArray[5,r_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[5,g_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[5,b_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		
		vwmColorArray[6,r_] 		= 42;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[6,g_] 		= 21;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[6,b_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		
		vwmColorArray[7,r_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[7,g_] 		= 63;   // These get reset to zero each time so new tasks start at zero trials per location.
	    vwmColorArray[7,b_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		
		vwmColorArray[8,r_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
		vwmColorArray[8,g_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.
	    vwmColorArray[8,b_] 		= 0;   // These get reset to zero each time so new tasks start at zero trials per location.

		vwmAngleArray[0]			= 45.0;	//45.0 0// angle of each target individually (degrees)
		vwmAngleArray[1]			= 135.0;   //135.0 45
		vwmAngleArray[2]			= 225.0;   //225.0 90
		vwmAngleArray[3]			= 315.0;  //315.0 135
		
		//vwmAngleArray[0]			= 225.0;	//45.0 0// angle of each target individually (degrees)
		//vwmAngleArray[1]			= 315.0;   //135.0 45
		//vwmAngleArray[2]			= 225.0;   //225.0 90
		//vwmAngleArray[3]			= 315.0;  //315.0 135
		// vwmAngleArray[4]			= 0;  //180
		// vwmAngleArray[5]			= 0; //-135
		// vwmAngleArray[6]			= 0;  //-90
		// vwmAngleArray[7]			= 0;  //-45
		
		//original 8locs
		// vwmAngleArray[0]			= 22.5;	// 0// angle of each target individually (degrees)
		// vwmAngleArray[1]			= 67.5;   //45
		// vwmAngleArray[2]			= 112.5;   //90
		// vwmAngleArray[3]			= 157.5;  //135
		// vwmAngleArray[4]			= -157.5;  //180
		// vwmAngleArray[5]			= -112.5; //-135
		// vwmAngleArray[6]			= -67.5;  //-90
		// vwmAngleArray[7]			= -22.5;  //-45
		
		// vwmAngleArray[0]			= 67.5;	// 0// angle of each target individually (degrees)
		// vwmAngleArray[1]			= 67.5;   //45
		// vwmAngleArray[2]			= 67.5;   //90
		// vwmAngleArray[3]			= 67.5;  //135
		// vwmAngleArray[4]			= 67.5;  //180
		// vwmAngleArray[5]			= 22.5; //-135
		// vwmAngleArray[6]			= 67.5;  //-90
		// vwmAngleArray[7]			= 157.5;  //-45
		
		// vwmAngleArray[0]			= 22.5;	// 0// angle of each target individually (degrees)
		// vwmAngleArray[1]			= 67.5;   //45
		// vwmAngleArray[2]			= 67.5;   //90
		// vwmAngleArray[3]			= 67.5;  //135
		// vwmAngleArray[4]			= -157.5;  //180
		// vwmAngleArray[5]			= -112.5; //-135
		// vwmAngleArray[6]			= -112.5;  //-90
		// vwmAngleArray[7]			= -112.5;  //-45
		
		// vwmAngleArray[0]			= 67.5;	// 0// angle of each target individually (degrees)
		// vwmAngleArray[1]			= 67.5;   //45
		// vwmAngleArray[2]			= 67.5;   //90
		// vwmAngleArray[3]			= 67.5;  //135
		// vwmAngleArray[4]			= -112.5;  //180
		// vwmAngleArray[5]			= -112.5; //-135
		// vwmAngleArray[6]			= -112.5;  //-90
		// vwmAngleArray[7]			= -112.5;  //-45
		
		// vwmAngleArray[0]			= 90;	// 0// angle of each target individually (degrees)
		// vwmAngleArray[1]			= 90;   //45
		// vwmAngleArray[2]			= 90;   //90
		// vwmAngleArray[3]			= 90;  //135
		// vwmAngleArray[4]			= 90;  //180
		// vwmAngleArray[5]			= 90; //-135
		// vwmAngleArray[6]			= 90;  //-90
		// vwmAngleArray[7]			= 90;  //-45
		
		// vwmAngleArray[0]			= 0;	// 0// angle of each target individually (degrees)
		// vwmAngleArray[1]			= 45;   //45
		// vwmAngleArray[2]			= 90;   //90
		// vwmAngleArray[3]			= 135;  //135
		// vwmAngleArray[4]			= 180;  //180
		// vwmAngleArray[5]			= -135; //-135
		// vwmAngleArray[6]			= -90;  //-90
		// vwmAngleArray[7]			= -45;  //-45
		
		//for removing rightward bias...
		// vwmAngleArray[0]			= 90;	// 0// angle of each target individually (degrees)
		// vwmAngleArray[1]			= 45;   //45
		// vwmAngleArray[2]			= 0;   //90
		// vwmAngleArray[3]			= -45;  //135
		// vwmAngleArray[4]			= -90;  //180
		// vwmAngleArray[5]			= -45; //-135
		// vwmAngleArray[6]			= 0;  //-90
		// vwmAngleArray[7]			= 45;  //-45
	
		
		}
		}
	}
	
	


	
                                                                                                                                                                                                          //--------------------------------------------------------------------------------------------------
// process DEL_PGS();
//
// Figure out all stimuli that will be needed on the next mem guided trial and
// place it all into video memory.
//


declare DEL_PGS();                       										// see GRAPHS.pro

process DEL_PGS()	                       										// see GRAPHS.pro
{


// number the pgs that need to be drawn
declare hide int   	blank       		= 0;
declare hide int	pd					= 1;
declare hide int	fixation_pd			= 2;
declare hide int	fixation    		= 3;
declare hide int	fixation_target_pd	= 4;
declare hide int	fixation_target		= 5;
declare hide int	target_pd   		= 6;
declare hide int	target      		= 7;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Calculate screen coordinates for stimuli on this trial
// targAmp = ampArray[targIndex];												// THEY CANNOT BE PASSED INTO PROCESSES
if (AutoTargetSizeFlag)
	{
	targSize        	 	= targAmp * TargetSizeConversion;   			// Figure out the attributes of the current target
	}
else
	{
	targSize				= sizeArray[targIndex];
	}
targColor        = targIndex + 1;																// zero is reserved for black.  see SET_CLRS.pro


opposite = ((screenHeight/2)-pdBottom);														// Figure out targAngle and eccentricity of photodiode marker in pixels
adjacent = ((screenWidth/2)-pdLeft);                                                         // NOTE: I am assuming your pd is in the lower left quadrant of your screen
pdAmp = sqrt((opposite * opposite) + (adjacent * adjacent));
pdAngle = rad2deg(atan (opposite / adjacent));
pdAngle = pdAngle + 180; 																	//change this for different quadrent or write some code for flexibility

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 1
// print("photodiode");
dsendf("rw %d,%d;\n",pd,pd);				 												// draw first pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 2
// print("fixation with photodiode");
dsendf("rw %d,%d;\n",fixation_pd,fixation_pd); 												// draw second pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 3
// print("fixation");
dsendf("rw %d,%d;\n",fixation,fixation);   													// draw 3rd pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 4
// print("fixation target and photodiode");
dsendf("rw %d,%d;\n",fixation_target_pd,fixation_target_pd);   								// draw 4th pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 5
// print("fixation and target");
dsendf("rw %d,%d;\n",fixation_target,fixation_target);   								// draw 4th pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 5
// print("target with photodiode");
dsendf("rw %d,%d;\n",target_pd,target_pd);  												// draw pg 5
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 6
// print("target");
dsendf("rw %d,%d;\n",target,target);  														// draw pg 6
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);         	// draw target
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 0 (last is displayed first)
// print("blank");
dsendf("rw %d,%d;\n",blank,blank);                                          				// draw the blank screen last so that it shows up first
dsendf("cl:\n");                                                                            // clear screen (that's all)

}//--------------------------------------------------------------------------------------------
// Run a memory guided saccade trial based on the variables calculated by SETD_TRL.pro and
// those given by the user.  Adapted from MEMTRIAL
//
// 04-2012: created		-pgm


declare DELTRIAL();			// animated graph object

process DELTRIAL()        		// animated graph object
	{


	// Number the trial stages to make them easier to read below
	declare hide int 	need_fix  	= 1;
	declare hide int 	fixating  	= 2;
	declare hide int 	targ_on   	= 3;
	declare hide int	fix_off		= 4;
	declare hide int 	in_flight 	= 5;
	declare hide int 	on_target 	= 6;
	declare hide int 	stage;

	// Number the stimuli pages to make reading easier
	declare hide int   	blank       		= 0;
	declare hide int	pd					= 1;
	declare hide int	fixation_pd 		= 2;
	declare hide int	fixation    		= 3;
	declare hide int	fixation_target_pd	= 4;
	declare hide int	fixation_target		= 5;
	declare hide int	target_pd   		= 6;
	declare hide int	target      		= 7;


	// Timing variables which will be used to time task
	declare hide float 	fix_on_time;
	declare hide float 	aquire_fix_time;
	declare hide float  targ_time;
	declare hide float	fix_off_time;
	declare hide float  saccade_time;
	declare hide float	aquire_targ_time;

	// Have to be reset on every iteration since
	// variable declaration only occurs at load time
	trl_running 		= 1;
	stage 				= need_fix;

	// Tell the user what's up
	printf(" \n");
	printf("# %d\n",nTrial);
	printf("Hold time:     %d\n",  soa);



																			// HERE IS WHERE THE FUN BEGINS
	Event_fifo[Set_event] = TrialStart_;									// queue TrialStart_ strobe
	Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
	dsendf("vp %d\n",fixation_pd);											// flip the pg to the fixation stim with pd marker
	fix_on_time = time();  													// record the time
	Event_fifo[Set_event] = FixSpotOn_;										// queue strobe
	Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
	dsendf("XM RFRSH:\n"); 													// wait for one retrace
	dsendf("vp %d\n",fixation);												// flip the pg to the fixation stim without pd marker
	oSetAttribute(object_fix, aVISIBLE); 									// turn on the fixation point in animated graph


	while (trl_running)														// trials ending will set trl_running = 0
		{

	//--------------------------------------------------------------------------------------------
	// STAGE need_fix (the fixation point is on, but the subject hasn't looked at it)
		if (stage == need_fix)
			{
			if (In_FixWin && time() > 200)													// If the eyes have entered the fixation window (before time, see below)...
				{
				aquire_fix_time = time();									// ...function call to time to note current time and...
				trialStartTime = aquire_fix_time;							// Global output for timing iti
				Event_fifo[Set_event] = Fixate_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				stage = fixating;											// ...advance to the next stage.
				}
			else if (time() > fix_on_time + allowFixTime)				// But if time runs out...
				{
				trialOutcome = noFix;    									// TRIAL OUTCOME ABORT (no fixation)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen,...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Aborted (no fixation)\n");							// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}
			}



	//--------------------------------------------------------------------------------------------
	// STAGE fixating (the subject is looking at the fixation point waiting for target onset)
		else if (stage == fixating)
			{
			if (!In_FixWin && time() > aquire_fix_time + 100)													// If the eyes stray out of the fixation window...
				{
				trialOutcome = brokeFix;									// TRIAL OUTCOME ABORT (broke fixation)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}
			else if (In_FixWin && time() > aquire_fix_time + preTargHoldtime)	// But if the eyes are still in the window at end of holdtime...
				{
				dsendf("vp %d\n",fixation_target_pd);						// ...flip the pg to the target with pd marker...
				targ_time = time(); 										// ...record the time...
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				dsendf("vp %d\n",fixation_target);						// ...flip the pg to the target with pd marker...
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
					dsendf("vw %d\n",targDuration-1);							// Wait so many vertical retraces (one is waited implicitly b/c photodiode marker above)...
//				dsendf("vp %d\n",fixation);									// ...flip the pg to the fixation point without pd marker.
				Event_fifo[Set_event] = Target_;						// Queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...

				oSetAttribute(object_targ, aVISIBLE); 						// ...show target in animated graph...

				stage = targ_on;											// Advance to the next trial stage.
				}
			}



	//--------------------------------------------------------------------------------------------
	// STAGE targ_off (the target has been presented and disappeared but the subject is still fixating)
		else if (stage == targ_on)
			{
			if (!In_FixWin)													// If the eyes leave the fixation window...
				{
				trialOutcome = saccEarly;									// TRIAL OUTCOME ERROR (sacc before cued to do so)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (early saccade)\n");							// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}

			else if (In_FixWin &&  											// But if no saccade occurs...
				time() > targ_time + soa)	 							// ...and the stim onset asychrony passes...
				{
				dsendf("vp %d\n",target_pd);										// DELAY TASK  Flip the pg to the target screen with the photodiode marker...
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				dsendf("vp %d\n",target);									// ...flip the pg to the target with pd marker...
				fix_off_time = time();										// ...and record the time that the fixation point was extinguished.
				Event_fifo[Set_event] = FixSpotOff_;						// Queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				stage = fix_off;											// ...and advance to the next stage.
				}
			}



	//--------------------------------------------------------------------------------------------
	// STAGE fix_off (the fixation point has been turned off but the subject is still fixating)
		else if (stage == fix_off)
			{
			if (!In_FixWin)													// If the eyes leave the fixation window...
				{															// ...we have a saccade, so...
				saccade_time = time();										// ...record the time...
				Event_fifo[Set_event] = Saccade_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				printf("                          rt = %d\n",saccade_time - fix_off_time);	// ...tell the user whats up...
				stage = in_flight;											// ...and advance to the next stage.
				}

			else if (In_FixWin &&  											// But if no saccade occurs...
				time() > fix_off_time + saccTimeMax) 					// ...and time for a saccade runs out...
				{
				trialOutcome = noSacc;           							// TRIAL OUTCOME ERROR (no saccade after cue)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (no saccade)\n");								// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}
			}


	//--------------------------------------------------------------------------------------------
	// STAGE in_flight (eyes have left fixation window but have not entered target window)
		else if (stage == in_flight)
			{
			if (In_TargWin)													// If the eyes get into the target window...
				{
				aquire_targ_time = time(); 									// ...record the time...
				Event_fifo[Set_event] = Decide_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				stage = on_target;											// ...and advance to the next stage of the trial.
				}
			else if (time() > saccade_time + saccDurationMax)				// But, if the eyes are out of the target window and time runs out...
				{
				trialOutcome = saccOut;   									// TRIAL OUTCOME ERROR (innacurrate saccade)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (inaccurate saccade)\n");						// ...tell the user whats up...
				trl_running = 0; 											// ...and terminate the trial.
				}
			}



	//--------------------------------------------------------------------------------------------
	// STAGE on_target (eyes have entered the target window.  will they remain there for duration?)
		else if (stage == on_target)
			{
			if (!In_TargWin)												// If the eyes left the target window...
				{
				trialOutcome = brokeTarg;									// TRIAL OUTCOME ERROR (broke target fixation)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (broke target fixation)\n");					// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}
			else if (In_TargWin  											// But if the eyes are still in the target window...
				&&  time() > aquire_targ_time + targHoldtime)				// ...and the target hold time is up...
				{
				trialOutcome = saccTarg;									//TRIAL OUTCOME CORRECT (correct sacc trial)
				Event_fifo[Set_event] = Correct_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				printf("Correct (saccade)\n");								// ...tell the user whats up...
				dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				trl_running = 0;											// ...and terminate the trial.
				}
			}

		nexttick;
		}
	}/* DIO.PRO - Definitions for use with TEMPO's DIO module
** Copyright 1994-2002 Reflective Computing.  All rights reserved.
**
*/

// OR these in dioSetMode() function(s) to set output TTL ports.

hide constant PORTA =    0x1;
hide constant PORTB =    0x2;
hide constant PORTC =    0x4;



//-----------------------------------------------------------------------------------
// process DRW_CHKR(int changeStimulus);

// Prepares a checkered stimulus for each trial. The stimulus is comprised of blue and red
// checkered squares. The proportion of blue (and thus red) squares is randomly selected from
// an array of possible proportions (see BlueProportionArray in DEFAULT.pro), and the blue
// squares are randomly placed within the checkered stimulus. The target gets defined by
// whether the proportion of Blue squares is over or under 0.5.


// define constants
declare float 	CheckerWidthDegrees, CheckerHeightDegrees;
	
declare DRW_CHKR(int changeStimulus);

process DRW_CHKR(int changeStimulus)
	{
	
	// stimtest variables
	declare int 	iSquare, iLevel, iRow, iColumn;
	declare int 	tempIndex, tempColor;
	declare int 	iSquareIndex;
	declare int 	iSquareColorChannel;
	declare int 	iSquareCenterX;
	declare int 	iSquareCenterY;
	declare int 	iSquareEccentricity;	
	declare int 	iSquareAngle;
	declare float 	iSquareULX, checkerULX;
	declare float 	iSquareULY, checkerULY;
	declare float 	iSquareLRX, checkerLRX;
	declare float 	iSquareLRY, checkerLRY;
	declare int 	nTarg1Square, nTarg2Square;
	declare float 	checkerOffsetX, checkerOffsetY;
	declare float 	checkerSizePixels;
	declare hide int r_, g_, b_;
	declare int		largeSquareColorR, largeSquareColorG, largeSquareColorB;
	declare int		smallSquareColorR, smallSquareColorG, smallSquareColorB;
	declare int 	iSquareColor[3]; //
	declare int 	iChecker, nTarg2, nTarg1; //
	declare int		majorityColor, minorityColor; 
	declare float   nMinority, nRowRemain, nMax, nMin;
	declare int 	randInsert, nInsert;
	declare float 	minorityP;
	
	r_ = 0; g_ = 1; b_ = 2;			
		
	// Where on the screen is the stimulus in x,y coordinates (in pixels)?
	checkerOffsetX = checkerAmp * cos(checkerAngle) * Deg2Pix_X;
	checkerOffsety = checkerAmp * sin(checkerAngle) * Deg2Pix_Y;
	checkerSizePixels = iSquareSizePixels * nCheckerColumn;
	CheckerWidthDegrees = checkerSizePixels / Deg2Pix_X;
	CheckerHeightDegrees = checkerSizePixels / Deg2Pix_Y;
	
	// oMove(object_checker, checkerOffsetX*deg2pix_X, checkerOffsety*deg2pix_Y);								// ...and move the animated graph object there.
	// oSetAttribute(object_checker, aSIZE, checkerSizePixels/deg2pix_x, checkerSizePixels/deg2pix_y);							// while we are at it, resize fixation object on animated graph

	
	if (changeStimulus == 1)
		{

		// TO MINIMIZE THE AMOUNT OF INFO SENT TO VIDEOSYNC, IF THE CHECKER STIMULUS
		// IS MOSTLY Targ2, START WITH A BIG Targ2 SQUARE AND DRAW SMALL Targ1-targColor SQUARES.
		// LIKEWISE, IF THE CHECKER STIMULUS IS MOSTLY Targ1, START WITH A BIG Targ1-targColor 
		// SQUARE AND DRAW SMALL Targ2-targColor SQUARES
		
		// *************   USE THE FOLLOWING LINES OF CODE WITH CHKRSTIM.PRO TO TEST LUMINANCE, ETC    **********
		// targIndex = Targ1;  // for testing
		// proportionIndex = 0;  // Use this with target1ProportionArrya for testing luminance
		// targIndex = Targ2;  // for testing
		// proportionIndex = 1;  // Use this with target1ProportionArrya for testing luminance
		// **************************************************************************************************************
		if (targIndex == Targ1 || targIndex == Targ1+2)
			{
			majorityColor = 0;
			minorityColor = 1;
			minorityP     = 1.0 - targ1PropArray[proportionIndex];
			// Set the large and small square colors:
			largeSquareColorR = Targ1SquareColor[0];
			largeSquareColorG = Targ1SquareColor[1];
			largeSquareColorB = Targ1SquareColor[2];
			smallSquareColorR = Targ2SquareColor[0];
			smallSquareColorG = Targ2SquareColor[1];
			smallSquareColorB = Targ2SquareColor[2];
			}
		else if (targIndex == Targ2 || targIndex == Targ2+2)
			{
			majorityColor = 1;
			minorityColor = 0;
			minorityP     = targ1PropArray[proportionIndex];
			// Set the large and small square colors:
			smallSquareColorR = Targ1SquareColor[0];
			smallSquareColorG = Targ1SquareColor[1];
			smallSquareColorB = Targ1SquareColor[2];
			largeSquareColorR = Targ2SquareColor[0];
			largeSquareColorG = Targ2SquareColor[1];
			largeSquareColorB = Targ2SquareColor[2];
			}
			
		// Initialize all checkers to majority (target) color
		iSquare = 0;
		while (iSquare < nSquare)
			{
			checkerboardArray[iSquare] = majorityColor;
			iSquare = iSquare + 1;			
			}
		
		nRowRemain = nCheckerRow;
		nMinority = round(minorityP * nSquare);
		nMax = ceil(nMinority / nRowRemain);
		nMin = floor(nMinority / nRowRemain);
		
		iRow = 1;
		while (iRow <= nCheckerRow)
			{
			
			// Choose the number of minority color checkers to insert in the row
			randInsert = random(2);
			if (randInsert == 0)
				nInsert = nMax;
			else if (randInsert == 1)
				nInsert = nMin;
				
			// Fill row with minority checkers	
			iColumn = 1;
			while (iColumn <= nInsert)
				{
				iSquare = (iRow-1) * nCheckerColumn + (iColumn-1);
				checkerboardArray[iSquare] = minorityColor;
				iColumn = iColumn + 1;
				}
			// Randomly shuffle the ones and zeros within the row
			iColumn = 1;
			while (iColumn <= nCheckerColumn)
				{
				iSquare = (iRow-1) * nCheckerColumn + (iColumn-1);
				tempIndex = (iRow-1) * nCheckerColumn + random(nCheckerColumn);
				tempColor = checkerboardArray[tempIndex];
				checkerboardArray[tempIndex] = checkerboardArray[iSquare];
				checkerboardArray[iSquare] = tempColor;
				iColumn = iColumn + 1;
				}
			// Update the variables used to caclulate how many minority color checkers will go into the next row
			nRowRemain = nRowRemain - 1;
			nMinority = nMinority - nInsert;
			nMax = ceil(nMinority / nRowRemain);
			nMin = floor(nMinority / nRowRemain);
			
			iRow = iRow + 1;
			}
			
			
			
		/*	
			// Re-set all the squares to Targ2 (ones) each trial
			iSquare = 0;
			while (iSquare < nSquare)
				{
				checkerboardArray[iSquare] = Targ2;
				iSquare = iSquare + 1;			
				}
			// Calculate how many squares will be Targ1 on this trial
			nTarg1Square = round(targ1PropArray[proportionIndex] * nSquare);
			nTarg2Square = round((1 - targ1PropArray[proportionIndex]) * nSquare);
	// printf("      nTarg1 nTarg2:  = %d \t %d\n", nTarg1Square, nTarg2Square);

			// Fill checkerboardArray with as many zeros as there will be Targ1 squares
			iSquare = 0;
			while (iSquare < nTarg1Square)
				{
				checkerboardArray[iSquare] = Targ1;
				iSquare = iSquare + 1;			
				}
			
			// Now randomly suffle sort the ones and zeros in the array
			iSquare = 0;
			while (iSquare < nSquare)
				{
				tempIndex = random(nSquare);
				tempColor = checkerboardArray[tempIndex];
				checkerboardArray[tempIndex] = checkerboardArray[iSquare];
				checkerboardArray[iSquare] = tempColor;
				iSquare = iSquare + 1;
				}

				
			
		if (targIndex == Targ1 || targIndex == Targ1+2)
			{
			// Set the large and small square colors:
			largeSquareColorR = Targ1SquareColor[0];
			largeSquareColorG = Targ1SquareColor[1];
			largeSquareColorB = Targ1SquareColor[2];
			smallSquareColorR = Targ2SquareColor[0];
			smallSquareColorG = Targ2SquareColor[1];
			smallSquareColorB = Targ2SquareColor[2];
			
			// Re-set all the squares to Targ1 (zeros) each trial
			iSquare = 0;
			while (iSquare < nSquare)
				{
				checkerboardArray[iSquare] = Targ1;
				iSquare = iSquare + 1;			
				}
			// Calculate how many squares will be Targ2 on this trial
			nTarg1Square = round(targ1PropArray[proportionIndex] * nSquare);
			nTarg2Square = round((1 - targ1PropArray[proportionIndex]) * nSquare);
	// printf("      nTarg1 nTarg2:  = %d \t %d\n", nTarg1Square, nTarg2Square);

			// Fill checkerboardArray with as many ones as there will be Targ2 squares
			iSquare = 0;
			while (iSquare < nTarg2Square)
				{
				checkerboardArray[iSquare] = Targ2;
				iSquare = iSquare + 1;			
				}
			
			// Now randomly suffle sort the ones and zeros in the array
			iSquare = 0;
			while (iSquare < nSquare)
				{
				tempIndex = random(nSquare);
				tempColor = checkerboardArray[tempIndex];
				checkerboardArray[tempIndex] = checkerboardArray[iSquare];
				checkerboardArray[iSquare] = tempColor;
				iSquare = iSquare + 1;
				}
			}	
		*/						
		}
	


	
	// We have an array (checkerboardArray) with a proportional number Targ1 (0's) and Targ2 (1's) squares
	// Now we want to:
	// 1. Draw a large square the targSize of the whole checkered stimulus, the targColor of the correct target direction
	// 2. Loop through and draw small Targ1 squares in their randomized positions, the targColor of the incorrect target direction
	
	// 1. Draw a large square the targSize of the whole stimulus	
	// Determine the upper left and lower right of the large square
	checkerULX = checkerOffsetX - checkerSizePixels/2;
	checkerULY = checkerOffsetY + checkerSizePixels/2;
	checkerLRX = checkerOffsetX + checkerSizePixels/2 - 1;
	checkerLRY = checkerOffsetY - checkerSizePixels/2 + 1;
			
	// Draw the large square
	iSquareColor[0] = largeSquareColorR;
	iSquareColor[1] = largeSquareColorG;
	iSquareColor[2] = largeSquareColorB;
	dsendf("cm 100 %d %d %d;\n",					// set the targColor of the large square to 100
	iSquareColor[r_],			
	iSquareColor[g_],
	iSquareColor[b_]);
	iSquareColorChannel = 100;
	dsendf("co %d;\n", iSquareColorChannel);
	dsendf("rf %d,%d,%d,%d;\n", checkerULX, checkerULY, checkerLRX, checkerLRY);
	nexttick;

	
	
	
	// 2. Loop through and draw small minority color squares in their randomized positions
	iRow = 1;
	while (iRow <= nCheckerRow)
		{
		iColumn = 1;
		while (iColumn <= nCheckerColumn)
			{
			// Which targColor is the current square?
			iSquareIndex = iColumn + (nCheckerColumn * (iRow - 1)) - 1;
			// printf("iSquareIndex: %d   blueRed: %d   \n", iSquareIndex, checkerboardArray[iSquareIndex]);
			// if (targIndex == Targ2 || targIndex == Targ2+2)
				// {
				if (checkerboardArray[iSquareIndex] == minorityColor)
					{
					iSquareColor[0] = smallSquareColorR;
					iSquareColor[1] = smallSquareColorG;
					iSquareColor[2] = smallSquareColorB;
					dsendf("cm 101 %d %d %d;\n",					// set the targColor of the small Targ1 squares to 101
					iSquareColor[r_],			
					iSquareColor[g_],
					iSquareColor[b_]);
					iSquareColorChannel = 101;
					
					// Determine upper left and lower right coordinates of small Targ1 iSquare
					iSquareULX = checkerULX + iSquareSizePixels * (iColumn - 1);
					iSquareULY = checkerULY - iSquareSizePixels * (iRow - 1); 
					iSquareLRX = iSquareULX + (iSquareSizePixels - 1);
					iSquareLRY = iSquareULY - (iSquareSizePixels - 1);
				
					// Draw the current iSquare				
					dsendf("co %d;\n", iSquareColorChannel);
					dsendf("rf %d,%d,%d,%d;\n", iSquareULX, iSquareULY, iSquareLRX, iSquareLRY);
					}
/*				}
			else if (targIndex == Targ1)
				{
				if (checkerboardArray[iSquareIndex] == Targ2 || checkerboardArray[iSquareIndex]  == Targ2+2)
					{
					iSquareColor[0] = smallSquareColorR;
					iSquareColor[1] = smallSquareColorG;
					iSquareColor[2] = smallSquareColorB;
					dsendf("cm 101 %d %d %d;\n",					// set the targColor of the small Targ1 squares to 101
					iSquareColor[r_],			
					iSquareColor[g_],
					iSquareColor[b_]);
					iSquareColorChannel = 101;
					
					// Determine upper left and lower right coordinates of small Targ1 iSquare
					iSquareULX = checkerULX + iSquareSizePixels * (iColumn - 1);
					iSquareULY = checkerULY - iSquareSizePixels * (iRow - 1); 
					iSquareLRX = iSquareULX + (iSquareSizePixels - 1);
					iSquareLRY = iSquareULY - (iSquareSizePixels - 1);
				
					// Draw the current iSquare				
					dsendf("co %d;\n", iSquareColorChannel);
					dsendf("rf %d,%d,%d,%d;\n", iSquareULX, iSquareULY, iSquareLRX, iSquareLRY);
					}
				} */
			iColumn = iColumn + 1;								
			nexttick 2;				
			}
		iRow = iRow + 1;
		nexttick 2;
		}
		

	}

//-----------------------------------------------------------------------------------
// process DRW_GNG(int changeStimulus);

// Prepares a checkered stimulus for each trial. The stimulus is comprised of 2 colors of
// checkered squares. The proportion of Go squares is randomly selected from
// an array of possible proportions (see goPropArray in DEFAULT.pro), and the Go
// squares are randomly placed within the checkered stimulus. The target gets defined by
// whether the proportion of Go squares is over or under 0.5.


// define constants
declare int		GoNoGoFlag;
declare int		Go = 0;
declare int		Nogo = 1;
declare float 	CheckerWidthDegrees, CheckerHeightDegrees;
	
declare DRW_GNG(int changeStimulus);

process DRW_GNG(int changeStimulus)
	{
	
	// stimtest variables
	declare int 	iSquare, iLevel, iGoSquare, iNoGoSquare, iRow, iColumn;
	declare int 	tempIndex, tempColor;
	declare int 	iSquareIndex;
	declare int 	iSquareColorChannel;
	declare int 	iSquareCenterX;
	declare int 	iSquareCenterY;
	declare int 	iSquareEccentricity;	
	declare int 	iSquareAngle;
	declare float 	iSquareULX, checkerULX;
	declare float 	iSquareULY, checkerULY;
	declare float 	iSquareLRX, checkerLRX;
	declare float 	iSquareLRY, checkerLRY;
	declare float 	nGoSquare, nNoGoSquare;
	declare float 	checkerOffsetX, checkerOffsetY;
	declare float 	checkerSizePixels;
	declare hide int r_, g_, b_;
	declare int		largeSquareColorR, largeSquareColorG, largeSquareColorB;
	declare int		smallSquareColorR, smallSquareColorG, smallSquareColorB;
	declare int 	iSquareColor[3]; //
	r_ = 0; g_ = 1; b_ = 2;			
		
	// Where on the screen is the stimulus in x,y coordinates (in pixels)?
	checkerOffsetX = checkerAmp * cos(checkerAngle) * Deg2Pix_X;
	checkerOffsety = checkerAmp * sin(checkerAngle) * Deg2Pix_Y;
	checkerSizePixels = iSquareSizePixels * nCheckerColumn;
	CheckerWidthDegrees = checkerSizePixels / Deg2Pix_X;
	CheckerHeightDegrees = checkerSizePixels / Deg2Pix_Y;
	
	// Calculate the dimensions of each checker square
	// iSquareWidthPixels = round(iSquareWidthDegrees * Deg2Pix_X);
	// iSquareHeightPixels = round(iSquareWidthDegrees * Deg2Pix_Y);
	
	
	if (changeStimulus == 1)
		{


		
		// TO MINIMIZE THE AMOUNT OF INFO SENT TO VIDEOSYNC, IF THE CHECKER STIMULUS
		// IS MOSTLY RED, START WITH A BIG RED SQUARE AND DRAW SMALL BLUE SQUARES.
		// LIKEWISE, IF THE CHECKER STIMULUS IS MOSTLY BLUE, START WITH A BIG BLUE 
		// SQUARE AND DRAW SMALL RED SQUARES
		
		
		if (GoNoGoFlag == NoGo)
			{
			// Set the large and small square colors:
			largeSquareColorR = NoGoSquareColor[0];
			largeSquareColorG = NoGoSquareColor[1];
			largeSquareColorB = NoGoSquareColor[2];
			smallSquareColorR = GoSquareColor[0];
			smallSquareColorG = GoSquareColor[1];
			smallSquareColorB = GoSquareColor[2];
			
			// Re-set all the squares to NoGo (zeros) each trial
			iSquare = 0;
			while (iSquare < nSquare)
				{
				checkerboardArray[iSquare] = NoGo;
				iSquare = iSquare + 1;			
				}
			// Calculate how many squares will be go on this trial
			nGoSquare = goPropArray[proportionIndex] * nSquare;
			
			// Fill checkerboardArray with as many ones as there will be go squares
			iNoGoSquare = 0;
			while (iNoGoSquare < nGoSquare)
				{
				checkerboardArray[iNoGoSquare] = go;
				iNoGoSquare = iNoGoSquare + 1;			
				}
			
			// Now randomly suffle sort the ones and zeros in the array
			iSquare = 0;
			while (iSquare < nSquare)
				{
				tempIndex = random(nSquare);
				tempColor = checkerboardArray[tempIndex];
				checkerboardArray[tempIndex] = checkerboardArray[iSquare];
				checkerboardArray[iSquare] = tempColor;
				iSquare = iSquare + 1;
				}
			}	
			
			
		if (GoNoGoFlag == Go)
			{
			// Set the large and small square colors:
			largeSquareColorR = GoSquareColor[0];
			largeSquareColorG = GoSquareColor[1];
			largeSquareColorB = GoSquareColor[2];
			smallSquareColorR = NoGoSquareColor[0];
			smallSquareColorG = NoGoSquareColor[1];
			smallSquareColorB = NoGoSquareColor[2];
			
			// Re-set all the squares to go (ones) each trial
			iSquare = 0;
			while (iSquare < nSquare)
				{
				checkerboardArray[iSquare] = Go;
				iSquare = iSquare + 1;			
				}
			// Calculate how many squares will be nogo on this trial
			nNoGoSquare = (1 - goPropArray[proportionIndex]) * nSquare;
			
			// Fill checkerboardArray with as many zeros as there will be go squares
			iGoSquare = 0;
			while (iGoSquare < nNoGoSquare)
				{
				checkerboardArray[iGoSquare] = NoGo;
				iGoSquare = iGoSquare + 1;			
				}
			
			// Now randomly suffle sort the ones and zeros in the array
			iSquare = 0;
			while (iSquare < nSquare)
				{
				tempIndex = random(nSquare);
				tempColor = checkerboardArray[tempIndex];
				checkerboardArray[tempIndex] = checkerboardArray[iSquare];
				checkerboardArray[iSquare] = tempColor;
				iSquare = iSquare + 1;
				}
			}	
								
		}
	


	
	// We have an array (checkerboardArray) with a proportional number go (1's) and nogo (0's) squares
	// Now we want to:
	// 1. Draw a large nogo square the targSize of the whole checkered stimulus
	// 2. Loop through and draw small go squares in their randomized positions
	
	// 1. Draw a large nogo square the targSize of the whole stimulus	
	// Determine the upper left and lower right of the large nogo square
	checkerULX = checkerOffsetX - checkerSizePixels/2;
	checkerULY = checkerOffsetY + checkerSizePixels/2;
	checkerLRX = checkerOffsetX + checkerSizePixels/2 - 1;
	checkerLRY = checkerOffsetY - checkerSizePixels/2 + 1;
			
	// Draw the large nogo iSquare
	iSquareColor[0] = largeSquareColorR;
	iSquareColor[1] = largeSquareColorG;
	iSquareColor[2] = largeSquareColorB;
	dsendf("cm 100 %d %d %d;\n",					// set the targColor of the large nogo square to 254
	iSquareColor[r_],			
	iSquareColor[g_],
	iSquareColor[b_]);
	iSquareColorChannel = 100;
	dsendf("co %d;\n", iSquareColorChannel);
	dsendf("rf %d,%d,%d,%d;\n", checkerULX, checkerULY, checkerLRX, checkerLRY);
	nexttick;

	
	
	
	// 2. Loop through and draw small go squares in their randomized positions
	iRow = 1;
	while (iRow <= nCheckerRow)
		{
		iColumn = 1;
		while (iColumn <= nCheckerColumn)
			{
			// Which targColor is the current square?
			iSquareIndex = iColumn + (nCheckerColumn * (iRow - 1)) - 1;
			// printf("iSquareIndex: %d   goNoGo: %d   %d   %d\n", iSquareIndex, checkerboardArray[iSquareIndex], m, n);
			if (GoNoGoFlag == NoGo)
				{
				if (checkerboardArray[iSquareIndex] == Go)
					{
					iSquareColor[0] = smallSquareColorR;
					iSquareColor[1] = smallSquareColorG;
					iSquareColor[2] = smallSquareColorB;
					dsendf("cm 101 %d %d %d;\n",					// set the targColor of the small go squares to 255
					iSquareColor[r_],			
					iSquareColor[g_],
					iSquareColor[b_]);
					iSquareColorChannel = 101;
					
					// Determine upper left and lower right coordinates of small go iSquare
					iSquareULX = checkerULX + iSquareSizePixels * (iColumn - 1);
					iSquareULY = checkerULY - iSquareSizePixels * (iRow - 1); 
					iSquareLRX = iSquareULX + (iSquareSizePixels - 1);
					iSquareLRY = iSquareULY - (iSquareSizePixels - 1);
				
					// Draw the current iSquare				
					dsendf("co %d;\n", iSquareColorChannel);
					dsendf("rf %d,%d,%d,%d;\n", iSquareULX, iSquareULY, iSquareLRX, iSquareLRY);
					}
				}
			else if (GoNoGoFlag == Go)
				{
				if (checkerboardArray[iSquareIndex] == NoGo)
					{
					iSquareColor[0] = smallSquareColorR;
					iSquareColor[1] = smallSquareColorG;
					iSquareColor[2] = smallSquareColorB;
					dsendf("cm 101 %d %d %d;\n",					// set the targColor of the small go squares to 255
					iSquareColor[r_],			
					iSquareColor[g_],
					iSquareColor[b_]);
					iSquareColorChannel = 101;
					
					// Determine upper left and lower right coordinates of small go iSquare
					iSquareULX = checkerULX + iSquareSizePixels * (iColumn - 1);
					iSquareULY = checkerULY - iSquareSizePixels * (iRow - 1); 
					iSquareLRX = iSquareULX + (iSquareSizePixels - 1);
					iSquareLRY = iSquareULY - (iSquareSizePixels - 1);
				
					// Draw the current iSquare				
					dsendf("co %d;\n", iSquareColorChannel);
					dsendf("rf %d,%d,%d,%d;\n", iSquareULX, iSquareULY, iSquareLRX, iSquareLRY);
					}
				}
			iColumn = iColumn + 1;								
			nexttick;				
			}
		iRow = iRow + 1;
		nexttick;
		}
		

	}

//--------------------------------------------------------------------------------------------------
// process DRW_SQR(squareSize,squareAngle,squareAmp,squareColor,fill)
// Draw a square on the video sync screen
//
// INPUT
//	 squareSize         = how big do you want the square to be?  (must know your virtual coordiate system)
//	 squareAngle 		  = in cartesian coordinates
//   squareAmp = once again you must know your virtual coordiate system
//   squareColor        = squareColor of box (must know the current pallettes you are using)
//   fill         = 0 (no fill) or 1 (fill)
//   deg2pixX     = scaling factor to go between degrees and pixels (see SET_COOR.pro)
//   deg2pixY     = same as above
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011

declare DRW_SQR(float squareSize, float squareAngle, float squareAmp, int squareColor, int fill, float conversion_X, float conversion_Y);

process DRW_SQR(float squareSize, float squareAngle, float squareAmp, int squareColor, int fill, float conversion_X, float conversion_Y)
	{
	declare hide float stim_ecc_x;
	declare hide float stim_ecc_y;
	declare hide float half_size;
	declare hide int ulx;
	declare hide int uly;
	declare hide int lrx;
	declare hide int lry;
	
	// find the center of the box in x and y space based on the squareAngle and squareAmp
	stim_ecc_x = cos(squareAngle) * squareAmp;
	stim_ecc_y = sin(squareAngle) * squareAmp;

	// find locations of upper left and lower right corners based on location of center and squareSize
	half_size = squareSize/2;
		ulx       = round((stim_ecc_x - half_size)*conversion_X);
		uly       = round((stim_ecc_y + half_size)*conversion_Y);
		lrx       = round((stim_ecc_x + half_size)*conversion_X);
		lry       = round((stim_ecc_y - half_size)*conversion_Y);

		//If the checkerboard serves as a target, the targets should be same squareSize as checkerboard
	// if (checkerIsTarg == 1)
		// {
		// half_size = iSquareSizePixels * nCheckerColumn / 2;
		// ulx       = round(stim_ecc_x*conversion_X - half_size);
		// uly       = round(stim_ecc_y *conversion_Y + half_size);
		// lrx       = round(stim_ecc_x*conversion_X + half_size);
		// lry       = round(stim_ecc_y*conversion_Y - half_size);
		// }

	
	// send video sync command to draw desired square
	dsendf("co %d;\n",squareColor);
	
	if(fill == 0)
		{
		dsendf("ru %d,%d,%d,%d;\n",ulx,uly,lrx,lry);
		}
	else
		{
		dsendf("rf %d,%d,%d,%d;\n",ulx,uly,lrx,lry);
		}

	}// These codes are the numbers they are for historic reasons.
// Many are not currently being used and could be discarded.
// This is hold over garbage from the bad old days.
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011
// 11-2011: Integrated choice countermanding task. -pgm
// 11-2011: Integrated visually guided saccade task. -pgm
// 11-2011: Integrated amplitude saccade task. -pgm

declare hide constant FixSpotOn_		= 2301;
declare hide constant Fixate_			= 2660;
declare hide constant ProFixate_		= 2661;
declare hide constant DecFixate_		= 2662;
declare hide constant BetFixate_		= 2663;
declare hide constant Target_			= 2651; //Must Check to be sure.
declare hide constant Choice_			= 2652; //Must Check to be sure.
declare hide constant Cue_				= 2653; //Must Check to be sure.
declare hide constant Saccade_ 			= 2810;
declare hide constant FixSpotOff_		= 2300;
declare hide constant StopSignal_		= 2653;
declare hide constant TrialStart_		= 1666;
declare hide constant FixError_			= 2750; //Must Check to be sure.
declare hide constant GoSaccade_		= 2751; //Must Check to be sure.
declare hide constant GoError_			= 2752; //Must Check to be sure.
declare hide constant NOGOWrong_		= 2753; //Must Check to be sure.
declare hide constant Abort_ 			= 2620;
declare hide constant Correct_ 			= 2600;
declare hide constant Distract_			= 2601;	
declare hide constant HighBet_ 			= 2602;	
declare hide constant LowBet_			= 2603;	
declare hide constant GOCorrect_ 		= 2755;
declare hide constant NOGOCorrect_ 		= 2756;
declare hide constant Reward_ 			= 2727;
declare hide constant Tone_				= 2001;
declare hide constant Error_tone		= 776;  //Strobe for Neuro Explorer
declare hide constant Reward_tone		= 777;	//Strobe for Neuro Explorer
declare hide constant Error_sacc		= 887;  //Strobe for Neuro Explorer
declare hide constant ExtraReward_ 		= 2777;
declare hide constant SoundOnReward_ 	= 2778;
declare hide constant SoundNoReward_ 	= 2779;
declare hide constant Eot_ 				= 1667;
declare hide constant CmanHeader_ 		= 1501;
declare hide constant MemHeader_		= 1502;
declare hide constant ChCmanHeader_		= 1503;
declare hide constant VisHeader_		= 1504;
declare hide constant AmpHeader_		= 1505;
declare hide constant GoNoGoHeader_		= 1506;
declare hide constant DelayHeader_		= 1507;
declare hide constant MaskBetHeader_	= 1508;
declare hide constant Identify_Room_	= 1500;
declare hide constant Stimulation_ 		= 666;
//Note that this is followed by a 1 or a 2 if MultElectrodeStimFlag is set depending on the stim channel
declare hide constant ZeroEyePosition_ 	= 2302;
declare hide constant VSyncSynced_		= 999; //This is a bit weird.  Looks like we are waiting to hear back from videosync that all commands are out of buffer?
//Note followed by another TTL == 2820 + trials[1] (looks like it classifies trial type)
declare hide constant Decide_ 			= 2811;
declare hide constant MouthBegin_ 		= 2655;
declare hide constant MouthEnd_ 		= 2656;
declare hide constant MapHeader_ 		= 1503;
declare hide constant FixWindow_ 		= 2770;
declare hide constant TargetWindow_		= 2771;

/* MUST CHECK ALL THAT FOLLOWS IN TRANSLATED VARIABLES (MY VERSION DIED WITHOUT NETWORK) */
declare hide constant Staircase_ 		= 2772;
declare hide constant Neg2Reinforcement_= 2773; //?????
declare hide constant Feedback_ 		= 2774; //????? 
declare hide constant RewardSize_ 		= 2927;
declare hide constant TrialInBlock 		= 2928;
// declare hide constant SendStimInfo_ 	= 7000; // MUST CHANGE. TOO BIG
declare hide constant SendPenatrInfo_ 	= 2929;
declare hide constant TargetPre_ 		= 2650; //?????
declare hide constant StopOn_ 			= 2654; //?????
declare hide constant StimFailed_ 		= 667;
//for VWM task
declare hide constant VWMHeader_	= 1509;
declare hide constant MemOn_		= 2201;
declare hide constant TestOn_		= 2202;
declare hide constant TestOff_		= 2203;

declare hide constant StartInfos_		= 2998;
declare hide constant EndInfos_			= 2999;
declare hide float 	  InfosZero			= 3000.0;


//--------------------------------------------------------------------------------------------------
// Figure out stimulus that will be needed on the next fixation trial and
// place it into video memory.
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011

							

declare FIX_PGS();                        										// see GRAPHS.pro

process FIX_PGS()                        										// see GRAPHS.pro
	{										
	// declare hide float 	targSize;   											// Global output will be sent as stobes...        										
	// declare hide int   	targColor;									
										
	// declare hide float	fixX;										
	// declare hide float	fixY;										
	
	// number the pgs that need to be drawn
	declare hide int   	blank       = 0;										
	declare hide int	fix      = 1;
	
	
	//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	// Calculate screen coordinates for stimuli on this trial								
	targSize         = sizeArray[targIndex];   													// Figure out the attributes of the current fix 
	targColor        = targIndex + 1;																// zero is reserved for black.  see SET_CLRS.pro							
													
	// fixX = cos(fixAngle) * fixAmp;														// find the center of the box in x and y space based on the angle and fixAmp...
	// fixY = sin(fixAngle) * fixAmp * -1;												
	// oMove(object_fix, fixX*deg2pix_X, fixY*deg2pix_Y);								// ...and move the animated graph object there.
	// oSetAttribute(object_fix, aSIZE, targSize*deg2pix_X, targSize*deg2pix_Y);							// while we are at it, resize fixation object on animated graph
	//oSetAttribute(object_fix, aSIZE, 1*deg2pix_X, 1*deg2pix_Y);									
	
	
	
	//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	// Draw pg 1
	// print("fix");
	dsendf("rw %d,%d;\n",fix,fix); 														// draw first pg of video memory
	dsendf("cl:\n");																			// clear screen
	spawnwait DRW_SQR(targSize, fixAngle, fixAmp, targColor, fill, deg2pix_X, deg2pix_Y);          	// draw fix
    
	
	//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	// Draw pg 0 (last is displayed first)	
	// print("blank"); 																			
	dsendf("rw %d,%d;\n",blank,blank);                                          				// draw the blank screen last so that it shows up first
	dsendf("cl:\n");                                                                            // clear screen (that's all)
	
	
	}//--------------------------------------------------------------------------------------------
// Run a fixation trial based on the variables calculated by SETF_TRL.pro and those 
// given by the user.
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011


declare FIXTRIAL();			// animated graph object

process FIXTRIAL()			// animated graph object
{


// Number the trial stages to make them easier to read below
declare hide int 	need_fix  	= 1;
declare hide int 	fixating  	= 2;


// Number the stimuli pages to make reading easier
declare hide int   	blank       = 0;
declare hide int	fix      = 1;

										
// Timing variables which will be used to time task
declare hide float  fix_time; 					
declare hide float	aquire_fix_time;	

// These variables make the while loop work
declare hide int	stage;

	
// Have to be reset on every iteration since 
// variable declaration only occurs at load time
trl_running 		= 1;
stage 				= need_fix;




																		// HERE IS WHERE THE FUN BEGINS
dsendf("vp %d\n",fix);												// flip the pg to the fix stim 
fix_time = time();  													// record the time
oSetAttribute(object_fix, aVISIBLE); 									// turn on the fix in animated graph	

while (trl_running)														// trials ending will set trl_running = 0
	{	
	
//--------------------------------------------------------------------------------------------
// STAGE need_fix (the fix is on, but the subject hasn't looked at it)
	if (stage == need_fix)
		{		
		if (In_Fixwin)													// If the eyes have entered the fixation window (before time, see below)...
			{
			aquire_fix_time = time();									// ...function call to time to note current time and...
			stage = fixating;											// ...advance to the next stage.
			}
		else if (time() > fix_time + saccTimeMax)					// But if time runs out...
			{
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen,...
			oSetAttribute(object_fix, aINVISIBLE); 					// ...remove fix from animated graph...
			trl_running = 0;											// ...and terminate the trial.
			}			
		}
		
		

//--------------------------------------------------------------------------------------------
// STAGE fixating (the subject is looking at the fix waiting for reward)		
	else if (stage == fixating)
		{
		if (!In_Fixwin)												// If the eyes stray out of the fix window...
			{
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_fix, aINVISIBLE); 					// ...remove fix from animated graph...
			print("broke");
			trl_running = 0;											// ...and terminate the trial.
			}
		else if (In_Fixwin && time() > 
				aquire_fix_time + targHoldtime) 						// But if the eyes are still in the window at end of holdtime...
			{
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_fix, aINVISIBLE); 					// ...remove fix from animated graph...
			spawn TONE(success_Tone_medR,toneDuration);				// give the secondary reinforcer tone
			spawn JUICE(juiceChannel,baseRewardDuration);				// YEAH BABY!  THAT'S WHAT IT'S ALL ABOUT!
			trl_running = 0;											// ...and terminate the trial.
			
			}
		}
		
		
				
	nexttick;
	}		
}//--------------------------------------------------------------------------------------------------
// process GNG_PGS(int targIndex, 
				// float fixSize, 
				// int fixColor, 
				// int signalColor, 
				// float screenWidth, 
				// float screenHeight, 
				// float pdLeft, 
				// float pdBottom, 
				// float pdSize);
// Figure out all stimuli that will be needed on the next go/no-go trial and
// place it all into video memory.
//
// 11-2011: Based on CMD_PGS 	-pgm


declare GNG_PGS();                       										// see GRAPHS.pro

process GNG_PGS()                        										// see GRAPHS.pro
	{										
											
	
	// number the pgs that need to be drawn
	declare hide int   	blank       = 0;										
	declare hide int	fixation_pd = 1;										
	declare hide int	fixation    = 2;										
	declare hide int	cue_pd   	= 3;										
	declare hide int	cue      	= 4;										
	declare hide int	target_pd   = 5;										
	declare hide int	target      = 6;										
//	declare hide int	signal_pd   = 5;										
//	declare hide int	signal      = 6;
	
	declare int changeStimulus = 1;
	declare int keepStimulus = 0;


	//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	// Calculate screen coordinates for stimuli on this trial								
	if (AutoTargetSizeFlag)
		{
		targSize        	 	= targAmp * TargetSizeConversion;   			// Figure out the attributes of the current target
		}
	else
		{
		targSize				= sizeArray[targIndex];
		}
	targColor        = targIndex + 1;																// zero is reserved for black.  see SET_CLRS.pro
													
	
	opposite = ((screenHeight/2)-pdBottom);														// Figure out angle and eccentricity of photodiode marker in pixels
	adjacent = ((screenWidth/2)-pdLeft);                                                         // NOTE: I am assuming your pd is in the lower left quadrant of your screen
	pdAmp = sqrt((opposite * opposite) + (adjacent * adjacent));
	pdAngle = rad2deg(atan (opposite / adjacent));
	pdAngle = pdAngle + 180; 																	//change this for different quadrent or write some code for flexibility
	
	
	//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	// Draw pg 1
	// print("fixation with photodiode");
	dsendf("rw %d,%d;\n",fixation_pd,fixation_pd); 												// draw first pg of video memory
	dsendf("cl:\n");																			// clear screen
	spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
	spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
    
	//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	// Draw pg 2	  
	// print("fixation");
	dsendf("rw %d,%d;\n",fixation,fixation);   													// draw second pg of video memory                                       
	dsendf("cl:\n");																			// clear screen
	spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
    nexttick;

	//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	// Draw pg 3
	// print("cue with photodiode");
	dsendf("rw %d,%d;\n",cue_pd,cue_pd); 												// draw first pg of video memory
	dsendf("cl:\n");																			// clear screen
	spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
	spawnwait DRW_GNG(changeStimulus);   	// draw fixation point
	spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
    
	//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	// Draw pg 4	  
	// print("cue");
	dsendf("rw %d,%d;\n",cue,cue);   													// draw second pg of video memory                                       
	dsendf("cl:\n");																			// clear screen
	spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
	spawnwait DRW_GNG(changeStimulus);   	// draw fixation point
    nexttick;
	
	//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	// Draw pg 5	 
	// print("target with photodiode");
	dsendf("rw %d,%d;\n",target_pd,target_pd);  												// draw pg 3                                        
	dsendf("cl:\n");																			// clear screen
	spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
	spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y); // draw fixation point
	spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
    nexttick;
	
    //--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	// Draw pg 6	  
	// print("target");
	dsendf("rw %d,%d;\n",target,target);  														// draw pg 4                                        
	dsendf("cl:\n");																			// clear screen
	spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);         	// draw target
	spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
    nexttick;
	
	//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	// Draw pg 5 
	// print("signal with photodiode");
//	dsendf("rw %d,%d;\n",signal_pd,signal_pd);    												// draw pg 5                                      
//	dsendf("cl:\n");																			// clear screen
//	spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);         	// draw target
//	if (Classic)
//	spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, signalColor, fill, deg2pix_X, deg2pix_Y);   		// draw stop signal/ignore stim
//	if (!Classic)																				// if we are doing stop-signal 2.0 (not classic)
//		{
//		spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, open, deg2pix_X, deg2pix_Y); // draw fixation point
//		}
//	spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
  //  nexttick;
	
    //--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	// Draw pg 6	 
	// print("signal");
//	dsendf("rw %d,%d;\n",signal,signal);   														// draw pg 6                                       					
//	dsendf("cl:\n");																			// clear screen
//	spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
//	spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, signalColor, fill, deg2pix_X, deg2pix_Y);   		// draw stop signal/ignore stim
//	if (!Classic)																				// if we are doing stop-signal 2.0 (not classic)
//		{
//		spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, open, deg2pix_X, deg2pix_Y); // draw fixation point
//		}
//	nexttick;
	
	//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	// Draw pg 0 (last is displayed first)	
	// print("blank"); 																			
	dsendf("rw %d,%d;\n",blank,blank);                                          				// draw the blank screen last so that it shows up first
	dsendf("cl:\n");                                                                            // clear screen (that's all)
	
	
	}//--------------------------------------------------------------------------------------------
// Run a GO/NO-GO trial based on the variables calculated by SETC_TRL.pro and those 
// given by the user.
//


declare GNGTRIAL();			

process GNGTRIAL()        		
	{
	
	
	// Number the trial stages to make them easier to read below
	declare hide int 	need_fix  	= 1;
	declare hide int 	fixating  	= 2;
	declare hide int 	cue_on   	= 3;
	declare hide int 	targ_on   	= 4;
	declare hide int 	in_flight 	= 5;
	declare hide int 	on_target 	= 6;	
	declare hide int 	stage;
	
	// Number the stimuli pages to make reading easier
	declare hide int   	blank       = 0;
	declare hide int	fixation_pd = 1;
	declare hide int	fixation    = 2;
	declare hide int	cue_pd 		= 3;
	declare hide int	cue    		= 4;
	declare hide int	target_pd   = 5;
	declare hide int	target      = 6;

		                                        
	// Timing variables that will be used to time task
	declare hide float 	fix_spot_time; 					
	declare hide float 	cue_time; 					
	declare hide float  targ_time; 					
	declare hide float  saccade_time;
	declare hide float 	aquire_fix_time;
	declare hide float	aquire_targ_time;	
	
	
	// Have to be reset on every iteration since 
	// variable declaration only occurs at load time
	trl_running 		= 1;
	stage 				= need_fix;
	
	// Tell the user what's up
	printf(" \n");
	printf("#: %d",nTrial);
	printf(" (%d correct) ",nTrialComplete);
	if (trialType == goTrial)
		{
		printf("  GO\n");
		}
	if (trialType == nogoTrial)
		{
		printf("  NO-GO\n");
		}
		printf("pre-cue holdtime = %d\n",preTargHoldtime);
		printf("post-cue holdtime = %d\n",postTargHoldtime);
		printf("        Go Proportion = %.2d\n", goCheckerProp);
	
	
																			// HERE IS WHERE THE FUN BEGINS
	Event_fifo[Set_event] = TrialStart_;									// queue TrialStart_ strobe
	Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
	dsendf("vp %d\n",fixation_pd);											// flip the pg to the fixation stim with pd marker
	fix_spot_time = time();  												// record the time
	Event_fifo[Set_event] = FixSpotOn_;										// queue strobe
	Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
	dsendf("XM RFRSH:\n"); 													// wait one vertical retrace
	dsendf("vp %d\n",fixation);												// flip the pg to the fixation stim without pd marker
	oSetAttribute(object_fix, aVISIBLE); 									// turn on the fixation point in animated graph
	
	
	while (trl_running)														// trials ending will set trl_running = 0
		{	
		
	//--------------------------------------------------------------------------------------------
	// STAGE need_fix (the fixation point is on, but the subject hasn't looked at it)
		if (stage == need_fix)
			{		
			if (In_FixWin)													// If the eyes have entered the fixation window (before time, see below)...
				{
				aquire_fix_time = time();									// ...function call to time to note current time and...
				trialStartTime = aquire_fix_time;							// Global output
				Event_fifo[Set_event] = Fixate_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				// if (time() > aquire_fix_time + 50)
				// {
				stage = fixating;						// ...advance to the next stage.
				}
			else if (time() > fix_spot_time + allowFixTime)				// But if time runs out...
				{
				trialOutcome = noFix;    									// TRIAL OUTCOME ERROR (no fixation)
				LastOutcome = noChange;								// Don't change SSD
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen,...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Aborted (no fixation)\n");							// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}			
			}
			
			

	//--------------------------------------------------------------------------------------------
	// STAGE fixating (the subject is looking at the fixation point waiting for cue onset)		
		else if (stage == fixating)
			{
			if (!In_FixWin && time() > aquire_fix_time + 100)													// If the eyes stray out of the fixation window...
				{
				trialOutcome = brokeFix;									// TRIAL OUTCOME ERROR (broke fixation)
				lastOutcome = noChange;								// Don't change SSD
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}
			else if (In_FixWin && time() > aquire_fix_time + preTargHoldtime)	// But if the eyes are still in the window at end of holdtime...
				{
				dsendf("vp %d\n", target_pd);								// ...flip the pg to the target with pd marker...	
				targ_time = time(); 										// ...record the time...
				dsendf("XM RFRSH:\n"); 										// ...wait one vetical retrace...
				dsendf("vp %d\n",target);									// ...flip the pg to the target without pd marker.
				oSetAttribute(object_targ, aVISIBLE); 					// ...remove target from animated graph...
				
					
				Event_fifo[Set_event] = Target_;							// Queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				
																			// Now the animated graphs have to catch up (seperate so that stim timing stays tight)					
				stage = targ_on;											// Advance to the next trial stage.				
				}
			}
			
			

	//--------------------------------------------------------------------------------------------
	// STAGE targ_on (the subject is looking at the target waiting for cue onset)		
		else if (stage == targ_on)
			{
			if (!In_FixWin)													// If the eyes stray out of the fixation window...
				{
				trialOutcome = brokeFix;									// TRIAL OUTCOME ERROR (broke fixation)
				lastOutcome = noChange;								// Don't change SSD
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}
			else if (In_FixWin && time() > targ_time + postTargHoldtime)	// But if the eyes are still in the window at end of holdtime...
				{
				// if (trialType == nogoTrial)
				// spawn JUICE(juiceChannel, 100);
				dsendf("vp %d\n",cue_pd);								// ...flip the pg to the target with pd marker...	
				cue_time = time(); 										// ...record the time...
				dsendf("XM RFRSH:\n"); 										// ...wait one vetical retrace...
				dsendf("vp %d\n",cue);									// ...flip the pg to the target without pd marker.
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				Event_fifo[Set_event] = Cue_;							// Queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
									
				stage = cue_on;											// Advance to the next trial stage.				
				}
			}
			
			

	//--------------------------------------------------------------------------------------------
	// STAGE cue_on (the target has been presented but the subject is still fixating)		
		else if (stage == cue_on)
			{		
			if (!In_FixWin)													// If the eyes leave the fixation window...
				{															// ...we have a saccade, so...
				saccade_time = time();										// ...record the time...
				Event_fifo[Set_event] = Saccade_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				printf("                          rt = %d\n",saccade_time - cue_time);	// ...tell the user whats up...
				stage = in_flight;											// ...and advance to the next stage.
				if (trialType == nogoTrial)
					{
					spawn TONE(200,400);
					}
				}
			else if (In_FixWin &&  											// But if no saccade occurs...
				time() > cue_time + saccTimeMax && 					// ...and time for a saccade runs out...
				trialType == goTrial)				// ...and a saccade was supposed to be made.
				{
				trialOutcome = goIncorrect;           							// TRIAL OUTCOME ERROR (incorrect go trial)
				lastOutcome = failure;										// 
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (no saccade)\n");								// ...tell the user whats up...
				// spawn SVR_BELL();
				trl_running = 0;											// ...and terminate the trial.
				}				
			else if (In_FixWin &&											// But if no saccade occurs...
				time() > cue_time + holdStopDuration && 				// ...and time for a saccade runs out...
				trialType == nogoTrial)										// ...and a saccade was NOT supposed to be made...
				{
				trialOutcome = nogoCorrect;   								// TRIAL OUTCOME CORRECT (canceled trial)
				lastOutcome = success;									// set the global for staircasing...
				dsendf("vp %d\n",blank);									// ...flip the pg to remove target...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				Event_fifo[Set_event] = Correct_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				printf("Correct (no-go)\n");								// ...tell the user whats up...
				trl_running = 0;  											// ...and terminate the trial.
				}		
			}
			
			
			
	//--------------------------------------------------------------------------------------------
	// STAGE in_flight (eyes have left fixation window but have not entered target window)		
		else if (stage == in_flight)
			{
			if (In_TargWin)													// If the eyes get into the target window...
				{
				aquire_targ_time = time();									// ...record the time...
				Event_fifo[Set_event] = Decide_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				stage = on_target;											// ...and advance to the next stage of the trial.
				if (trialType == nogoTrial)									// But if a saccade was the wrong thing to do...
					{												
					Event_fifo[Set_event] = Error_sacc;						// ...queue strobe for Neuro Explorer
					Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.
					}
				else 														// Otherwise...
					{								
					Event_fifo[Set_event] = Correct_;					// ...queue strobe for Neuro Explorer
					Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.					
					}
				}
			else if (time() > saccade_time + saccDurationMax)				// But, if the eyes are out of the target window and time runs out...
				{
				trialOutcome = saccOut;   									// TRIAL OUTCOME ERROR (innacurrate saccade)
				if (trialType == nogoTrial)									// But if a saccade was the wrong thing to do...
					{												
					lastOutcome = failure;								// ...record the failure.
					}
				else 														// Otherwise...
					{								
					lastOutcome = noChange;							// ...make sure that the last outcome is cleared.						
					}
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (inaccurate saccade)\n");						// ...tell the user whats up...
				trl_running = 0; 											// ...and terminate the trial.
				}
			}
		
		
		
	//--------------------------------------------------------------------------------------------
	// STAGE on_target (eyes have entered the target window.  will they remain there for duration?)	
		else if (stage == on_target)
			{
			if (!In_TargWin)												// If the eyes left the target window...
				{			
				trialOutcome = brokeTarg;									// TRIAL OUTCOME ERROR (broke target fixation)
				if (trialType == nogoTrial)									// But if a saccade was the wrong thing to do...
					{												
					lastOutcome = failure;
					}
				else 														// Otherwise...
					{								
					lastOutcome = noChange;							// ...make sure that the last outcome is cleared.						
					}
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (broke target fixation)\n");					// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}		
			else if (In_TargWin  											// But if the eyes are still in the target window...
				&&  time() > aquire_targ_time + targHoldtime)				// ...and the target hold time is up...
				{
				if (trialType == goTrial || trialType == ignoreTrial)			// ...and a saccade was the correct thing to do...
					{
					trialOutcome = goTarg;								//TRIAL OUTCOME CORRECT (correct go trial)
					lastOutcome = success;									// 
					Event_fifo[Set_event] = Correct_;						// ...queue strobe...
					Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue...
					printf("Correct (saccade)\n");							// ...tell the user whats up...
					}
				else if (trialType == nogoTrial)								// But if a saccade was the wrong thing to do...
					{
					trialOutcome = nogoTarg;								//TRIAL OUTCOME ERROR (noncanceled trial)
					lastOutcome = failure;
					printf("Error (noncanceled)\n");						// ...tell the user whats up...
					}														// Either way we are done, so...
				dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				trl_running = 0;											// ...and terminate the trial.
				}			
			}
			
		if (Move_ct > 0)
			{
			trialOutcome = bodyMove;   									// TRIAL OUTCOME ABORTED (the body was moving)
			lastOutcome = noChange;								// ...make sure that the last outcome is cleared.	
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Aborted (body movement)\n");							// ...tell the user whats up...
			trl_running = 0; 											// ...and terminate the trial.
			}
			
		nexttick;
		}
	}//-------------------------------------------------------------------------------------------------------------------------
// perform a few checks to try to guard against poor user input

declare GOODVARS();

process GOODVARS()
{	
declare hide int i, j;
declare float sumDist, trialRateFactor;


//---------------------------------------------------------------------------------------------------------------------------	
if (state == stateCMD)
	{
	if (goPct				
		+ stopPct
		+ ignorePct != 100)
		{
		printf("WARNING!!!\n");
		printf("Trial weights do not sum to 100.\n");
		printf("CHANGE PARAMETERS BEFORE RECORDING\n");
		State = 0;  					// hook the user back into IDLE()
		system("dpop");					// clear dialogs
		}
	
	
	i = 0;								// count up the target locations based on sizeArray
	nTarg = 0;
	while(i < 8)
		{
		if(sizeArray[i] != 0)
			{
			nTarg = nTarg + 1;
			}
		i = i + 1;
		nexttick;
		}
		
	i = 2;								// count up the levels of discrimination
	nDiscriminate = 2;							// want at least 2 levels of discrimination (can be 1 and 0)
	while(i < 10)
		{
		if(targ1PropArray[i] != 0)
			{
			nDiscriminate = nDiscriminate + 1;
			}
		i = i + 1;
		nexttick;
		}

	i = 0;								// count up the SSDs
	nSSD = 0;
	while(i < 12)
		{
		if(ssdArray[i] != 0)
			{
			nSSD = nSSD + 1;
			}
		i = i + 1;
		nexttick;
		}
	
	ssdMax = ssdArray[nSSD-1];
	ssdMax = ceil(ssdMax * (1000.0/screenRefreshRate));
	ssdMin = ssdArray[0];
	ssdMin = ceil(ssdMin * (1000.0/screenRefreshRate));
	
	if (ssdMax > saccTimeMax)
		{
		printf("WARNING!!!\n");
		printf("SSDs exceed Max time allowed...\n");
		printf("...for saccade to target.\n");
		printf("CHANGE PARAMETERS BEFORE RECORDING\n");
		State = 0;  					// hook the user back into IDLE()
		system("dpop");					// clear dialogs
		}
	
	if(trialDuration < holdtimeMax
					+ ssdMax
					+ holdStopDuration
					+ toneDuration
					+ rewardDelay
					+ baseRewardDuration * 2
					+ 100) 				// maximum time a trial can take including 100ms for iti calculations (generous)
		{
		trialDuration = holdtimeMax
					+ ssdMax
					+ holdStopDuration
					+ toneDuration
					+ rewardDelay
					+ baseRewardDuration * 2
					+ 100;
		printf("WARNING!!!\n");
		printf("Trial length too short\n");
		printf("Extending trial length to %d\n",trialDuration);
		}
		
	}
	
//---------------------------------------------------------------------------------------------------------------------------	


//---------------------------------------------------------------------------------------------------------------------------	
if (state == stateCCM)
	{
	if (goPct				
		+ stopPct
		+ ignorePct != 100)
		{
		printf("WARNING!!!\n");
		printf("Trial weights do not sum to 100.\n");
		printf("CHANGE PARAMETERS BEFORE RECORDING\n");
		State = 0;  					// hook the user back into IDLE()
		system("dpop");					// clear dialogs
		}
	
	
	i = 0;								// count up the target locations based on sizeArray
	nTarg = 0;
	while(i < 8)
		{
		if(sizeArray[i] != 0)
			{
			nTarg = nTarg + 1;
			}
		i = i + 1;
		nexttick;
		}


	i = 0;								// count up the levels of discrimination
	nDiscriminate = 0;							// want at least 2 levels of discrimination (can be 1 and 0)
	sumDist = 0.0;						// will be used below to calculate trial rate within each level of discim
	while(i < 10)
		{
		if (targ1PropArray[i] == 0 && i == 0)
			{
			nDiscriminate = nDiscriminate + 1;
			sumDist = sumDist + trialDist[i];
			}		
		else if(targ1PropArray[i] != 0)
			{
			nDiscriminate = nDiscriminate + 1;
			sumDist = sumDist + trialDist[i];
			}
		i = i + 1;
		nexttick;
		}

	maxDiscriminate = targ1PropArray[nDiscriminate-1];
	minDiscriminate = targ1PropArray[0];
	
	
	
	// Calculate the absolute trial rate within each level of discrimination
	trialRateFactor = 1.0 / sumDist;
	i = 0;
	while (i < nDiscriminate)
		{
		trialRate[i] = trialDist[i] * trialRateFactor;
		i = i + 1;
		}
	// Calculate the boundaries between trial rates. This will be used in SETTRIAL.pro to choose which level of discrimnation to use
	i = 1;
	trialRateBound[0] = trialRate[0];
	while (i < nDiscriminate)
		{
		trialRateBound[i] = trialRateBound[i-1] + trialRate[i]; 
		printf("%d\n", trialRateBound[i]);
		i = i + 1;
		}



	i = 0;								// count up the SSDs
	nSSD = 0;
	while(i < 12)
		{
		if(ssdArray[i] != 0)
			{
			nSSD = nSSD + 1;
			}
		i = i + 1;
		nexttick;
		}
	
	ssdMax = ssdArray[nSSD-1];
	ssdMax = ceil(ssdMax * (1000.0/screenRefreshRate));
	ssdMin = ssdArray[0];
	ssdMin = ceil(ssdMin * (1000.0/screenRefreshRate));
	
	if (ssdMax > saccTimeMax)
		{
		printf("WARNING!!!\n");
		printf("SSDs exceed Max time allowed...\n");
		printf("...for saccade to target.\n");
		printf("CHANGE PARAMETERS BEFORE RECORDING\n");
		State = 0;  					// hook the user back into IDLE()
		system("dpop");					// clear dialogs
		}
	
	// Reset all the counters in case this isn't the first run of choice countermanding (so inhibition and psychometric functions reset)
	i = 0;
	while (i < 10)
		{
		j = 0;
		while (j < 10)
			{
			nTrialPsySSD[i,j] 	= 0;
			nSaccPsySSD[i,j] 	= 0;
			nTarg1PsySSD[i,j] 	= 0;
			j = j + 1;
			}
		i = i + 1;
		}
		
		
	if(trialDuration < holdtimeMax
					+ ssdMax
					+ holdStopDuration
					+ toneDuration
					+ rewardDelay
					+ baseRewardDuration * 2
					+ 100) 				// maximum time a trial can take including 100ms for iti calculations (generous)
		{
		trialDuration = holdtimeMax
					+ ssdMax
					+ holdStopDuration
					+ toneDuration
					+ rewardDelay
					+ baseRewardDuration * 2
					+ 100;
		printf("WARNING!!!\n");
		printf("Trial length too short\n");
		printf("Extending trial length to %d\n",trialDuration);
		}
	}


//---------------------------------------------------------------------------------------------------------------------------	
if (state == stateGNG)
	{
	if (goPct				
		+ NogoPct != 100)
		{
		printf("WARNING!!!\n");
		printf("Trial weights do not sum to 100.\n");
		printf("CHANGE PARAMETERS BEFORE RECORDING\n");
		State = 0;  					// hook the user back into IDLE()
		system("dpop");					// clear dialogs
		}
	
	
	i = 0;								// count up the target locations based on sizeArray
	nTarg = 0;
	while(i < 8)
		{
		if(sizeArray[i] != 0)
			{
			nTarg = nTarg + 1;
			}
		i = i + 1;
		nexttick;
		}
		
	i = 2;								// count up the levels of discrimination
	nDiscriminate = 2;							// want at least 2 levels of discrimination (can be 1 and 0)
	while(i < 10)
		{
		if(goPropArray[i] != 0)
			{
			nDiscriminate = nDiscriminate + 1;
			}
		i = i + 1;
		nexttick;
		}
	
	maxDiscriminate = goPropArray[nDiscriminate-1];
	minDiscriminate = goPropArray[0];
	
	
	if(trialDuration < holdtimeMax
					+ holdStopDuration
					+ toneDuration
					+ rewardDelay
					+ baseRewardDuration * 2
					+ 100) 				// maximum time a trial can take including 100ms for iti calculations (generous)
		{
		trialDuration = holdtimeMax
					+ holdStopDuration
					+ toneDuration
					+ rewardDelay
					+ baseRewardDuration * 2
					+ 100;
		printf("WARNING!!!\n");
		printf("Trial length too short\n");
		printf("Extending trial length to %d\n",trialDuration);
		}
	}
	
//---------------------------------------------------------------------------------------------------------------------------	

	
if (state == stateVIS ||
	state == stateMEM ||
	state == stateDEL)
	{
	i = 0;								// count up the target locations based on sizeArray
	nTarg = 0;
	while(i < 8)
		{
		if(sizeArray[i] != 0)
			{
			nTarg = nTarg + 1;
			}
		i = i + 1;
		nexttick;
		}
	
	}

if (state == stateAMP)
	{
	i = 0;								// count up the target locations based on sizeArray
	nTarg = 0;
	while(i < 8)
		{
		if(ampArray[i] != 0)
			{
			nTarg = nTarg + 1;
			}
		i = i + 1;
		nexttick;
		}
	
	}

if (trialDuration < holdtimeMax
			+ ssdMax
			+ holdStopDuration
			+ toneDuration
			+ rewardDelay
			+ baseRewardDuration * 2
			+ 100) 					// maximum time a trial can take including 100ms for iti calculations (generous)
	{
	trialDuration = holdtimeMax
				+ ssdMax
				+ holdStopDuration
				+ toneDuration
				+ rewardDelay
				+ baseRewardDuration * 2
				+ 100;
	printf("WARNING!!!\n");
	printf("Trial length too short\n");
	printf("Extending trial length to %d\n",trialDuration);
	}
	
	
if (Set_tones == 1)
	{
	Success_Tone_bigR		= 3200;	// positive secondary reinforcer in Hz (large reward)
	Success_Tone_medR		= 1600;	// positive secondary reinforcer in Hz (medium reward)
	Success_Tone_smlR		= 800;	// positive secondary reinforcer in Hz (small reward)		
	Failure_Tone_smlP		= 400;	// negative secondary reinforcer in Hz (short timeout)
	Failure_Tone_medP		= 200;	// negative secondary reinforcer in Hz (medium timeout)
	Failure_Tone_bigP		= 100;	// negative secondary reinforcer in Hz (long timeout)
	}
else
	{
	Success_Tone_bigR		= 100;	// positive secondary reinforcer in Hz (large reward)
	Success_Tone_medR		= 200;	// positive secondary reinforcer in Hz (medium reward)
	Success_Tone_smlR		= 400;	// positive secondary reinforcer in Hz (small reward)		
	Failure_Tone_smlP		= 800;	// negative secondary reinforcer in Hz (short timeout)
	Failure_Tone_medP		= 1600;	// negative secondary reinforcer in Hz (medium timeout)
	Failure_Tone_bigP		= 3200;	// negative secondary reinforcer in Hz (long timeout)
	}			
	





//---------------------------------------------------------------------------------------------------------------------------			
if (state == stateMCM)
	{

	if (maskPct				
		+ betPct
		+ retroPct
		+ proPct != 100)
		{
		printf("WARNING!!!\n");
		printf("Trial weights do not sum to 100.\n");
		printf("CHANGE PARAMETERS BEFORE RECORDING\n");
		state = stateNoTask;  					// hook the user back into IDLE()
		system("dpop");					// clear dialogs
		}


	i = 0;								// count up the target locations based on maskAmpArray (up to 4 target locations for now)
	nTarg = 0;
	while(i < 4)
		{
		if(maskAmpArray[i] != 0)
			{
			nTarg = nTarg + 1;
			}
		i = i + 1;
		nexttick;
		}
	}

	i = 0;								// count up the SOAs
	nSOA = 0;
	while(i < 10)
		{
		if(soaArray[i] != 0)
			{
			nSOA = nSOA + 1;
			}
		i = i + 1;
		nexttick;
		}




}
	// Modified version of OBJECT.pro which sets globals neccessary for use with
// animated graphs and also sets graphs up for countermanding task.
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011
// 11-2011: Integrated choice countermanding task into ALL_PROS.pro. -pgm

// Graph references used in oCreate() and oSetGraph()

hide constant gLEFT           =0;             						// Left graph
hide constant gRIGHT          =1;             						// Right graph
						
// Object types for use with oCreate()						
						
hide constant tPOINT          =1;             						// A single pixel
hide constant tBOX            =2;             						// A rectangle
hide constant tCROSS          =3;             						// '+' Horizontal/Vertical Cross
hide constant tXCROSS         =4;             						// 'x' Diagonal Cross
hide constant tELLIPSE        =5;             						// An ellipse (VideoSYNC only)
						
// Object attributes used by oSetAttribute()						
						
hide constant aXOR            =1;             						// Erase object when moving
hide constant aREPLACE        =2;             						// Replace pixels
hide constant aVISIBLE        =3;             						// Make object visible
hide constant aINVISIBLE      =4;             						// Don't draw object
hide constant aFILLED         =5;             						// Filled rectangle
hide constant aUNFILLED       =6;             						// Hollow rectangle
hide constant aSIZE           =7;             						// Resize box, cross, plus
			
// Graph attributes used by oSetGraph()			
			
hide constant aRANGE          =1;									// Define graph coordinate system
hide constant aTITLE          =2;									// Define graph title
hide constant aCLEAR          =3;									// Clear graph
			
declare hide object_fixwin,											// Eye and Box objects (left graph)
			object_eye,
			object_targwin,
			object_distwin,  										// distractor window, for choice countermanding task
			object_chkrwin,  										// checkered stimulus window, for choice countermanding task
			object_fix,
			object_targ,
			object_checker,
			object_distwin1,
			object_distwin2,
			object_distwin3,
			object_highBet,
			object_lowBet,
			object_highBetwin,
			object_lowBetwin;
			                 	  
declare hide object_ssd0 ;
declare hide object_ssd1 ;
declare hide object_ssd2 ;
declare hide object_ssd3 ;
declare hide object_ssd4 ;
declare hide object_ssd5 ;
declare hide object_ssd6 ;
declare hide object_ssd7 ;
declare hide object_ssd8 ;
declare hide object_ssd9 ;
declare hide object_ssd10;
declare hide object_ssd11;


declare hide object_psy0;
declare hide object_psy1;
declare hide object_psy2;
declare hide object_psy3;
declare hide object_psy4;
declare hide object_psy5;
declare hide object_psy6;
declare hide object_psy7;
declare hide object_psy8;
declare hide object_psy9;


declare GRAPHS();

process GRAPHS()
	{
	
	declare hide int left, right, down, up;
	
	nObject = object_psy9;  // keep track of how many objects there are so they can easily be destroyed when exiting a task
	
	oSetGraph(gleft, aCLEAR);
	
	// SETUP UP TARGET & EYE OBJECTS IN LEFT GRAPH
	left 	= screenPixelX/-2;
	right 	= screenPixelX/2;
	up 		= screenPixelY/-2;
	down 	= screenPixelY/2;
	
    oSetGraph(gleft, aRANGE, left, right, up, down);				// Object graph virt. coord
	oSetGraph(gleft, aTITLE, "*** TASK ***");						// Graph title
				
    object_fixwin = oCreate(tBOX, gLEFT, 0, 0);						// Create fix window object
    oSetAttribute(object_fixwin, aINVISIBLE);						// Not visible yet	
				
	object_targwin = oCreate(tBOX, gLEFT, 0, 0);					// Create target window object
    oSetAttribute(object_targwin, aINVISIBLE);						// Not visible yet
	
	// Have to inclued choice countermanding checker stimulus window and 2nd target windw here
	// (since GRAPHS.pro is called early in ALL_PROS.pro), but they don't get drawn if running regular countermanding task
	object_distwin = oCreate(tBOX, gLEFT, 0, 0);					// Create distractor window object
	oSetAttribute(object_distwin, aINVISIBLE);						// Not visible yet

	object_chkrwin = oCreate(tBOX, gLEFT, 0, 0);					// Create checkered stimulus window object
	oSetAttribute(object_chkrwin, aINVISIBLE);						// Not visible yet	

	object_fix = oCreate(tBOX, gLEFT, 0, 0);						// Create fix object
    oSetAttribute(object_fix,aFILLED);								// Draw it filled
	oSetAttribute(object_fix, aINVISIBLE);							// Not visible yet	
				
	object_targ = oCreate(tBOX, gLEFT, 0, 0);						// Create target object
	oSetAttribute(object_targ,aFILLED);								// Draw it filled
    oSetAttribute(object_targ, aINVISIBLE);							// Not visible yet
	
	object_checker = oCreate(tBOX, gLEFT, 0, 0);						// Create target object
	oSetAttribute(object_checker,aFILLED);								// Draw it filled
    oSetAttribute(object_checker, aINVISIBLE);							// Not visible yet

	object_distwin1 = oCreate(tBOX, gLEFT, 0, 0);						// Create target object
    oSetAttribute(object_distwin1, aINVISIBLE);							// Not visible yet
	
	object_distwin2 = oCreate(tBOX, gLEFT, 0, 0);						// Create target object
    oSetAttribute(object_distwin2, aINVISIBLE);							// Not visible yet
	
	object_distwin3 = oCreate(tBOX, gLEFT, 0, 0);						// Create target object
    oSetAttribute(object_distwin3, aINVISIBLE);							// Not visible yet
	
	object_highBetwin = oCreate(tBOX, gLEFT, 0, 0);						// Create target object
    oSetAttribute(object_highBetwin, aINVISIBLE);							// Not visible yet
	
	object_lowBetwin = oCreate(tBOX, gLEFT, 0, 0);						// Create target object
    oSetAttribute(object_lowBetwin, aINVISIBLE);							// Not visible yet
	
	object_highBet = oCreate(tBOX, gLEFT, 0, 0);						// Create target object
	oSetAttribute(object_highBet,aFILLED);								// Draw it filled
    oSetAttribute(object_highBet, aINVISIBLE);							// Not visible yet
	
	object_lowBet = oCreate(tBOX, gLEFT, 0, 0);						// Create target object
	oSetAttribute(object_lowBet,aFILLED);								// Draw it filled
    oSetAttribute(object_lowBet, aINVISIBLE);							// Not visible yet

    object_eye = oCreate(tCross, gLEFT, 2*deg2pix_X, 2*deg2pix_Y);	// Create EYE object
	oSetAttribute(object_eye, aVISIBLE);							// It's always visible
	

	nObject = object_eye;
	
	
	
	
	
	}		//-------------------------------------------------------------------------------------------------------------------
// Records all of the parameters for a countermanding trial.  Should be sent during the inter trial interval while
// the communication lines are clear (no rdx communication with vdosync).  
// NOTES:
// 1) The order of these params is very important.  Matlab translation code identifies these parameters based on their
// order, so if you add more events, make sure to keep them in the same order in the matlab translation code.  (They 
// are currently in alphabetical order based on their Matlab variable names so that they are recorded in Infos_ in
// alphabetical order.
// 2) This process relies heavily on globals (since it is grabbing stuff from all over the protocol).
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011
// 11-2011: Integrated choice countermanding task into ALL_PROS.pro. -pgm


declare INFOS();

process INFOS()
{
declare int stopColor_r, stopColor_g, stopColor_b;
declare int ignoreColor_r, ignoreColor_g, ignoreColor_b;
declare int fixColor_r, fixColor_g, fixColor_b;
declare int targColor_r, targColor_g, targColor_b;
declare int targ1CheckerColor_r, targ1CheckerColor_g, targ1CheckerColor_b; 	// (choice countermanding)
declare int targ2CheckerColor_r, targ2CheckerColor_g, targ2CheckerColor_b;		// (choice countermanding)
declare int goCheckerColor_r, goCheckerColor_g, goCheckerColor_b; 	// (choice countermanding)
declare int nogoCheckerColor_r, nogoCheckerColor_g, nogoCheckerColor_b;		// (choice countermanding)
declare int maskColor_r, maskColor_g, maskColor_b;		// (choice countermanding)
declare int highBetColor_r, highBetColor_g, highBetColor_b;		// (choice countermanding)
declare int lowBetColor_r, lowBetColor_g, lowBetColor_b;		// (choice countermanding)
declare int betFixColor_r, betFixColor_g, betFixColor_b;		// (choice countermanding)
declare int proFixColor_r, proFixColor_g, proFixColor_b;		// (choice countermanding)
declare int iChecker;

stopColor_r	= stopColorArray[0];
stopColor_g	= stopColorArray[1];
stopColor_b	= stopColorArray[2];
					 
ignoreColor_r	= ignoreColorArray[0];
ignoreColor_g	= ignoreColorArray[1];
ignoreColor_b	= ignoreColorArray[2];

fixColor_r	= fixColorArray[0];
fixColor_g	= fixColorArray[1];
fixColor_b	= fixColorArray[2];
					
targColor_r		= targColorArray[targIndex,0];
targColor_g		= targColorArray[targIndex,1];
targColor_b		= targColorArray[targIndex,2];

targ1CheckerColor_r	= Targ1SquareColor[0];			// (choice countermanding)
targ1CheckerColor_g	= Targ1SquareColor[1];			
targ1CheckerColor_b	= Targ1SquareColor[2];

targ2CheckerColor_r		= Targ2SquareColor[0];			// (choice countermanding)
targ2CheckerColor_g		= Targ2SquareColor[1];
targ2CheckerColor_b		= Targ2SquareColor[2];

goCheckerColor_r	= goSquareColor[0];			// (go/no-go)
goCheckerColor_g	= goSquareColor[1];			
goCheckerColor_b	= goSquareColor[2];

nogoCheckerColor_r		= noGoSquareColor[0];			// (go/no-go)
nogoCheckerColor_g		= noGoSquareColor[1];
nogoCheckerColor_b		= noGoSquareColor[2];

maskColor_r		= maskColorArray[0];			// (metacog)
maskColor_g		= maskColorArray[1];
maskColor_b		= maskColorArray[2];

highBetColor_r		= highBetColorArray[0];			// (metacog)
highBetColor_g		= highBetColorArray[1];
highBetColor_b		= highBetColorArray[2];

lowBetColor_r		= lowBetColorArray[0];			// (metacog)
lowBetColor_g		= lowBetColorArray[1];
lowBetColor_b		= lowBetColorArray[2];

betFixColor_r		= betFixColorArray[0];			// ((metacog)
betFixColor_g		= betFixColorArray[1];
betFixColor_b		= betFixColorArray[2];

proFixColor_r		= proFixColorArray[0];			// (metacog)
proFixColor_g		= proFixColorArray[1];
proFixColor_b		= proFixColorArray[2];






Event_fifo[Set_event] = StartInfos_;								// Let Matlab know that trial infos are going to start streaming in...
Set_event = (Set_event + 1) % Event_fifo_N;							// ...incriment event queue.
	
//---------------------------------------------------------------------------------------------------------------------------------------
	Event_fifo[Set_event] = InfosZero + allowFixTime;			// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + holdStopDuration;					// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + ssd;					// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + targIndex;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + expoJitterFlag;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + toneStopFailure;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + (fixWinSize * 100);		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + fixColor_b;			// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + fixColor_g;			// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + fixColor_r;			// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
		
	Event_fifo[Set_event] = InfosZero + (fixSize * 100);		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + fixedTrialDuration;			// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + (goPct * 100);			// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + ignoreColor_b;			// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + ignoreColor_g;			// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + ignoreColor_r;			// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + (ignorePct * 100);		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
		
	Event_fifo[Set_event] = InfosZero + interTrialDuration;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + holdtimeMax;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + saccDurationMax;			// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + saccTimeMax;			// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + holdtimeMin;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + nSSD;						// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + punishDuration;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + rewardDuration;			// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + rewardDelay;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
				
	Event_fifo[Set_event] = InfosZero + Staircase;					// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + stopColor_b;			// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + stopColor_g;			// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + stopColor_r;			// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + (stopPct * 100);		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + toneStopSuccess;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + (targWinSize * 100);		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + targAngle;						// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + targColor_b;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + targColor_g;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + targColor_r;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + (targAmp * 100);		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + targHoldtime;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + (targSize * 100);				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + toneDuration;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + trialDuration;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + trialOutcome;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + trialType;					// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + (eyeXGain * 100) + 1000;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
		
	Event_fifo[Set_event] = InfosZero + (eyeXOffset * 100) + 1000;	// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
			
	Event_fifo[Set_event] = InfosZero + (eyeYGain * 100) + 1000;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
		
	Event_fifo[Set_event] = InfosZero + (eyeYOffset * 100) + 1000;	// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
	
	Event_fifo[Set_event] = InfosZero + soa;					// Send event and... <-- added by Namsoo
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue





	Event_fifo[Set_event] = InfosZero + preTargHoldtime;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + postTargHoldtime;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + targ1CheckerColor_r;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + targ1CheckerColor_g;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + targ1CheckerColor_b;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + targ2CheckerColor_r;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + targ2CheckerColor_g;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + targ2CheckerColor_b;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + chkrWinSize * 100;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + nCheckerColumn;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + nCheckerRow;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + iSquareSizePixels;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + CheckerWidthDegrees * 100;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + CheckerHeightDegrees * 100;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + checkerAmp * 100;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + checkerAngle;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + targAmp * 100;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + targAngle;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + distAmp * 100;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + distAngle;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + nDiscriminate;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + round(targ1CheckerProp * 100);				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	// printf("   INFOS Target 1 Percentage = %d\n", targ1CheckerProp*100);
	// printf("   INFOS Target 1 Proportion = %.3d\n", targ1CheckerProp);
			
	


	Event_fifo[Set_event] = InfosZero + goCheckerColor_r;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + goCheckerColor_g;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + goCheckerColor_b;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + nogoCheckerColor_r;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + nogoCheckerColor_g;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + nogoCheckerColor_b;		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + goCheckerProp * 100;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	iChecker = 0;		
	while (iChecker < 100)
		{
		Event_fifo[Set_event] = InfosZero + checkerboardArray[iChecker];				// Send event and...	
		Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
		iChecker = iChecker + 1;
		}


// After adding metacog suite:

	Event_fifo[Set_event] = InfosZero + (maskSize * 100);			// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.
		
	Event_fifo[Set_event] = InfosZero + preBetHoldtime;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + preProHoldtime;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + highBetAngle;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + highBetAmp;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + lowBetAngle;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + lowBetAmp;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + maskColor_r;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + maskColor_g;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + maskColor_b;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + highBetColor_r;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + highBetColor_g;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + highBetColor_b;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + lowBetColor_r;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + lowBetColor_g;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + lowBetColor_b;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + betFixColor_r;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + betFixColor_g;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + betFixColor_b;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + proFixColor_r;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + proFixColor_g;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + proFixColor_b;				// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.	
			
	Event_fifo[Set_event] = InfosZero + (betWinSize * 100);		// Send event and...	
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue.



	//---------------------------------------------------------------------------------------------------------------------------------------
	
Event_fifo[Set_event] = EndInfos_;									// Let Matlab know that trial infos are finished streaming in...
Set_event = (Set_event + 1) % Event_fifo_N;							// ...incriment event queue.	


}//------------------------------------------------------------------------
// process JUICE(int channel, int duration)
// Deliver a juice reward to the animal
// INPUT
//	 channel  = rig specific TTL channel connected to solenoid (channel 9 in 028)
//	 duration = amount of time (in ms) to leave solenoid open
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011

declare JUICE(int channel, int duration);

process JUICE(int channel, int duration)
	{
	declare hide int open   = 1;	
	declare hide int closed = 0;	
	
	mio_dig_set(channel,open);		// Start sending the TTL
	wait(duration);					// Wait for user defined period of time (ms)
	mio_dig_set(channel,closed);	// Stop sending the TTL
	}//------------------------------------------------------------------------
// process KEY_MOVE()
// Give timeout and bad tone when the button is pressed.  Had to be written
// b/c can't spawn processes with input at command prompt (stupid). 
//
// paul.g.middlebrooks@vanderbilt.edu 	September, 2011

declare KEY_MOVE();

process KEY_MOVE()
	{
	declare hide int tone_freq, tone_durr;			
	
		Move_ct = 2;	
		tone_freq = 400;	
		tone_durr = round(Bmove_tout/2);
	
	spawnwait TONE(600,tone_durr);
	spawnwait TONE(1000,tone_durr);
	
	}//------------------------------------------------------------------------
// process KEY_REWD()
// Give reward and play a tone when the button is pressed.  Had to be written
// b/c can't spawn processes with input at command prompt (stupid). 
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011

declare KEY_REWD();

process KEY_REWD()
	{
	declare hide int juice_duration, tone_freq, tone_durr;			
	
	// if (baseRewardDuration == 0)				//Don't know if these user defined globals have values yet
		// {
		// juice_duration = 80;
		// }
	// else
		// {
		// juice_duration = baseRewardDuration;
		// }
		// juice_duration = 50;
		juice_duration = 100;
		
	if (Success_Tone_medR == 0)				//Don't know if these user defined globals have values yet
		{
		tone_freq = 600;
		}
	else
		{
		tone_freq = Success_Tone_medR;
		}
	
	if (toneDuration == 0)					//Don't know if these user defined globals have values yet
		{
		tone_durr = 30;
		}
	else
		{
		tone_durr = toneDuration;
		}
	
	spawn JUICE(juiceChannel,juice_duration);
	// spawn TONE(tone_freq,tone_durr);
	
	}//------------------------------------------------------------------------
// process KEY_STIM()
// Give stimulation  when the button is pressed.  Had to be written
// b/c can't spawn processes with input at command prompt. 
//

declare KEY_STIM();

process KEY_STIM()
	{
	
	spawn STIM(stimChannel,stimDuration);
	
	}// This had be be written in this klugey way for 2 reasons
// 1) This has to only happen during fixation.  Otherwise, an accidental
// button press could upset the apple cart during cmanding.
// 2) There is no way to give user defined input to processes at the
// command promt (lame).

//------------------------------------------------------------------------
// process KEY_T_UP()
// Advance to the next target during the fixation task based on a user button press
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011

declare KEY_T_UP();

process KEY_T_UP()
	{
	if (state == stateFIX)									// Global which defines which task we are running (2 = fixation)
		{
		targIndex = (targIndex + 1) % 9;
		}
	}
	
	
//------------------------------------------------------------------------
// process KEY_T_DN()
// Advance to the next target during the fixation task based on a user button press
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011

declare KEY_T_DN();

process KEY_T_DN()
	{
	if (State == stateFIX)									// Global which defines which task we are running (2 = fixation)
		{
		targIndex = targIndex - 1;
		if (targIndex == -1)
			{
			targIndex = 8;
			}
		}	
	}//----------------------------------------------------------------------
// LOCATE_I - Updates the global variables In_FixWin and In_TargWin 
// which tell where the eyes are.  This is called by WATCHEYE.pro every
// time the eye position changes.
//
// IN
//      No args
//      eyeX
// 		eyeY                   Mouse/eye position
//      fix_win_left		    Target and Fixation window positions
// 		fix_win_right
// 		fix_win_down
// 		fix_win_up
// 		targ_win_left
// 		targ_win_right
// 		targ_win_down
// 		targ_win_up
//
// OUT
//      In_FixWin                1 for yes, 0 for no
//		In_TargWin
//
// NOTE:  The logic of this function does not preclude the eyes being
// both at fixaion and at the target simultaneously.  This could 
// happen if the user accidentally made two overlapping windows in the
// setup.  It is up to the user to handle this with input or in the 
// protocol.
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011
// 11-2011: Integrated choice countermanding task into ALL_PROS.pro. -pgm

declare int In_FixWin, In_TargWin, In_DistWin, In_ChkrWin, In_HighBetWin, In_LowBetWin;

declare LOCATE_I(float eyeX,
				float eyeY);
				
process LOCATE_I(float eyeX,
                float eyeY)
	{
	
	
	// See if subject is in the fixation window
	if (eyeX >= fix_win_left  &&
		eyeX <= fix_win_right &&
		eyeY <= fix_win_down  &&
		eyeY >= fix_win_up)
		{
		In_FixWin = 1;               // Subject is inside fixation window
		}
	else
		{
		In_FixWin = 0;               // Subject is not inside fixation window
		}
		
	// See if subject is in the target window
	if (eyeX >= targ_win_left  &&
		eyeX <= targ_win_right &&
		eyeY <= targ_win_down  &&
		eyeY >= targ_win_up)
		{
		In_TargWin = 1;               // Subject is inside target window
		}
	else
		{
		In_TargWin = 0;               // Subject is not inside taraget window	
		}


	// For the choice choice countermanding task, also check the distractor target and the checkered stimulus
	if (state == stateCCM)
		{
		// See if subject is in the distractor window 
		if (eyeX >= dist_win_left  &&
			eyeX <= dist_win_right &&
			eyeY <= dist_win_down  &&
			eyeY >= dist_win_up)
			{
			In_DistWin = 1;               // Subject is inside distractor window
			}
		else
			{
			In_DistWin = 0;               // Subject is not inside distractor window		
			}
			
			//See if subject is in the checkered stimulus window 
		if (eyeX > chkr_win_left  &&
			eyeX < chkr_win_right &&
			eyeY < chkr_win_down  &&
			eyeY > chkr_win_up)
			{
			In_ChkrWin = 1;               // Subject is inside checkered stimulus window
			}
		else
			{
			In_ChkrWin = 0;               // Subject is not inside checkered stimulus window	
			}
		}

	if (state == stateMCM)
		{
		// For mask tasks also check the distractor windows
		if (trialType != tBetTrial)
			{
			// For 2-target trials, look inside the distractor window
			if (nTarg == 2)
				{
				if (eyeX >= dist1_win_left  &&
					eyeX <= dist1_win_right &&
					eyeY <= dist1_win_down  &&
					eyeY >= dist1_win_up)
					{
					In_DistWin = 1;               // Subject is inside distractor window
					}
				else
					{
					In_DistWin = 0;               // Subject is not inside distractor window		
					}
				}
			// For 4-target trials, also look inside the other 2 distractor windows
			if (nTarg == 4)
				{
				if ((eyeX >= dist1_win_left  &&
					eyeX <= dist1_win_right &&
					eyeY <= dist1_win_down  &&
					eyeY >= dist1_win_up) ||
					(eyeX >= dist2_win_left  &&
					eyeX <= dist2_win_right &&
					eyeY <= dist2_win_down  &&
					eyeY >= dist2_win_up) ||
					(eyeX >= dist3_win_left  &&
					eyeX <= dist3_win_right &&
					eyeY <= dist3_win_down  &&
					eyeY >= dist3_win_up))
					{
					In_DistWin = 1;               // Subject is inside distractor window
					}
				else
					{
					In_DistWin = 0;               // Subject is not inside distractor window		
					}
				} // nTarg == 4
			} // trialType != tBetTrial
			

		// For betting tasks, also check the high and low bet windows
		if (trialType != tMaskTrial)
			{
			// See if subject is in the high bet window 
			if (eyeX >= highBet_win_left  &&
				eyeX <= highBet_win_right &&
				eyeY <= highBet_win_down  &&
				eyeY >= highBet_win_up)
				{
				In_HighBetWin = 1;               // Subject is inside distractor window
				}
			else
				{
				In_HighBetWin = 0;               // Subject is not inside distractor window		
				}
				
			// See if subject is in the low bet window 
			if (eyeX >= lowBet_win_left  &&
				eyeX <= lowBet_win_right &&
				eyeY <= lowBet_win_down  &&
				eyeY >= lowBet_win_up)
				{
				In_LowBetWin = 1;               // Subject is inside distractor window
				}
			else
				{
				In_LowBetWin = 0;               // Subject is not inside distractor window		
				}
			}
		}

	}//--------------------------------------------------------------------------------------------------
// process MEM_PGS();
//
// Figure out all stimuli that will be needed on the next mem guided trial and
// place it all into video memory.
//
// written by david.c.godlove@vanderbilt.edu 	July, 2011


declare MEM_PGS();                       										// see GRAPHS.pro

process MEM_PGS()	                       										// see GRAPHS.pro
{


// number the pgs that need to be drawn
declare hide int   	blank       		= 0;
declare hide int	pd					= 1;
declare hide int	fixation_pd			= 2;
declare hide int	fixation    		= 3;
declare hide int	fixation_target_pd	= 4;
declare hide int	fixation_target	= 5;
declare hide int	target_pd   		= 6;
declare hide int	target      		= 7;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Calculate screen coordinates for stimuli on this trial

if (AutoTargetSizeFlag)
	{
	targSize        	 	= targAmp * TargetSizeConversion;   			// Figure out the attributes of the current target
	}
else
	{
	targSize				= sizeArray[targIndex];
	}
targAngle        = angleArray[targIndex]; 													// THESE USER DEFINED GLOBALS ARE ARRAYS SO
targColor        = targIndex + 1;																// zero is reserved for black.  see SET_CLRS.pro


opposite = ((screenHeight/2)-pdBottom);														// Figure out angle and eccentricity of photodiode marker in pixels
adjacent = ((screenWidth/2)-pdLeft);                                                         // NOTE: I am assuming your pd is in the lower left quadrant of your screen
pdAmp = sqrt((opposite * opposite) + (adjacent * adjacent));
pdAngle = rad2deg(atan (opposite / adjacent));
pdAngle = pdAngle + 180; 																	//change this for different quadrent or write some code for flexibility

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 1
// print("photodiode");
dsendf("rw %d,%d;\n",pd,pd);				 												// draw first pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 2
// print("fixation with photodiode");
dsendf("rw %d,%d;\n",fixation_pd,fixation_pd); 												// draw second pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 3
// print("fixation");
dsendf("rw %d,%d;\n",fixation,fixation);   													// draw 3rd pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 4
// print("fixation target and photodiode");
dsendf("rw %d,%d;\n",fixation_target_pd,fixation_target_pd);   								// draw 4th pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          	// draw target 
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 5
// print("fixation and target");
dsendf("rw %d,%d;\n",fixation_target,fixation_target);   								// draw 4th pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 5
// print("target with photodiode");
dsendf("rw %d,%d;\n",target_pd,target_pd);  												// draw pg 5
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 6
// print("target");
dsendf("rw %d,%d;\n",target,target);  														// draw pg 6 k commented out
dsendf("cl:\n");																			// clear screen k commented out
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);         	// draw target k chnaged
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 0 (last is displayed first)
// print("blank");
dsendf("rw %d,%d;\n",blank,blank);                                          				// draw the blank screen last so that it shows up first
dsendf("cl:\n");                                                                            // clear screen (that's all)

}//--------------------------------------------------------------------------------------------
// Run a memory guided saccade trial based on the variables calculated by SETM_TRL.pro and 
// those given by the user.  Adapted from CMDTRIAL.
//
// written by david.c.godlove@vanderbilt.edu 	July, 2011


declare MEMTRIAL();			// animated graph object

process MEMTRIAL()        		// animated graph object
	{
	
	
	// Number the trial stages to make them easier to read below
	declare hide int 	need_fix  	= 1;
	declare hide int 	fixating  	= 2;
	declare hide int 	targ_off   	= 3;
	declare hide int	fix_off		= 4;
	declare hide int 	in_flight 	= 5;
	declare hide int 	on_target 	= 6;	
	declare hide int 	stage;
	
	// Number the stimuli pages to make reading easier
	declare hide int   	blank       		= 0;
	declare hide int	pd					= 1;
	declare hide int	fixation_pd 		= 2;
	declare hide int	fixation    		= 3;
	declare hide int	fixation_target_pd	= 4;
	declare hide int	fixation_target	= 5;
	declare hide int	target_pd   		= 6;	
	declare hide int	target      		= 7;
		  
	// Timing variables which will be used to time task
	declare hide float 	fix_on_time; 	
	declare hide float 	aquire_fix_time;
	declare hide float  targ_time;	
	declare hide float	fix_off_time;
	declare hide float  saccade_time;
	declare hide float	aquire_targ_time;	
	
	
	// Have to be reset on every iteration since 
	// variable declaration only occurs at load time
	trl_running 		= 1;
	stage 				= need_fix;
	
	// Tell the user what's up
	printf("\n# %d\n",nTrial);
	printf("Hold time:     %d\n",  soa);

	
	
																			// HERE IS WHERE THE FUN BEGINS
	Event_fifo[Set_event] = TrialStart_;									// queue TrialStart_ strobe
	Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
	dsendf("vp %d\n",fixation_pd);											// flip the pg to the fixation stim with pd marker
	fix_on_time = time();  													// record the time
	Event_fifo[Set_event] = FixSpotOn_;										// queue strobe
	Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
	dsendf("XM RFRSH:\n"); 													// wait for one retrace
	dsendf("vp %d\n",fixation);												// flip the pg to the fixation stim without pd marker
	oSetAttribute(object_fix, aVISIBLE); 									// turn on the fixation point in animated graph
	
	
	while (trl_running)														// trials ending will set trl_running = 0
		{	
		
	//--------------------------------------------------------------------------------------------
	// STAGE need_fix (the fixation point is on, but the subject hasn't looked at it)
		if (stage == need_fix)
			{		
			if (In_FixWin)													// If the eyes have entered the fixation window (before time, see below)...
				{
				aquire_fix_time = time();									// ...function call to time to note current time and...
				trialStartTime = aquire_fix_time;							// Global output for timing iti
				Event_fifo[Set_event] = Fixate_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				stage = fixating;											// ...advance to the next stage.
				}
			else if (time() > fix_on_time + allowFixTime)				// But if time runs out...
				{
				trialOutcome = noFix;    									// TRIAL OUTCOME ABORT (no fixation)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen,...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Aborted (no fixation)\n");							// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}			
			}
			
			

	//--------------------------------------------------------------------------------------------
	// STAGE fixating (the subject is looking at the fixation point waiting for target onset)		
		else if (stage == fixating)
			{
			if (!In_FixWin)													// If the eyes stray out of the fixation window...
				{
				trialOutcome = brokeFix;									// TRIAL OUTCOME ABORT (broke fixation)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}
			else if (In_FixWin && time() > aquire_fix_time + preTargHoldtime)	// But if the eyes are still in the window at end of holdtime...
				{
				dsendf("vp %d\n",fixation_target_pd);						// ...flip the pg to the target with pd marker...	
				targ_time = time(); 										// ...record the time...
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				dsendf("vp %d\n",fixation_target);						// ...flip the pg to the target with pd marker...	
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
					dsendf("vw %d\n",targDuration-1);							// Wait so many vertical retraces (one is waited implicitly b/c photodiode marker above)...
				dsendf("vp %d\n",fixation);									// ...flip the pg to the fixation point without pd marker.
				Event_fifo[Set_event] = Target_;						// Queue strobe... 
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
		

				oSetAttribute(object_targ, aVISIBLE); 						// ...show target in animated graph...
														
				stage = targ_off;											// Advance to the next trial stage.				
				}
			}
			
			

	//--------------------------------------------------------------------------------------------
	// STAGE targ_off (the target has been presented and disappeared but the subject is still fixating)		
		else if (stage == targ_off)
			{		
			if (!In_FixWin)													// If the eyes leave the fixation window...
				{
				trialOutcome = saccEarly;									// TRIAL OUTCOME ERROR (sacc before cued to do so)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (early saccade)\n");							// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}
			
			else if (In_FixWin &&  											// But if no saccade occurs...
				time() > targ_time + soa)	 							// ...and the stim onset asychrony passes...
				{
				dsendf("vp %d\n",pd);										// Flip the pg to the blank screen with the photodiode marker...
				// dsendf("vp %d\n",target_pd);										// DELAY TASK  Flip the pg to the target screen with the photodiode marker...
				fix_off_time = time();										// ...and record the time that the fixation point was extinguished.
				Event_fifo[Set_event] = FixSpotOff_;						// Queue strobe... 
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen without pd marker.
				// dsendf("vp %d\n",target);									// .DELAY TASK..flip the pg to the target screen without pd marker.
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				stage = fix_off;											// ...and advance to the next stage.
				}	
			}



	//--------------------------------------------------------------------------------------------
	// STAGE fix_off (the fixation point has been turned off but the subject is still fixating)		
		else if (stage == fix_off)
			{
			if (!In_FixWin)													// If the eyes leave the fixation window...			
				{															// ...we have a saccade, so...
				saccade_time = time();										// ...record the time...
				Event_fifo[Set_event] = Saccade_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				printf("                          rt = %d\n",saccade_time - fix_off_time);	// ...tell the user whats up...
				stage = in_flight;											// ...and advance to the next stage.
				}
			
			else if (In_FixWin &&  											// But if no saccade occurs...
				time() > fix_off_time + saccTimeMax) 					// ...and time for a saccade runs out...
				{
				trialOutcome = noSacc;           							// TRIAL OUTCOME ERROR (no saccade after cue)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (no saccade)\n");								// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}	
			}			
			
			
	//--------------------------------------------------------------------------------------------
	// STAGE in_flight (eyes have left fixation window but have not entered target window)		
		else if (stage == in_flight)
			{
			if (In_TargWin)													// If the eyes get into the target window...
				{
				aquire_targ_time = time(); 									// ...record the time...
				Event_fifo[Set_event] = Decide_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				nexttick 80;
				stage = on_target;											// ...and advance to the next stage of the trial.
				dsendf("vp %d\n",target);									// turn on the target again to reinforce the idea
				}
			else if (time() > saccade_time + saccDurationMax)				// But, if the eyes are out of the target window and time runs out...
				{
				trialOutcome = saccOut;   									// TRIAL OUTCOME ERROR (innacurrate saccade)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (inaccurate saccade)\n");						// ...tell the user whats up...
				trl_running = 0; 											// ...and terminate the trial.
				}
			}
		
		
		
	//--------------------------------------------------------------------------------------------
	// STAGE on_target (eyes have entered the target window.  will they remain there for duration?)	
		else if (stage == on_target)
			{
			if (!In_Targwin)													// If the eyes stray out of the fixation window...
				{			
				trialOutcome = brokeTarg;									// TRIAL OUTCOME ERROR (broke target fixation)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (broke target fixation)\n");					// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}		
			else if (In_TargWin 											// But if the eyes are still in the target window...
				&&  time() > aquire_targ_time + targHoldtime)				// ...and the target hold time is up...				
				{
				trialOutcome = saccTarg;									//TRIAL OUTCOME CORRECT (correct sacc trial)
				Event_fifo[Set_event] = Correct_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				printf("Correct (saccade)\n");								// ...tell the user whats up...
				dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				trl_running = 0;											// ...and terminate the trial.
				}			
			}
			
		nexttick;
		}
	}; TEMPO DIALOG CONFIGURATION FILE
; Copyright 1997-2014 Reflective Computing.  All Rights Reserved.
; This file was created by TEMPO and should not be edited directly by the user.
; The commands in this file are undocumented and subject to change in future releases.
; Fri Mar 07 00:26:31 2014
; DLOAD metacog.dcf

; DIALOGS

SCREENRES 1280,1024,32

DIAPAGE 0,"Info_and_StartClock"
DIAPOS   0,0,-1,-1,-1,-1,411,354,791,557,0
DIAOBJ   0,0,2,269,120,349,150,"OK","start;\r\ndpop Info_and_StartClock;"
DIAOBJ   0,3,1,17,14,243,157,"","ALL_PROS.pro     (F1)\r\n\r\nprotocol control structure\r\nand associated protocols\r\n\r\nwritten by\r\ndavid.c.godlove@vanderbilt.edu\r\nJanuary, 2011"

DIAPAGE 1,"Choose_Task"
DIAPOS   1,0,0,972,-1,-1,809,266,1180,877,1
DIAOBJ   1,0,2,58,156,186,178,"Fixation","quiet State = 1;\r\ndpop Choose_Task"
DIAOBJ   1,1,1,20,12,166,62,"","Which task do you\r\nwant to run? (F2)"
DIAOBJ   1,2,2,270,538,350,562,"Exit","Exit"
DIAOBJ   1,3,2,175,538,255,562,"Stop Clock","stop"
DIAOBJ   1,12,2,184,317,319,341,"Metacog","quiet State = 9;\r\ndshow mask_betting;\r\ndpop Choose_Task"

DIAPAGE 2,"mask_betting"
DIAPOS   2,0,-1,-1,-1,-1,817,72,1203,862,2
DIAOBJ   2,0,2,296,728,360,750,"Start","beginTaskFlag = 1; "
DIAOBJ   2,1,2,211,728,275,750,"Quit","dshow quit_check;\r\nDPOP"
DIAOBJ   2,2,2,118,730,191,749,"Update","DSET;"
DIAOBJ   2,3,2,21,729,96,750,"Pause","quiet Pause = 1;\r\ndialog Resume"
DIAOBJ   2,4,1,8,45,105,66,"","Mask Trial %"
DIAOBJ   2,5,1,8,79,105,100,"","Bet Trial %"
DIAOBJ   2,6,1,8,113,105,134,"","Retro Trial %"
DIAOBJ   2,7,1,8,148,105,168,"","ProTrial %"
DIAOBJ   2,8,1,116,16,244,38,"","Trial Distribution"
DIAOBJ   2,9,3,205,45,266,63,"","maskPct"
DIAOBJ   2,10,3,205,78,266,94,"","betPct"
DIAOBJ   2,11,3,205,109,266,131,"","retroPct"
DIAOBJ   2,12,3,205,146,266,168,"","proPct"
DIAOBJ   2,13,1,10,201,105,221,"","Target Amp"
DIAOBJ   2,14,5,119,199,182,220,"","ampDefault"
DIAOBJ   2,15,3,218,198,294,217,"","ampDefault"
DIAOBJ   2,16,1,8,229,109,249,"","Target 1 Angle"
DIAOBJ   2,17,5,120,113,170,134,"","retroPct"
DIAOBJ   2,18,5,119,259,182,277,"","maskAngleArray[1]"
DIAOBJ   2,19,5,120,149,170,168,"","proPct"
DIAOBJ   2,20,5,120,45,170,64,"","maskPct"
DIAOBJ   2,21,5,120,78,170,99,"","betPct"
DIAOBJ   2,22,5,119,229,182,250,"","maskAngleArray[0]"
DIAOBJ   2,23,3,218,229,294,247,"","maskAngleArray[0]"
DIAOBJ   2,24,5,119,287,182,308,"","maskAngleArray[2]"
DIAOBJ   2,25,5,119,320,182,337,"","maskAngleArray[3]"
DIAOBJ   2,26,3,218,318,294,340,"","maskAngleArray[3]"
DIAOBJ   2,27,3,218,288,294,310,"","maskAngleArray[2]"
DIAOBJ   2,28,3,218,259,294,276,"","maskAngleArray[1]"
DIAOBJ   2,29,1,7,257,107,274,"","Target 2 Angle"
DIAOBJ   2,30,1,8,287,112,305,"","Target 3 Angle"
DIAOBJ   2,31,1,11,321,111,340,"","Target 4 Angle"
DIAOBJ   2,32,1,13,395,108,414,"","Mask Window"
DIAOBJ   2,33,5,142,393,205,411,"","targWinSize"
DIAOBJ   2,34,3,263,393,308,409,"","targWinSize"
DIAOBJ   2,35,1,12,424,105,444,"","Bet Window"
DIAOBJ   2,36,5,142,425,205,444,"","betWinSize"
DIAOBJ   2,37,3,263,423,305,442,"","betWinSize"
DIAOBJ   2,38,1,11,480,123,501,"","Fake Correct Rate"
DIAOBJ   2,39,5,142,479,205,499,"","fakeCorrectRate"
DIAOBJ   2,40,3,263,481,310,500,"","fakeCorrectRate"
DIAOBJ   2,41,1,11,508,126,530,"","Target Right Rate"
DIAOBJ   2,42,5,142,505,205,527,"","targetRightRate"
DIAOBJ   2,43,3,263,508,306,526,"","targetRightRate"
DIAOBJ   2,44,1,11,536,139,558,"","High Bet Right Rate"
DIAOBJ   2,45,3,263,535,308,556,"","highBetRightRate"
DIAOBJ   2,46,5,142,534,205,554,"","highBetRightRate"
DIAOBJ   2,47,3,251,597,316,614,"","baseRewardDuration"
DIAOBJ   2,48,5,144,591,211,609,"","baseRewardDuration"
DIAOBJ   2,49,1,20,589,120,608,"","Reward time"
DIAOBJ   2,50,1,16,621,121,641,"","Timeout"
DIAOBJ   2,51,3,244,628,326,643,"","basePunishDuration"
DIAOBJ   2,52,5,145,625,215,641,"","basePunishDuration"
DIAOBJ   2,53,5,132,660,200,679,"","nTarg"
DIAOBJ   2,54,3,245,664,315,679,"","nTarg"
DIAOBJ   2,55,1,28,662,111,681,"","nTarg"
DIAOBJ   2,56,2,142,698,252,720,"Slow it down","intertrialDuration = 2500;"
DIAOBJ   2,57,5,142,365,202,384,"","fixWinSize"
DIAOBJ   2,58,3,240,370,303,385,"","fixWinSize"
DIAOBJ   2,59,1,13,368,99,387,"","Fix Window"

DIAPAGE 13,"Quit_Check"
DIAPOS   13,0,-1,-1,-1,-1,431,452,791,632,13
DIAOBJ   13,0,2,233,119,345,141,"Quit Task","quiet state = 0;\r\nDPOP;\r\n"
DIAOBJ   13,1,2,110,119,222,141,"Don't Quit","DPOP"
DIAOBJ   13,2,1,8,15,218,79,"","QUIT TASK\r\n\r\nAre you sure you want to quit?"

DIAPAGE 15,"Resume"
DIAPOS   15,0,-1,-1,-1,-1,512,377,694,513,15
DIAOBJ   15,0,1,35,22,148,50,"","Task is paused."
DIAOBJ   15,1,2,53,63,117,85,"Resume","quiet Pause = 0;\r\nDPOP"

DIAPAGE 16,"Select_Monkey"
DIAPOS   16,0,-1,-1,-1,-1,884,264,1248,875,16
DIAOBJ   16,0,2,181,391,245,413,"OK","DPOP"
DIAOBJ   16,1,2,70,299,195,335,"Default","quiet setMonkey = 1;\r\ndpop"
DIAOBJ   16,2,2,63,175,191,209,"Cajal","quiet Monkey = 2;\r\nquiet setMonkey = 1;\r\ndpop"
DIAOBJ   16,4,2,61,79,186,115,"Xena","quiet Monkey = 3;\r\nquiet setMonkey = 1;\r\ndpop"
DIAOBJ   16,5,2,61,125,186,161,"Broca","quiet Monkey = 2;\r\nquiet setMonkey = 1;\r\ndpop"

; END OF DIALOGS

C:/TEMPO/ProcLib/PGM/DEFAULT.pro(793) : error Error - 'broca' not explicitly declared.
C:/TEMPO/ProcLib/PGM/DEFAULT.pro(1116) : error Error - 'cajal' not explicitly declared.
C:/TEMPO/ProcLib/PGM/DEFAULT.pro(1499) : error Error - 'euler' not explicitly declared.
C:/TEMPO/ProcLib/PGM/REWARDS.pro(256) : error Error - 'broca' not explicitly declared.
; TEMPO PROTOCOL CONFIGURATION FILE
; Copyright 1997-2014 Reflective Computing.  All Rights Reserved.
; This file was created by TEMPO and should not be edited directly by the user.
; The commands in this file are undocumented and subject to change in future releases.
; Fri Mar 07 00:26:31 2014
; CLOAD METACOG.pcf

; tempow 11.7 Set 40.13   'CLIENT0291343' connected to 'tempo4'
; KPED 11.2 Set 40
; KSRV 11.3 Set 40.13 (Server 'tempo4          ' running on computer '')
; PCL 0.0     TEMPO 0.0
; ANALOGRESOLUTION=16
; WARNING=2
; SPEED=1000.000000  PROSPEED=500.000000  (100/100000 Sec/SampleSet)
; ASETS=2(2)  CSETS=2(2)  ESETS=2(2)
; ACHANNELS=3
; CCHANNELS=2
; ECHANNELS=2
;
;                          Protocol Usage of Kernel Resources  
;
; Parameter       Limit          Used    Pct        Bytes/Total        Develop    Stable
; -------------   -------     -------  -----        -----------        -------    ------
; PROCESSES       =80              41    51%         1804/3520          =59        =43      
; INSTRUCTIONS    =7000          3567    51%        64206/126000        =4460      =3756    
; InstructionsXMS =20025         3567    18%        64206/360448        =4460      =3756    
; SYMBOLTABLE     =2200          1502    68%        18024/26400         =1767      =1581    
; HASHTABLE       =     257,2200         62%         9774/14742       Use Kernel Default
; NAMETABLE       =60000        17255    29%        17255/60000         =20300     =18163   
; DATABASES       =16               0     0%            0/960           =0         =0       
; ARRAYTABLE      =500            462    92%          462/500           =578       =476     
; ARRAYDATA       =10240         9360    91%         9360/10240         =11700     =9649    
; OBJECTS         =41              15    37%          660/1804          =17        =15      
;
; PROTOCOL PROCESS CONTROL BLOCKS (XMS Instructions Caching ENABLED)
; INSTRUCTIONS=7000,20024
; Memory (bytes):  64206/126000 Conventional, 64206/360448 XMS
; Server CPU Mhz  Empirical 2992.5    Theoretical 3000.0
;
;    STATE PROCESS  Longest  0.264ms   PC INST  MAX LONG     MS  MaxMS LongMS Bytes  Conventional        XMS      Loaded  uSec 
;   1 SUSP DEFAULT                      0    0    0    0  0.000  0.000  0.000  7572    not loaded        2-7573        0     0
;   2 SUSP GOODVARS                     0    0    0    0  0.000  0.000  0.000  3786    not loaded     7574-11359       0     0
;   3 SUSP SET_CLRS                     0    0    0    0  0.000  0.000  0.000   842    not loaded    11360-12201       0     0
;   4 DONE SET_COOR                   192    0   17   17  0.000  0.093  0.093   192     938-1137     12202-12393       1     3
;   5 DONE GRAPHS                     548    0   47   47  0.000  0.042  0.042   548    1138-1693     12394-12941       1     3
;   6 SUSP SET_PSY                      0    0    0    0  0.000  0.000  0.000   712    not loaded    12942-13653       0     0
;   7 SUSP JUICE                        0    0    0    0  0.000  0.000  0.000    44    not loaded    13654-13697       0     0
;   8 SUSP STIM                         0    0    0    0  0.000  0.000  0.000    88    not loaded    13698-13785       0     0
;   9 SUSP STAIR                        0    0    0    0  0.000  0.000  0.000   316    not loaded    13786-14101       0     0
;  10 SUSP STAIR_DSC                    0    0    0    0  0.000  0.000  0.000   574    not loaded    14102-14675       0     0
;  11 SUSP SETTRIAL                     0    0    0    0  0.000  0.000  0.000  6226    not loaded    14676-20901       0     0
;  12 SUSP WINDOWS                      0    0    0    0  0.000  0.000  0.000  4264    not loaded    20902-25165       0     0
;  13 DONE LOCATE_I                  1416   24   24   24  0.009  0.144  0.018  1416    2192-3615     25166-26581       1     5
;  14 RUN  WATCHEYE                   486   27   32   26  0.015  0.149  0.029   490    1694-2191     26582-27071       1     3
;  15 SUSP TONE                         0    0    0    0  0.000  0.000  0.000    54    not loaded    27072-27125       0     0
;  16 SUSP TONESWEP                     0    0    0    0  0.000  0.000  0.000   288    not loaded    27126-27413       0     0
;  17 SUSP WATCHMTH                     0    0    0    0  0.000  0.000  0.000   404    not loaded    27414-27817       0     0
;  18 SUSP WATCHBOD                     0    0    0    0  0.000  0.000  0.000   160    not loaded    27818-27977       0     0
;  19 SUSP SVR_BELL                     0    0    0    0  0.000  0.000  0.000   180    not loaded    27978-28157       0     0
;  20 SUSP SVR_BEL2                     0    0    0    0  0.000  0.000  0.000    20    not loaded    28158-28177       0     0
;  21 SUSP DRW_SQR                      0    0    0    0  0.000  0.000  0.000   380    not loaded    28178-28557       0     0
;  22 SUSP DRW_CHKR                     0    0    0    0  0.000  0.000  0.000  1920    not loaded    28558-30477       0     0
;  23 SUSP DRW_GNG                      0    0    0    0  0.000  0.000  0.000  1910    not loaded    30478-32387       0     0
;  24 SUSP MSK_PGS                      0    0    0    0  0.000  0.000  0.000  1678    not loaded    32388-34065       0     0
;  25 SUSP BET_PGS                      0    0    0    0  0.000  0.000  0.000  1042    not loaded    34066-35107       0     0
;  26 SUSP MSKTRIAL                     0    0    0    0  0.000  0.000  0.000  2248    not loaded    35108-37355       0     0
;  27 SUSP BETTRIAL                     0    0    0    0  0.000  0.000  0.000  2040    not loaded    37356-39395       0     0
;  28 SUSP RETTRIAL                     0    0    0    0  0.000  0.000  0.000  4064    not loaded    39396-43459       0     0
;  29 SUSP PROTRIAL                     0    0    0    0  0.000  0.000  0.000  4372    not loaded    43460-47831       0     0
;  30 SUSP UPD8_PSY                     0    0    0    0  0.000  0.000  0.000  2642    not loaded    47832-50473       0     0
;  31 SUSP INFOS                        0    0    0    0  0.000  0.000  0.000  6282    not loaded    50474-56755       0     0
;  32 SUSP REWARDS                      0    0    0    0  0.000  0.000  0.000  5740    not loaded    56756-62495       0     0
;  33 SUSP KEY_REWD                     0    0    0    0  0.000  0.000  0.000   128    not loaded    62496-62623       0     0
;  34 SUSP KEY_T_UP                     0    0    0    0  0.000  0.000  0.000    50    not loaded    62624-62673       0     0
;  35 SUSP KEY_T_DN                     0    0    0    0  0.000  0.000  0.000    68    not loaded    62674-62741       0     0
;  36 SUSP KEY_MOVE                     0    0    0    0  0.000  0.000  0.000   116    not loaded    62742-62857       0     0
;  37 SUSP KEY_STIM                     0    0    0    0  0.000  0.000  0.000    26    not loaded    62858-62883       0     0
;  38 SUSP WAIT_MU                      0    0    0    0  0.000  0.000  0.000   100    not loaded    62884-62983       0     0
;  39 SUSP SEND_TTL                     0    0    0    0  0.000  0.000  0.000   144    not loaded    62984-63127       0     0
;  40 RUN  QUE_TTL                    146    8    8    7  0.006  0.018  0.008   150    3616-3773     63128-63277       1     2
;  41 RUN  IDLE                       830   10   17   14  0.006  0.141  0.061   928       2-937      63278-64205       1     5


SPEED 1000

; ANALOG TABLE SETTINGS
;; ACHANNELS=3

; SPIKE TABLE SETTINGS
;; CCHANNELS=2

; EVENT TABLE SETTINGS
;; ECHANNELS=2

PLOAD metacog.pro

; DATABASES=16


; WINDOW CONFIGURATION

SCREENRES 1280,1024,32
MAINWND 1,-1,-1,-1,-1,1,-1,912,53,0
MSGWND 1,-1,-1,-1,-1,1,53,375,910,0
STATUSWND 1,-1,-1,-1,-1,369,429,1271,973,0
SHOW v 39

CMDWND 1,-1,-1,-1,-1,3,911,618,961,0
ANIMPAGE 0x1,1,-1,-1,-1,-1,368,54,1275,430,0
ANIMVIEW 0,1,-1,-1,-1,-1,0,0,449,349,0
ANIMVIEW 1,1,-1,-1,-1,-1,449,0,898,349,1

; DATABASES PAGES & VIEWS

DBPCOLORS 0x0,0x0,0x0,0x0,0x0

; END GRAPH CONFIGURATION

DLOAD metacog.dcf

; BEGIN KEY DEFINITIONS

KEY F1 = dialog Info_and_StartClock
KEY ESC = dpop
KEY PLUS = spawn key_rewd
KEY INSERT = spawn key_rewd
KEY ALTE = Eye_on_VDOSync = 1
KEY ALTX = Eye_on_VDOSYnc = 0
KEY ALTC = CenterEyeNow = 1
KEY F2 = dialog Choose_Task
KEY F4 = dialog in_task_pane
KEY ALTM = spawn key_move
KEY CURUP = spawn KEY_REWD
KEY PGUP = spawn KEY_STIM

; END KEY DEFINITIONS

//----------------------------------------------------------------------------
// METACOG.pro



#pragma declare = 1                     // require declarations of all variables

declare IDLE();							// must be declared in top because it is called by other processes below

declare int state;						// The state global variable allows the control structure to run tasks...
										// ...depending on the current stystem state. The beginning state is idling.
declare int beginTaskFlag;				// Starts tasks after setting variables;
declare int allowTaskToBegin;
declare int setMonkey;
declare int monkey;	
declare int Pause;						// Gives user ability to pause task with a button press
declare int Last_task;					// Keeps track of the last task which was run to hold onto default variable values
declare int Event_fifo_N = 1000;		// Length of strobed event buffer
declare int Event_fifo[Event_fifo_N];	// Global first in first out buffer for event codes
declare int Set_event = 0;              // Current index of Event_fifo buffer to set


#include C:/TEMPO/ProcLib/PGM/RIGSETUP.pro  // declares a bunch of rig specific global variables
#include C:/TEMPO/ProcLib/PGM/EVENTDEF.pro	// event code definitions
#include C:/TEMPO/ProcLib/PGM/ALL_VARS.pro	// declares global variables needed to run protocols
#include C:/TEMPO/ProcLib/PGM/DEFAULT.pro	// sets all globals to their appropriate defaults for countermanding
#include C:/TEMPO/ProcLib/PGM/GOODVARS.pro	// do user defined variables make sense before starting the task?
#include C:/TEMPO/ProcLib/PGM/SET_CLRS.pro	// sets the stim colors up
#include C:/TEMPO/ProcLib/PGM/DIO.pro		// necessary for digital input output communication
#include C:/TEMPO/ProcLib/PGM/SET_COOR.pro  // set screen coordinates up and calculate some conversion factors
#include C:/TEMPO/ProcLib/PGM/GRAPHS.pro    // required when using object graphs in cmanding protocol (modified from object.pro to include graph setup)
// #include C:/TEMPO/ProcLib/PGM/SET_INH.pro	// sets up the inhibition function graph used in cmanding
#include C:/TEMPO/ProcLib/PGM/SET_PSY.pro	// sets up the psychometric function graph used in go/no-go
#include C:/TEMPO/ProcLib/PGM/JUICE.pro
#include C:/TEMPO/ProcLib/PGM/STIM.pro
#include C:/TEMPO/ProcLib/PGM/SETTRIAL.pro	// sets up all of the input to run a countermanding trial
#include C:/TEMPO/ProcLib/PGM/WINDOWS.pro	// sets fixation and target window targSize (these valeus are needed in WATCHEYE.pro)
#include C:/TEMPO/ProcLib/PGM/WATCHEYE.pro	// monitors eye position on each process cyle
#include C:/TEMPO/ProcLib/PGM/TONE.pro      // does simple frequency conversion and presents tone accordingly
#include C:/TEMPO/ProcLib/PGM/TONESWEP.pro	// a sweep through several tones for a sound which can be distinguished from pure tones
#include C:/TEMPO/ProcLib/PGM/WATCHMTH.pro	// monitors mouth movement on each process cycle
#include C:/TEMPO/ProcLib/PGM/WATCHBOD.pro	// monitors body movement on each process cycle
#include C:/TEMPO/ProcLib/PGM/SVR_BELL.pro	// sounds speaker on server
#include C:/TEMPO/ProcLib/PGM/SVR_BEL2.pro	// sounds speaker on server (different)
#include C:/TEMPO/ProcLib/PGM/DRW_SQR.pro	// simple process for drawing stim
#include C:/TEMPO/ProcLib/PGM/DRW_CHKR.pro	// process for drawing checkered discriminatory stimulus
#include C:/TEMPO/ProcLib/PGM/DRW_GNG.pro	// process for drawing checkered go/no-go discriminatory stimulus
#include C:/TEMPO/ProcLib/PGM/MSK_PGS.pro						// sets all pgs of video memory up for the impending trial
#include C:/TEMPO/ProcLib/PGM/BET_PGS.pro						// sets all pgs of video memory up for the impending trial
#include C:/TEMPO/ProcLib/PGM/MSKTRIAL.pro	// modified from CMDTRIAL, for go/no-go
#include C:/TEMPO/ProcLib/PGM/BETTRIAL.pro	// modified from CMDTRIAL, for go/no-go
#include C:/TEMPO/ProcLib/PGM/RETTRIAL.pro	// modified from CMDTRIAL, for go/no-go
#include C:/TEMPO/ProcLib/PGM/PROTRIAL.pro	// modified from CMDTRIAL, for go/no-go
// #include C:/TEMPO/ProcLib/PGM/UPD8_INH.pro	// updates inhibition function for cmanding
#include C:/TEMPO/ProcLib/PGM/UPD8_PSY.pro	// updates psychometric function for go/no-go
#include C:/TEMPO/ProcLib/PGM/INFOS.pro		// queue up all trial event codes for strobing to plexon
#include C:/TEMPO/ProcLib/PGM/REWARDS.pro	// ends a trial based on outcome
#include C:/TEMPO/ProcLib/PGM/KEY_REWD.pro	// needed to give reward manually from keyboard (stupid)
#include C:/TEMPO/ProcLib/PGM/KEY_TARG.pro	// see above
#include C:/TEMPO/ProcLib/PGM/KEY_MOVE.pro	// see above
#include C:/TEMPO/ProcLib/PGM/KEY_STIM.pro	// see above
#include C:/TEMPO/ProcLib/PGM/QUE_TTL.pro	// makes a ring buffer for sending TTL events






//----------------------------------------------------------------------
process IDLE() enabled				// When the clock is started the task is not yet running.
{									// At any time we can press a button to return to this...
									// ...idle loop.  It will make sure everything is off...
									// ...and all necessary variables are reset before...
									// ...starting the task over or starting a new task.
declare hide int off = 0;
declare hide int idling = 1;			// makes the while loop run
declare int i;

seed1(timeus());					// randomly seed the number generator
normal(1);							// call the normal distribution to replenish queue after seeding
				  
dioSetMode(0, PORTA|PORTB|PORTC); 	// set 1st three TTL lines to output					  
mio_dig_set(juiceChannel,off);		// make sure the juice line is closed
mio_fout(off);						// make sure the speaker is off
dsend("vi 256;");					// make sure vdosync is in correct config
dsend("ca");						// flush all vdosync memory
		
		
		
		
spawn SET_COOR();					// set up screen coordinates based on globals defined in RIGSETUP.pro	
			
spawn GRAPHS();						// this is currently countermanding specific and should be changed
	
spawn WATCHEYE();					// start monitoring eye position

spawn QUE_TTL();					// set up for plexon communication


printf("flushing video memory please wait...\n");
wait 5000; 							// it can take up to 5 seconds to clear all vdo sync memory (pg 7-37)
printf("done!\n");
system("dialog Choose_Task");		// Pop up choose task dialog
if (!setMonkey)
	{
	system("dialog Select_Monkey");
	}
		system("key curup = spawn KEY_REWD");		// define up key macro
		system("key pgup = spawn KEY_STIM");		// define page up key macro







	
while (idling)						// wait for the user to specify which task to run
	{
	beginTaskFlag = 0;				// after exiting a task (or before ever starting one for the session), reset (set) beginTaskFlag
	allowTaskToBegin = 0;			// ensures a task doesn't get spawned before re-setting stuff in "if (state != stateNoTask)" conditional
	




	
// --------------------------------------------------------------------------------
// If a task has been selected to run, do a few things common to all tasks before calling relevant task below
// --------------------------------------------------------------------------------
	if (state != stateNoTask)					// stop idling if a task is being run
		{
		idling = 0;					
		
		nTrial				= 1;			// initialize some counters
		nTrialComplete			= 0;
		Block_number			= 1;

								
	
		dsend("DM RFRSH");                			// This code sets up a vdosync macro definition to wait a specified ...
		if (Room == 23)                   			// ...number of vertical retraces based on the room in which we are    ...
			{                             			// ...recording.  This kluge is necessary because vdosync operates     ...
			dsendf("vw %d:\n",1);         			// ...differently in the different rooms.  In 028 a command to wait    ...
			}                             			// ...2 refresh cycles usually only waits for one and a command to     ...
		else                              			// ...wait for 1 usually only waits for 0.  Room 029 and 023 appear to ...
			{                             			// ...work properly.
			dsendf("vw %d:\n",2);
			}
		dsend("EM RFRSH");
		
		// if (setMonkey)
			// {
			// spawnwait DEFAULT();			// Set all globals to their default values based on the monkey.
			// }
	

		spawn WATCHMTH;								// start watching the mouth motion detector if present
		spawn WATCHBOD;								// start watching motion detector for body if present
		

		
		allowTaskToBegin = 1;
		nexttick 10;								// to prevent buffer overflows after task reentry.
		
		}
		
		
		

		


// --------------------------------------------------------------------------------
// REVERSE MASKING METACOGNITION SUITE
// --------------------------------------------------------------------------------
	if (state == stateMCM && allowTaskToBegin)		// metacog task
		{
		
		spawnwait DEFAULT();
		spawnwait GOODVARS();
		spawnwait SET_CLRS();

		
		nTrial				= 1;
		
		// Wait for user to specify when to start (by pressing Start button on task GUI)
		while (!beginTaskFlag)									
			{
			nexttick;
			}
		Event_fifo[Set_event] = MaskBetHeader_;			// Set a strobe to identify this file as a visually guided session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		Event_fifo[Set_event] = Identify_Room_;		// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		Event_fifo[Set_event] = Room;				// Set a strobe to identify this file as a Cmanding session and...	
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
		
		while (State == stateMCM)				// while the user has not yet terminated the mem guided task
			{
			
			spawnwait 	SETTRIAL();		// see ALL_VARS.pro and DEFAULT.pro
			spawnwait 	WINDOWS();		// see ALL_VARS.pro and DEFAULT.pro	
			
			if (trialType == tMaskTrial)
				{
				spawnwait	MSK_PGS();
				spawnwait	MSKTRIAL();
				}
			else if (trialType == tBetTrial)
				{
				spawnwait	BET_PGS();
				spawnwait	BETTRIAL();
				}
			else if (trialType == tRetroTrial)
				{
				spawnwait	MSK_PGS();
				spawnwait	RETTRIAL();
				}
			else if (trialType == tProTrial)
				{
				spawnwait	MSK_PGS();
				spawnwait	PROTRIAL();
				}

			spawnwait 	REWARDS();			// end a trial with trialOutcome set in MEMTRIAL.pro
					
			lastMaskArray[targIndex] = lastOutcome;   // THIS NEEDS TO BE UPDATED BEFORE CALLING SETTRIAL, SINCE lastOutcome gets updated there based on the last outcome in a newly assigned discriminatory level
			nexttick;								// wait at least one cycle and do it all again
			
			while(Pause)							// gives the user the ability to pause the task without ending it
				{
				nexttick;
				}
			
			}
		}




				

		
	
	
	nexttick;						// if no task is specified idle for another process... 
									// ...cycle and then check again.
	}  // while (idling) loop
	oSetGraph(gleft,aCLEAR);					// clear the left graph
	oSetGraph(gright,aCLEAR);					// clear the right graph
	
	i = 1;
	while (i <= nObject)
		{
		oDestroy(i);
		i = i + 1;
		}
	idling = 1;
	spawn IDLE();  // kick it back to the top to reset stuff and start a new task

} // process



( KPED            	metacog.pro                                                                       d     ) p          | $H  S '  @Ez @E    (   x$  8 z      Z^Z^ Z^&Z^ Z^2Z^ jZ^Z^ >Z^J Z^Z^ JZ^J Z^Z^ VZ^>Z^JZ^ bZ^J Z^Z^ nZ^VZ^bZ^ nZ^  Z^zZ^   >Z^J Z^*Z^ >Z^  Z^Z^   >Z^J Z^Z^ >Z^  Z^Z^   >Z^J Z^6Z^ >Z^  Z^Z^ l  >Z^J Z^BZ^ >Z^  Z^Z^ H  >Z^J Z^NZ^ >Z^  Z^Z^ $  >Z^J Z^ZZ^ >Z^  Z^Z^ >Z^J Z^6Z^ >Z^* DZ^Z^DZ^Z^D*Z^Z^ f  >Z^J Z^BZ^ >Z^* DZ^Z^DZ^Z^D*Z^Z^ .  >Z^J Z^NZ^ >Z^ DZ^Z^DZ^Z^D6Z^Z^DBZ^Z^DNZ^Z^DZZ^Z^DfZ^Z^DrZ^Z^D~Z^Z^DZ^Z^ >	Z^Z^:  :  :  :  :  :  :  :  :  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  D
Z^Z^:   :   :   :   :   :   :   :   DZ^*Z^DZ^Z^DZ^Z^ 
Z^&Z^ 
Z^6Z^ 
Z^BZ^ 
Z^NZ^ Z^ZZ^ Z^fZ^ Z^rZ^ Z^NZ^ Z^6Z^ Z^BZ^ &Z^fZ^ 2Z^~Z^ >Z^Z^ JZ^Z^ VZ^fZ^ bZ^Z^ Z^Z^ Z^Z^:  :  :  :  :  :  :  :   6Z^Z^D*Z^Z^DZ^Z^DZ^Z^DZ^Z^CZ^Z^Z^$ ' Z^Z^ Z^&Z^ Z^Z^ Z^&Z^ Z^2Z^ BZ^Z^ *Z^>Z^ 6Z^JZ^ NZ^~Z^ ZZ^VZ^ fZ^rZ^ Z^&Z^ Z^~Z^ Z^bZ^ Z^&Z^ Z^nZ^ Z^^Z^ nZ^~Z^ Z^Z^ Z^Z^ Z^Z^ >Z^J Z^Z^ >Z^4 jZ^&Z^ 
Z^Z^;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  DZ^Z^DZ^Z^ Z^Z^ NZ^6Z^ fZ^Z^ >Z^J Z^Z^ >Z^H :  :  :  :  :  :  :  :   >Z^J Z^Z^ JZ^J Z^Z^ VZ^>Z^JZ^ bZ^J Z^*Z^ nZ^VZ^bZ^ Z^J Z^BZ^ "Z^nZ^Z^ .Z^J Z^NZ^ :Z^"Z^.Z^ FZ^J Z^ZZ^ RZ^:Z^FZ^ ^Z^J Z^Z^ jZ^RZ^^Z^ jZ^  Z^Z^ Z^vZ^ Z^Z^ >Z^J Z^Z^ >Z^ :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :   >Z^J Z^6Z^ >Z^  Z^6Z^ fZ^rZ^DJZ^*Z^: 8: 8: 8: 8: 8: 8: 8: 8: 8: 8: 8: 8:  :  :  :  :  :  :  :  : : : :  >Z^J Z^BZ^ >Z^ Z^&Z^ Z^Z^ Z^*Z^ Z^Z^ Z^Z^Z^ >Z^
Z^Z^ >Z^  DZ^RZ^DZ^Z^ J  >Z^
Z^&Z^ >Z^8 DZ^
Z^4  DZ^Z^DZ^*Z^DZ^Z^DZ^2Z^DJZ^*Z^DVZ^*Z^DZ^Z^DZ^Z^: 8: 8: 8: 8: 8: 8: 8: 8: 8: 8: 8: 8: : : : : : : : : : : 	: 	: 	: 	: 	: 	: 	: 	: 	: 	: : : : : : :  :  :  :  :  :  :  :  :  :  : : : : : : : : : :  *Z^rZ^ 6Z^Z^ >Z^J Z^NZ^ >Z^  Z^Z^ Z^*Z^ Z^*Z^ Z^Z^Z^DZ^Z^DZ^Z^DZ^&Z^DJZ^*Z^DVZ^*Z^: : : : : : : : : : :  :  :  : :  :  >Z^J Z^ZZ^ >Z^ DZ^Z^DZ^*Z^ Z^Z^ "Z^Z^ .Z^VZ^ :Z^Z^DZ^*Z^DJZ^*Z^DZ^*Z^: R: R: R: R: Q : Q : Q : Q DZ^bZ^D
Z^bZ^D	Z^*Z^ Z^Z^ >Z^Z^Z^ >Z^V ;  ~;  ~;  ~;  ~;  ~;  ~
 Z^Z^&Z^ :  :  :  :  	:  :  :  :  :  :  :  :  :  :  :   Z^&Z^: b: b: b: b: b: b
: b: b: b: b >Z^z Z^Z^ >Z^ Z^ D Z^Z^   &Z^ D Z^Z^ 
Z^&Z^ Z^nZ^D
Z^Z^ >Z^J Z^Z^ JZ^J Z^Z^ VZ^>Z^JZ^ bZ^J Z^Z^ nZ^VZ^bZ^ nZ^  Z^Z^   >Z^J Z^*Z^ >Z^  Z^zZ^   >Z^J Z^Z^ >Z^  Z^zZ^   >Z^J Z^6Z^ >Z^  Z^nZ^ l  >Z^J Z^BZ^ >Z^  Z^VZ^ H  >Z^J Z^NZ^ >Z^  Z^nZ^ $  >Z^J Z^ZZ^ >Z^  Z^Z^ >Z^J Z^*Z^ JZ^J Z^Z^ VZ^>Z^JZ^ VZ^F  BZ^*Z^ *Z^&Z^ 6Z^2Z^:  :  :  :   >Z^J Z^6Z^ >Z^* DZ^Z^DZ^Z^D*Z^Z^ f  >Z^J Z^BZ^ >Z^* DZ^Z^DZ^Z^D*Z^Z^ .  >Z^J Z^NZ^ >Z^ DZ^Z^DZ^Z^ >Z^J Z^6Z^ >Z^h : 8: 8: 8: 8: 8: 8: 8: 8: 8: 8: 8: 8 >Z^J Z^BZ^ >Z^DJZ^*Z^DVZ^Z^DZ^Z^DZ^Z^ 
Z^Z^ Z^Z^: 8!: 8": 8: 8$: 8&: 8: 8: 8: 8: 8: 8: 8: (: ): *: +: : : : : : : 	: 	: 	: 	: 	: 	: 	: 	: 	: 	: : : : : ,: , *Z^rZ^ 6Z^~Z^ >Z^z Z^Z^ >Z^DZ^RZ^ Z^&Z^ Z^2Z^ Z^nZ^ >Z^J Z^Z^ JZ^J Z^Z^ VZ^>Z^JZ^ bZ^J Z^Z^ nZ^VZ^bZ^ nZ^  Z^zZ^   >Z^J Z^*Z^ >Z^  Z^Z^   >Z^J Z^Z^ >Z^  Z^Z^   >Z^J Z^6Z^ >Z^  Z^*Z^ l  >Z^J Z^BZ^ >Z^  Z^ZZ^ H  >Z^J Z^NZ^ >Z^  Z^*Z^ $  >Z^J Z^ZZ^ >Z^  Z^*Z^ >Z^J Z^*Z^ JZ^J Z^Z^ VZ^>Z^JZ^ VZ^  BZ^*Z^ *Z^&Z^ 6Z^2Z^:  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :   >Z^J Z^*Z^ >Z^ DZ^Z^ >Z^J Z^BZ^ >Z^DZ^RZ^DJZ^*Z^DVZ^Z^DZ^Z^DZ^Z^ 
Z^Z^ Z^6Z^: 8!: 8": 8: 8$: 8&: 8: 8: 8: 8: 8: 8: 8: : : : : : : : : : : 	: 	: 	: 	: 	: 	: 	: 	: 	: 	: : : : : :  *Z^rZ^ 6Z^~Z^ >Z^J Z^fZ^ >Z^ Z^BZ^DZ^^Z^DZ^zZ^ Z^ZZ^ Z^Z^ Z^Z^: j: j: j: j: j: j: j: j: j: j: j: j: k: k: k: k: k: k: k: k: k: k: k: k: l: l: l: l: l: l: l: l: l: l: l: l; n1; n; n; n; n1; n; n; n; n1; n1; n; n1; n1; n1; n1; n; n1; n1; n ; n; n; n1; n1; n; n; n; n: o: o: o2: o3 >Z^z Z^rZ^ >Z^ DZ^RZ^ Z^&Z^ Z^2Z^ Z^nZ^ >Z^J Z^Z^ JZ^J Z^Z^ VZ^>Z^JZ^ bZ^J Z^Z^ nZ^VZ^bZ^ nZ^  Z^zZ^   >Z^J Z^*Z^ >Z^  Z^Z^   >Z^J Z^Z^ >Z^  Z^Z^   >Z^J Z^6Z^ >Z^  Z^*Z^ l  >Z^J Z^BZ^ >Z^  Z^ZZ^ H  >Z^J Z^NZ^ >Z^  Z^*Z^ $  >Z^J Z^ZZ^ >Z^  Z^*Z^ >Z^J Z^*Z^ JZ^J Z^Z^ VZ^>Z^JZ^ VZ^  BZ^*Z^ *Z^BZ^ 6Z^~Z^:  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :   >Z^J Z^*Z^ >Z^ DZ^Z^ >Z^J Z^BZ^ >Z^DZ^Z^DZ^Z^DZ^Z^CZ^ZZ^Z^DJZ^*Z^DVZ^Z^DZ^Z^DZ^Z^ 
Z^Z^ Z^6Z^: 8!: 8": 8: 8$: 8&: 8: 8: 8: 8: 8: 8: 8: : : : : : : : : : : 	: 	: 	: 	: 	: 	: 	: 	: 	: 	: : : : : : : 7: : : 9: :  *Z^rZ^ 6Z^~Z^ >Z^J Z^fZ^ >Z^ Z^BZ^DZ^^Z^DZ^Z^ Z^*Z^ Z^Z^ Z^Z^ Z^~Z^ Z^Z^ Z^Z^: j: j: j: j: j: j: j: j: j: j: j: j: k: k: k: k: k: k: k: k: k: k: k: k: l: l: l: l: l: l: l: l: l: l: l: l; n1; n; n; n; n1; n; n; n; n1; n1; n; n1; n1; n1; n1; n; n1; n1; n ; n; n; n1; n1; n; n; n; n: o: o: o2: o3 >Z^J Z^6Z^ >Z^PCZ^Z^Z^CZ^Z^*Z^CJZ^Z^ZZ^ JZ^2 $ A$ B$ C J Z^Z^$% D Z^Z^ 
Z^Z^ >Z^Z^zZ^ >Z^H 4  =CJZ^Z^Z^ JZ^ 
 
Z^
Z^&Z^
 Z^Z^&Z^ U Z^2Z^ &Z^2Z^ >Z^Z^*Z^ >Z^H 4 =CJZ^Z^Z^ JZ^ 
 &Z^&Z^&Z^
 Z^Z^&Z^  Z^Z^ rZ^Z^ >Z^Z^Z^ >Z^H 4 8=CJZ^Z^Z^ JZ^ 
 rZ^rZ^&Z^
 Z^Z^&Z^  >Z^rZ^&Z^4 8D~Z^Z^CZ^~Z^JZ^$ D~Z^Z^4 8DZ^Z^CZ^Z^JZ^$ DZ^Z^ >Z^~Z^NZ^ >Z^: $ G$ H$ I$ J J Z^Z^$% K
 >Z^Z^~Z^
 JZ^>Z^Z^
 VZ^JZ^Z^
 bZ^VZ^Z^ nZ^Z^2Z^
 Z^bZ^nZ^
 "Z^Z^ZZ^ .Z^Z^"Z^ .Z^ 
 :Z^Z^~Z^
 FZ^:Z^Z^
 RZ^FZ^Z^
 ^Z^RZ^Z^ jZ^Z^2Z^
 Z^^Z^jZ^
 Z^Z^ZZ^$ N$ O% PO >Z^J Z^BZ^ >Z^lCZ^Z^Z^CZ^Z^*Z^CJZ^Z^ZZ^ JZ^2 $ Q$ R$ S J Z^Z^$% T Z^Z^ 
Z^Z^ >Z^Z^zZ^ >Z^H 4  =CJZ^Z^Z^ JZ^ 
 
Z^
Z^&Z^
 Z^Z^&Z^   Z^Z^ &Z^Z^DZ^Z^ >Z^Z^*Z^ >Z^ 4 =CJZ^Z^Z^ VZ^Z^Z^ bZ^JZ^VZ^ bZ^0 
 &Z^&Z^&Z^4 	=CZ^Z^Z^ F 4 =C>Z^Z^Z^ >Z^, 
 &Z^&Z^&Z^4 	=CZ^Z^Z^
 Z^Z^&Z^  6 >Z^&Z^&Z^4 D2Z^Z^4 D>Z^Z^CZ^Z^Z^ Z^Z^ >Z^Z^&Z^ >Z^8 4 	=CZ^Z^Z^: 
=
 Z^Z^&Z^  Z^&Z^4 
:  >Z^Z^&Z^ >Z^`  JZ^Z^&Z^4 4 
=CZ^Z^Z^: U=4 =% V
 Z^Z^&Z^ Z^Z^ rZ^Z^ >Z^Z^Z^ >Z^H 4 8=CJZ^Z^Z^ JZ^ 
 rZ^rZ^&Z^
 Z^Z^&Z^   >Z^rZ^&Z^4 8D~Z^Z^CZ^~Z^JZ^$ D~Z^Z^4 8DZ^Z^CZ^Z^JZ^$ DZ^Z^ >Z^~Z^NZ^ >Z^: $ W$ X$ Y$ Z J Z^Z^$% [ Z^Z^ >Z^Z^*Z^ >Z^j  Z^Z^ >Z^Z^*Z^ >Z^8 ; =>; =>; =>
 Z^Z^&Z^
 Z^Z^&Z^
 >Z^Z^~Z^
 JZ^>Z^Z^
 VZ^JZ^Z^
 bZ^VZ^Z^ nZ^Z^2Z^
 Z^bZ^nZ^
 "Z^Z^ZZ^ .Z^Z^"Z^ .Z^ 
 :Z^Z^~Z^
 FZ^:Z^Z^
 RZ^FZ^Z^
 ^Z^RZ^Z^ jZ^Z^2Z^
 Z^^Z^jZ^
 Z^Z^ZZ^$ \$ ]% ^O >Z^J Z^NZ^ >Z^4CZ^Z^Z^CJZ^Z^ZZ^ JZ^2 $ _$ `$ a J Z^Z^$% b Z^Z^ 
Z^Z^ >Z^Z^zZ^ >Z^H 4  =CJZ^Z^Z^ JZ^ 
 
Z^
Z^&Z^
 Z^Z^&Z^ U Z^2Z^ &Z^2Z^ >Z^Z^*Z^ >Z^H 4 =CJZ^Z^Z^ JZ^ 
 &Z^&Z^&Z^
 Z^Z^&Z^   >Z^&Z^&Z^4 D2Z^Z^4 D>Z^Z^
 >Z^Z^Z^
 JZ^>Z^Z^
 VZ^JZ^Z^ bZ^Z^2Z^
 nZ^VZ^bZ^
 Z^nZ^ZZ^ "Z^Z^Z^ "Z^v 
 .Z^Z^Z^
 :Z^.Z^Z^
 FZ^:Z^Z^ RZ^Z^2Z^
 ^Z^FZ^RZ^
 Z^^Z^ZZ^$ c$ d% eO >Z^J Z^Z^ JZ^J Z^*Z^ VZ^>Z^JZ^ bZ^J Z^Z^ nZ^VZ^bZ^ nZ^r  Z^Z^ 
Z^Z^ >Z^Z^zZ^ >Z^H 4  =CJZ^Z^Z^ JZ^ 
 
Z^
Z^&Z^
 Z^Z^&Z^  >Z^J Z^Z^ >Z^r  Z^Z^ 
Z^Z^ >Z^Z^zZ^ >Z^H 4  =CJZ^Z^Z^ JZ^ 
 
Z^
Z^&Z^
 Z^Z^&Z^ 
 >Z^Z^~Z^
 JZ^>Z^Z^
 VZ^JZ^Z^
 bZ^VZ^Z^ nZ^Z^2Z^
 Z^bZ^nZ^
 "Z^Z^ZZ^ .Z^Z^"Z^ .Z^ 
 :Z^Z^~Z^
 FZ^:Z^Z^
 RZ^FZ^Z^
 ^Z^RZ^Z^ jZ^Z^2Z^
 Z^^Z^jZ^
 Z^Z^ZZ^$ f$ g% hO >Z^
Z^&Z^ >Z^H  
Z^NZ^ 
Z^BZ^ 
Z^6Z^ Z^rZ^ Z^fZ^ Z^ZZ^ @  
Z^ZZ^ 
Z^fZ^ 
Z^rZ^ Z^6Z^ Z^BZ^ Z^NZ^ >Z^J Z^ZZ^ >Z^ 
 JZ^Z^"Z^
 VZ^JZ^.Z^
 bZ^VZ^:Z^ nZ^bZ^ZZ^ nZ^2 $ i$ j$ k J Z^Z^$% l Z^Z^ 
Z^Z^ >Z^Z^RZ^ >Z^H 4 Q=CJZ^Z^Z^ JZ^ 
 
Z^
Z^&Z^
 Z^Z^&Z^  Z^Z^ Z^Z^ >Z^Z^*Z^ >Z^H 4 b= VZ^JZ^Z^ VZ^ 
 Z^Z^&Z^
 Z^Z^&Z^  6Z^Z^ BZ^&Z^ NZ^2Z^ *Z^Z^ >Z^*Z^zZ^ >Z^X 
 JZ^*Z^&Z^5  no5  np5  nq( r
 *Z^*Z^&Z^ U4  o4  p4  q' s4  o4  p4  q' t4  o4  p4  q' u4  o4  p4  q' v4  o4  p4  q' w4  o4  p4  q' x4  o4  p4  q' y4  o4  p4  q' z5 no5 np5 nq' {5 no5 np5 nq' |5 no5 np5 nq' }5 no5 np5 nq' ~5 no5 np5 nq' 5 no5 np5 nq' 5 no5 np5 nq' 5 no5 np5 nq' 5 no5 np5 nq' DZ^Z^DZ^Z^CZ^Z^ Z^$ $} CZ^Z^ Z^$ $} DZ^Z^DZ^Z^CZ^ZZ^Z^CZ^ZZ^Z^( CVZ^Z^Z^CbZ^Z^Z^DnZ^Z^DzZ^Z^ Z^!Z^%m  !Z^!Z^ !Z^Z^ !Z^!Z^ !Z^Z^)m &m 'i %l 'i %l 'i %l 'i %l 'i %l %l 'i %l %l 'i %l %l 'i %l 'i %l 'i %l 'i %l 'i %l 'i %l %l 'i %l %l CZ^2Z^VZ^CJZ^2Z^bZ^DVZ^Z^'i %l  Z^Z^ !Z^&Z^CZ^2Z^>Z^CZ^Z^~Z^C"Z^^Z^Z^%m C>Z^>Z^2Z^ >Z^  "Z^~Z^CZ^>Z^~Z^ >Z^"Z^zZ^C""Z^Z^>Z^CZ^2Z^~Z^ >Z^"Z^zZ^C."Z^Z^>Z^)m  :"Z^"Z^Z^&m 'i 	%l 'i 	%l 'i 	%l 'i 	%l 'i 	%l 'i 	%l 'i 	%l 'i 	%l 'i 	%l 'i 	%l  Z^!Z^: ": ": ": ": ": ": ": ": ": ": #: #: #: #: #: #: #: #: #: #: : : : : : : : : :  v"Z^"Z^ "Z^"Z^%  %  "Z^"Z^ "Z^"Z^%  % $ :  P  
 >Z^ Z^&Z^  Z^>Z^ Z^ #Z^"Z^ >Z^J Z^6Z^ >Z^  *#Z^2Z^   *#Z^&Z^ >Z^rZ^ZZ^ >Z^ $ 
 rZ^JZ^&Z^$ 
 #Z^&Z^>Z^ >Z^J Z^ZZ^ >Z^  #Z^#Z^ Z^ >Z^Z^Z^ >Z^ 
 rZ^rZ^#Z^ (  >Z^Z^Z^ >Z^  rZ^rZ^#Z^ >Z^#Z^&Z^ JZ^rZ^>Z^ JZ^  rZ^#Z^&Z^ >Z^rZ^Z^ >Z^  rZ^Z^$ 
 B#Z^&Z^>Z^ >Z^Z^f#Z^ >Z^D  Z#Z^&Z^&Z^ >Z^&Z^2Z^
 JZ^>Z^&Z^ N#Z^JZ^&Z^ N  >Z^Z^r#Z^ >Z^<  JZ^&Z^2Z^ VZ^JZ^&Z^ Z#Z^VZ^&Z^ N#Z^Z^ >Z^Z^Z^ JZ^Z^f#Z^ VZ^>Z^JZ^ VZ^:  Z^Z^B#Z^ >Z^Z^N#Z^ >Z^  Z^Z#Z^ , >Z^Z^Z^ JZ^Z^f#Z^ VZ^>Z^JZ^ VZ^: 
 Z^Z^B#Z^ >Z^Z^Z#Z^ >Z^  Z^Z#Z^   >Z^Z^Z^ JZ^Z^r#Z^ VZ^>Z^JZ^ VZ^: 
 Z^Z^B#Z^ >Z^Z^Z#Z^ >Z^  Z^Z#Z^ d  >Z^Z^Z^ JZ^Z^r#Z^ VZ^>Z^JZ^ VZ^6  Z^Z^B#Z^ >Z^Z^N#Z^ >Z^  Z^Z#Z^ >Z^Z^Z^D$Z^>Z^$ C$Z^>Z^>Z^ Z^0 CZ^$Z^%Z^CZ^%Z^Z^$   D$Z^$Z^C$Z^$Z^$Z^CZ^Z^$Z^$ D#Z^Z^ >Z^J Z^Z^ >Z^, 4  DZ^Z^4  DZ^Z^ >Z^J Z^Z^ JZ^J Z^Z^ VZ^>Z^JZ^ bZ^J Z^*Z^ nZ^VZ^bZ^ nZ^ "%Z^Z^D	Z^
Z^ >Z^"%Z^Z^ >Z^P $  4   JZ^>Z^Z^ JZ^$  "%Z^&Z^4  D	Z^Z^ U >Z^6Z^*Z^D
%Z^>Z^$ C$Z^>Z^>Z^ Z^0 CZ^$Z^%Z^CZ^%Z^Z^$   D$Z^$Z^C$Z^
%Z^$Z^CZ^*Z^$Z^$ DBZ^Z^ >Z^J Z^Z^ >Z^  ~#Z^Z^ "%Z^Z^ >Z^"%Z^Z^ >Z^ $ 4   JZ^>Z^Z^ JZ^d  "%Z^&Z^4  DNZ^Z^4  D	Z^Z^D	Z^NZ^CZ^	Z^%Z^CZ^RZ^Z^$ %h >Z^J Z^6Z^ >Z^*$ C$Z^JZ^>Z^C>Z^$Z^JZ^ >Z^  ~#Z^Z^   ~#Z^&Z^4  D	Z^Z^D	Z^
Z^ >Z^Z^ Z^ >Z^ D	Z^
Z^ &  Z^" $  4   D	Z^Z^$ #C^%Z^>Z^%Z^C>Z^^%Z^Z^ >Z^  Z^
Z^ p C>Z^^%Z^Z^CZ^Z^Z^CJZ^^%Z^Z^ VZ^>Z^JZ^ VZ^   Z^Z^ #Z^	Z^   Z^"Z^ #Z^	Z^ >	Z^  #Z^	Z^ Z^  >Z^Z^ Z^ >Z^4  "Z^rZ^	#Z^@ #Z^4 8 DZZ^Z^ `  Z^\ 4   rZ^>Z^4   Z^>Z^ "Z^rZ^	#Z^@ #Z^4 8 DZZ^Z^:     $  44 8 DZZ^Z^ >Z^J Z^BZ^ >Z^ "%Z^Z^ >Z^"%Z^Z^ >Z^$ C$Z^JZ^>Z^ Z^Z^ .%Z^Z^ >Z^.%Z^Z^ >Z^d 4 !CJZ^$Z^Z^ JZ^  .%Z^&Z^ 0 4 !C>Z^$Z^Z^ >Z^ 
 Z^Z^&Z^U FZ^Z^4 !D$Z^Z^D:Z^$Z^$ C$Z^>Z^>Z^C>Z^$Z^*Z^CJZ^$Z^VZ^ VZ^>Z^JZ^ VZ^  "%Z^&Z^$    C>Z^$Z^*Z^CJZ^$Z^JZ^ VZ^>Z^JZ^ VZ^   "%Z^&Z^ ~#Z^$Z^ J C>Z^$Z^*Z^CJZ^$Z^JZ^ VZ^>Z^JZ^ VZ^  "%Z^&Z^ ~#Z^$Z^ : >Z^~#Z^&Z^$ $   JZ^>Z^&Z^ JZ^$ 
 ~#Z^~#Z^2Z^
 "Z^"Z^2Z^4  D	Z^Z^4  D&	Z^Z^4  D	Z^Z^4  D2	Z^Z^ >Z^~#Z^Z^ JZ^~#Z^2Z^ VZ^>Z^JZ^ VZ^ CZ^	Z^Z^  CZ^	Z^Z^ >Z^
Z^&Z^ >Z^z CZ^Z^Z^C	Z^Z^bZ^$ CZ^>Z^>Z^C>Z^Z^Z^ >Z^  Z^~#Z^   Z^"Z^4  DZ^Z^$ #C^%Z^>Z^%Z^C>Z^^%Z^Z^ >Z^  Z^
Z^ p C>Z^^%Z^Z^CZ^Z^Z^CJZ^^%Z^Z^ VZ^>Z^JZ^ VZ^   Z^Z^ #Z^	Z^   Z^"Z^ #Z^	Z^ >	Z^  #Z^	Z^ >Z^Z^Z^ JZ^Z^"Z^ VZ^>Z^JZ^ VZ^  Z^` 4 ! rZ^bZ^4 ! Z^>Z^ "Z^rZ^	#Z^@ #Z^4 8 DZZ^Z^:  !  $  44 8 DZZ^Z^$ C$Z^>Z^>Z^ Z^0 CZ^$Z^%Z^CZ^%Z^Z^$   D$Z^$Z^C$Z^$Z^$Z^CZ^Z^$Z^$ D#Z^Z^ .Z^  >Z^6Z^*Z^D
%Z^>Z^$ C$Z^>Z^>Z^ Z^0 CZ^$Z^%Z^CZ^%Z^Z^$   D$Z^$Z^C$Z^
%Z^$Z^CZ^*Z^$Z^$ DBZ^Z^   BZ^Z^ >Z^J Z^NZ^ >Z^$ C$Z^JZ^>Z^C>Z^$Z^JZ^ >Z^  ~#Z^Z^   ~#Z^&Z^4  D	Z^Z^D	Z^
Z^$ #C^%Z^>Z^%Z^C>Z^^%Z^Z^ >Z^  Z^
Z^ N C>Z^^%Z^Z^CZ^Z^Z^CJZ^^%Z^Z^ VZ^>Z^JZ^ VZ^  Z^.Z^ Z^ 	 6#Z^@ 6#Z^  R%Z^Z^ >Z^R%Z^Z^ >Z^ $ $ ! FZ^Z^4 !DjZ^Z^D:Z^jZ^ >Z^Z^
Z^CJZ^jZ^*Z^ VZ^>Z^JZ^ VZ^  R%Z^&Z^ r  >Z^Z^.Z^CJZ^jZ^*Z^ VZ^>Z^JZ^ VZ^  R%Z^&Z^ 2 C>Z^jZ^*Z^ JZ^>Z^F%Z^ JZ^  R%Z^&Z^$ C$Z^>Z^>Z^ Z^0 CZ^$Z^%Z^CZ^%Z^Z^$   D$Z^$Z^C$Z^$Z^$Z^CZ^Z^$Z^$ D#Z^Z^ >Z^J Z^ZZ^ >Z^$ #C^%Z^JZ^%Z^ >Z^^%Z^Z^ >Z^  Z^:Z^ F >Z^^%Z^Z^
 JZ^Z^"Z^ VZ^^%Z^JZ^ bZ^>Z^VZ^ bZ^d  Z^FZ^DZ^Z^$ C$Z^>Z^>Z^C>Z^$Z^Z^ >Z^  ~Z^Z^   ~Z^VZ^  
 >Z^Z^"Z^ JZ^^%Z^>Z^
 VZ^Z^"Z^
 bZ^VZ^.Z^ nZ^^%Z^bZ^ Z^JZ^nZ^ Z^  Z^RZ^ @ 
 >Z^Z^"Z^
 JZ^>Z^.Z^ VZ^^%Z^JZ^ VZ^  Z^^Z^D	Z^
Z^ j%Z^Z^ >Z^j%Z^
Z^ >Z^" : Q 
 j%Z^j%Z^&Z^ >Z^Z^FZ^ >Z^$ C$Z^JZ^>Z^ >Z^
Z^2Z^ >Z^: CJZ^$Z^JZ^ JZ^  ~#Z^Z^   ~#Z^&Z^ R  >Z^
Z^RZ^ >Z^@ CJZ^$Z^JZ^ JZ^ $   $ 
 ~#Z^>Z^2Z^4 RD	Z^Z^ >Z^
Z^2Z^ >Z^"  JZ^~#Z^2Z^$    >Z^
Z^RZ^ >Z^  JZ^~#Z^Z^ JZ^*  #Z^&Z^ #Z^2Z^ #Z^FZ^   >Z^~#Z^&Z^ >Z^*  #Z^Z^ #Z^2Z^ #Z^FZ^ p  >Z^~#Z^2Z^ >Z^*  #Z^Z^ #Z^&Z^ #Z^FZ^ 8  >Z^~#Z^FZ^ >Z^&  #Z^Z^ #Z^&Z^ #Z^2Z^ >Z^Z^:Z^ >Z^$ C$Z^JZ^>Z^ >Z^
Z^2Z^ >Z^P CJZ^$Z^Z^ JZ^  #Z^Z^   #Z^&Z^ >Z^#Z^2Z^$  n  >Z^
Z^RZ^ >Z^\ CJZ^$Z^Z^ JZ^" $ 
 #Z^#Z^2Z^ ( $ 
 #Z^>Z^2Z^ #Z^#Z^2Z^DvZ^	Z^DZ^	Z^4 RDRZ^Z^4 RD^Z^Z^$ C$Z^>Z^>Z^ Z^0 CZ^$Z^%Z^CZ^%Z^Z^$   D$Z^$Z^C$Z^$Z^$Z^CZ^Z^$Z^$ D#Z^Z^ >Z^Z^FZ^ >Z^ Z^N 4 g rZ^JZ^4 f Z^>Z^ "Z^Z^	#Z^@ #Z^: g   $  c4 b  BZ^>Z^$ C$Z^>Z^>Z^ Z^0 CZ^$Z^%Z^CZ^%Z^Z^$   D$Z^$Z^C$Z^$Z^$Z^CZ^Z^$Z^$ D#Z^Z^ >Z^Z^^Z^ >Z^ $ C$Z^JZ^>Z^ Z^0 CZ^$Z^%Z^CZ^%Z^Z^$   D$Z^$Z^C$Z^$Z^$Z^CZ^Z^$Z^$ D#Z^Z^ >Z^J Z^fZ^ >Z^ "%Z^Z^C	Z^
Z^%Z^ &$Z^Z^ >$Z^Z^ >Z^"%Z^Z^ >Z^R JZ^&$Z^Z^ JZ^h $ 4 m4 l VZ^>Z^JZ^ VZ^6  &$Z^&Z^4 j $Z^>Z^4 k $Z^>Z^  $Z^Z^: 	: 	: 	: 	: 	: 	: 	: 	 >Z^$Z^^Z^ >Z^  2$Z^Z^ >Z^2$Z^Z^ >Z^D $ 4 	 JZ^>Z^&Z^ JZ^  2$Z^&Z^: 	 >Z^$Z^$Z^ >Z^"  JZ^%Z^V$Z^: q <  >Z^$Z^^Z^ >Z^"  JZ^%Z^V$Z^: q  : q 
 $Z^$Z^&Z^  $Z^Z^: 
: 
: 
: 
: 
: 
: 
: 
 >Z^$Z^RZ^ >Z^  >$Z^Z^ >Z^>$Z^Z^ >Z^D $ 4 
 JZ^>Z^&Z^ JZ^  >$Z^&Z^: 
U4 o: p
 $Z^$Z^&Z^ p >Z^$Z^&Z^ >Z^: 4 q $Z^JZ^4 pD	Z^Z^DZ^	Z^ @  >Z^$Z^2Z^ >Z^. 4 q $Z^JZ^D	Z^Z^DZ^Z^ "%Z^&Z^4 q% '4 p% (% ) U$y  C'Z^Z^Z^$x  CZ^Z^Z^C'Z^Z^ZZ^CZ^'Z^VZ^CJZ^'Z^bZ^DVZ^Z^&k CZ^'Z^VZ^CJZ^'Z^bZ^DVZ^Z^&k CZ^&Z^VZ^CJZ^&Z^bZ^DVZ^Z^'l $y  C'Z^Z^	Z^$x  CZ^Z^	Z^C'Z^Z^ZZ^CZ^'Z^VZ^CJZ^'Z^bZ^DVZ^Z^&k CZ^'Z^VZ^CJZ^'Z^bZ^DVZ^Z^&k CZ^	Z^VZ^CJZ^	Z^bZ^DVZ^Z^'l  Z^$ CZ^	Z^(Z^CZ^RZ^Z^CZ^Z^2Z^C%Z^'Z^Z^CZ^Z^2Z^C&Z^'Z^Z^CZ^Z^2Z^C&Z^'Z^Z^CZ^Z^2Z^C&Z^'Z^Z^CZ^Z^2Z^C*&Z^'Z^Z^CZ^Z^2Z^CB&Z^'Z^Z^CZ^Z^2Z^C6&Z^'Z^Z^CZ^Z^2Z^CN&Z^'Z^Z^ >Z^J Z^BZ^ >Z^$y  C'Z^Z^2	Z^$x  CZ^Z^2	Z^C'Z^Z^ZZ^CZ^'Z^VZ^CJZ^'Z^bZ^DVZ^Z^&k CZ^Z^2Z^CZ&Z^'Z^Z^CZ^Z^2Z^Cr&Z^'Z^Z^CZ^Z^2Z^Cf&Z^'Z^Z^CZ^Z^2Z^C~&Z^'Z^Z^$y  C'Z^Z^Z^$x  CZ^ZZ^Z^C
(Z^Z^Z^CZ^'Z^VZ^CJZ^
(Z^bZ^DVZ^Z^&k CZ^'Z^VZ^CJZ^
(Z^bZ^DVZ^Z^&k CZ^Z^2Z^C&Z^'Z^Z^CZ^Z^2Z^C&Z^
(Z^Z^CZ^Z^2Z^C&Z^'Z^Z^CZ^Z^2Z^C&Z^
(Z^Z^ >Z^J Z^ZZ^ >Z^ JZ^Z^FZ^ JZ^\4 R$y 4 QUC(Z^Z^Z^4 R$x CZ^ZZ^Z^4 QgC"(Z^Z^(Z^CZ^(Z^VZ^CJZ^"(Z^bZ^DVZ^Z^&k CZ^Z^2Z^C'Z^(Z^Z^CZ^Z^2Z^C2'Z^"(Z^Z^CZ^Z^2Z^C&'Z^(Z^Z^CZ^Z^2Z^C>'Z^"(Z^Z^ >Z^
Z^RZ^ >Z^ 4 R$y 4 QUC.(Z^Z^Z^4 R$x CZ^ZZ^Z^4 QgC:(Z^Z^(Z^CZ^.(Z^VZ^CJZ^:(Z^bZ^DVZ^Z^&k 4 R$y 4 QUCF(Z^Z^Z^4 R$x CZ^ZZ^Z^4 QgCR(Z^Z^(Z^CZ^F(Z^VZ^CJZ^R(Z^bZ^DVZ^Z^&k CZ^Z^2Z^CJ'Z^.(Z^Z^CZ^Z^2Z^Cb'Z^:(Z^Z^CZ^Z^2Z^CV'Z^.(Z^Z^CZ^Z^2Z^Cn'Z^:(Z^Z^CZ^Z^2Z^Cz'Z^F(Z^Z^CZ^Z^2Z^C'Z^R(Z^Z^CZ^Z^2Z^C'Z^F(Z^Z^CZ^Z^2Z^C'Z^R(Z^Z^ >Z^vZ^&Z^CJZ^Z^(Z^ VZ^>Z^JZ^ VZ^ CZ^Z^VZ^CnZ^Z^bZ^DZ^Z^'l %l CZ^Z^VZ^CJZ^Z^bZ^DVZ^Z^'l %l  >Z^
Z^RZ^ >Z^ CZ^Z^VZ^CVZ^Z^bZ^DbZ^Z^'l %l CZ^Z^VZ^CJZ^Z^bZ^DVZ^Z^'l %l D(Z^Z^ >Z^Z^:Z^ >Z^D$y \C^(Z^Z^vZ^$x \CZ^Z^vZ^Cj(Z^Z^ZZ^CZ^^(Z^VZ^CJZ^j(Z^bZ^DVZ^Z^&k CZ^^(Z^VZ^CJZ^j(Z^bZ^DVZ^Z^&k CZ^	Z^VZ^CJZ^	Z^bZ^DVZ^Z^'l CZ^Z^2Z^C&Z^^(Z^Z^CZ^Z^2Z^C&Z^j(Z^Z^CZ^Z^2Z^C&Z^^(Z^Z^CZ^Z^2Z^C&Z^j(Z^Z^$y ]Cv(Z^Z^Z^$x ]CZ^Z^Z^C(Z^Z^ZZ^CZ^v(Z^VZ^CJZ^(Z^bZ^DVZ^Z^&k CZ^v(Z^VZ^CJZ^(Z^bZ^DVZ^Z^&k CZ^	Z^VZ^CJZ^	Z^bZ^DVZ^Z^'l CZ^Z^2Z^C&Z^v(Z^Z^CZ^Z^2Z^C'Z^(Z^Z^CZ^Z^2Z^C&Z^v(Z^Z^CZ^Z^2Z^C'Z^(Z^Z^ >Z^vZ^&Z^CJZ^Z^(Z^ VZ^>Z^JZ^ VZ^ CZ^Z^VZ^CnZ^Z^bZ^DZ^Z^'l %l CZ^Z^VZ^CJZ^Z^bZ^DVZ^Z^'l %l D(Z^Z^ >Z^vZ^&Z^CJZ^Z^(Z^ VZ^>Z^JZ^ VZ^P CZ^Z^VZ^CnZ^Z^bZ^DZ^Z^'l %l D(Z^Z^ >Z^vZ^&Z^CJZ^Z^(Z^ VZ^>Z^JZ^ VZ^ CZ^Z^VZ^CnZ^Z^bZ^DZ^Z^'l %l D(Z^Z^ >Z^J Z^BZ^ >Z^F CZ^Z^VZ^CVZ^Z^bZ^DbZ^Z^'l %l  >Z^J Z^BZ^ >Z^  JZ^vZ^&Z^CVZ^Z^(Z^ bZ^JZ^VZ^ bZ^P CZ^Z^VZ^CZ^Z^bZ^D"Z^Z^'l %l D(Z^Z^ >Z^J Z^fZ^ >Z^H JZ^$Z^&Z^ JZ^: 4 q $Z^VZ^4 pD	Z^Z^D	Z^Z^ @  >Z^$Z^2Z^ >Z^. 4 q $Z^JZ^D	Z^Z^D	Z^Z^% i $y  C'Z^Z^	Z^$x  CZ^Z^	Z^C'Z^Z^ZZ^CZ^'Z^VZ^CJZ^'Z^bZ^DVZ^Z^&k CZ^'Z^VZ^CJZ^'Z^bZ^DVZ^Z^&k CZ^	Z^VZ^CJZ^	Z^bZ^DVZ^Z^'l CZ^Z^2Z^C%Z^'Z^Z^CZ^Z^2Z^C&Z^'Z^Z^CZ^Z^2Z^C&Z^'Z^Z^CZ^Z^2Z^C&Z^'Z^Z^CZ^Z^2Z^C*&Z^'Z^Z^CZ^Z^2Z^CB&Z^'Z^Z^CZ^Z^2Z^C6&Z^'Z^Z^CZ^Z^2Z^CN&Z^'Z^Z^DN)Z^Z)Z^Df)Z^r)Z^C>Z^N)Z^%Z^CJZ^N)Z^&Z^ VZ^>Z^JZ^CbZ^f)Z^&Z^ nZ^VZ^bZ^CZ^f)Z^&Z^ "Z^nZ^Z^ "Z^  (Z^&Z^   (Z^Z^C>Z^N)Z^*&Z^CJZ^N)Z^6&Z^ VZ^>Z^JZ^CbZ^f)Z^B&Z^ nZ^VZ^bZ^CZ^f)Z^N&Z^ "Z^nZ^Z^ "Z^  )Z^&Z^   )Z^Z^ >Z^J Z^BZ^ >Z^CJZ^N)Z^Z&Z^CVZ^N)Z^f&Z^ bZ^JZ^VZ^CnZ^f)Z^r&Z^ Z^bZ^nZ^C"Z^f)Z^~&Z^ .Z^Z^"Z^ .Z^  )Z^&Z^   )Z^Z^C>Z^N)Z^&Z^CJZ^N)Z^&Z^ VZ^>Z^JZ^CbZ^f)Z^&Z^ nZ^VZ^bZ^CZ^f)Z^&Z^ "Z^nZ^Z^ "Z^  )Z^&Z^   )Z^Z^ >Z^J Z^ZZ^ >Z^H JZ^Z^FZ^ JZ^ VZ^
Z^2Z^ VZ^ CbZ^N)Z^'Z^CnZ^N)Z^&'Z^ Z^bZ^nZ^C"Z^f)Z^2'Z^ .Z^Z^"Z^C:Z^f)Z^>'Z^ FZ^.Z^:Z^ FZ^  )Z^&Z^   )Z^Z^ >Z^
Z^RZ^ >Z^jCJZ^N)Z^'Z^CVZ^N)Z^&'Z^ bZ^JZ^VZ^CnZ^f)Z^2'Z^ Z^bZ^nZ^C"Z^f)Z^>'Z^ .Z^Z^"Z^C:Z^N)Z^J'Z^CFZ^N)Z^V'Z^ RZ^:Z^FZ^C^Z^f)Z^b'Z^ jZ^RZ^^Z^CZ^f)Z^n'Z^ Z^jZ^Z^ ~)Z^.Z^Z^C)Z^N)Z^z'Z^C)Z^N)Z^'Z^ )Z^)Z^)Z^C)Z^f)Z^'Z^ )Z^)Z^)Z^C)Z^f)Z^'Z^ )Z^)Z^)Z^ )Z^~)Z^)Z^ )Z^  )Z^&Z^   )Z^Z^ >Z^Z^:Z^ >Z^CJZ^N)Z^&Z^CVZ^N)Z^&Z^ bZ^JZ^VZ^CnZ^f)Z^&Z^ Z^bZ^nZ^C"Z^f)Z^&Z^ .Z^Z^"Z^ .Z^  *)Z^&Z^   *)Z^Z^C>Z^N)Z^&Z^CJZ^N)Z^&Z^ VZ^>Z^JZ^CbZ^f)Z^'Z^ nZ^VZ^bZ^CZ^f)Z^'Z^ "Z^nZ^Z^ "Z^  6)Z^&Z^   6)Z^Z^ &Z^$:   D*Z^>Z^$: ! D*Z^>Z^CZ^*Z^b*Z^CZ^Z^:Z^C*Z^Z^RZ^CZ^*Z^b*Z^CZ^Z^FZ^C*Z^Z^^Z^ )Z^. CRZ^RZ^*Z^C^Z^^Z^*Z^ )Z^Z^CJ*Z^*Z^VZ^CV*Z^*Z^bZ^C>Z^J*Z^&*Z^CJZ^V*Z^2*Z^ VZ^>Z^JZ^ VZ^ DZ)Z^*Z^Dr)Z^*Z^	B)Z^# ) 
 JZ^>*Z^Z^ VZ^>Z^JZ^ VZ^ &k  )Z^~ $  >Z^J*Z^RZ^ JZ^ZZ^V*Z^ VZ^JZ^RZ^
 bZ^J*Z^FZ^ nZ^ZZ^V*Z^
 Z^nZ^FZ^( % # ) D&*Z^J*Z^D2*Z^V*Z^ U *Z^"Z^ *Z^"Z^ *Z^*Z^*Z^$  $  "Z^*Z^ "Z^*Z^	*Z^@ *Z^ "Z^*Z^ "Z^*Z^	*Z^@ *Z^ "Z^*Z^ "Z^*Z^	*Z^@ *Z^ "Z^
+Z^ "Z^*Z^	*Z^@ *Z^ "Z^~Z^ "Z^*Z^	*Z^@ *Z^ "Z^+Z^ "Z^*Z^	*Z^@ *Z^ "Z^~Z^ "Z^*Z^	*Z^@ *Z^ "Z^&Z^ "Z^*Z^	*Z^@ *Z^ "Z^"+Z^ "Z^*Z^	*Z^@ *Z^$:  JZ^>Z^R+Z^ JZ^  v+Z^j+Z^ +Z^j+Z^ >Z^Z^.+Z^ >Z^T$:  >Z^+Z^R+Z^ >Z^x  v+Z^j+Z^ Z^b # ) 
 JZ^+Z^fZ^ VZ^>Z^JZ^ VZ^8 	 *Z^ >Z^zZ^Z^ >Z^ 
 zZ^zZ^&Z^# )  $  >Z^+Z^R+Z^ >Z^  v+Z^^+Z^ >Z^v+Z^+Z^ >Z^  JZ^v+Z^j+Z^ JZ^0 :  T  
 >Z^ Z^&Z^  Z^>Z^ Z^ >  >Z^v+Z^^+Z^ >Z^, :  U  
 >Z^ Z^&Z^  Z^>Z^ Z^ +Z^v+Z^  >Z^Z^.+Z^ >Z^  +Z^Z^ >Z^+Z^+Z^ >Z^l &>  JZ^F  VZ^zZ^Z^ VZ^ 
 zZ^zZ^&Z^ "Z^2Z^ "Z^Z^	*Z^
 +Z^+Z^&Z^ d$F  	$F $F  	$F $F  	$F $F  	$F $F 5 	$F $F  	$F $F  	$F $F  	$F $F  	$F $F 5 $F D+Z^Z)Z^D,Z^r)Z^D,Z^,Z^ *,Z^6,Z^ B,Z^N,Z^DZ,Z^f,Z^Dr,Z^~,Z^$y C,Z^Z^,Z^$x C,Z^Z^,Z^C,Z^+Z^2Z^CZ^,Z^,Z^CZ^Z^Z,Z^$ UD,Z^Z^CZ^,Z^,Z^CZ^Z^r,Z^$ UD,Z^Z^CZ^,Z^,Z^CZ^Z^Z,Z^$ UD,Z^Z^CZ^,Z^,Z^CZ^Z^r,Z^$ UD,Z^Z^%  >Z^B,Z^Z^ >Z^ (   (  &-Z^"Z^ ^.Z^Z^ j.Z^&Z^ v.Z^2Z^$y  CZ^Z^Z^C:.Z^Z^VZ^$x  CZ^Z^Z^CF.Z^Z^bZ^CR.Z^Z^Z^C-Z^R.Z^VZ^C-Z^R.Z^bZ^ >Z^&-Z^&Z^ >Z^8 JZ^~#Z^$Z^
 VZ^$Z^2Z^ bZ^~#Z^VZ^ nZ^JZ^bZ^ nZ^  .Z^Z^ /Z^&Z^4 !CZ/Z^Z^Z^4  .Z^>Z^4  .Z^>Z^4  .Z^>Z^4  .Z^>Z^4  .Z^>Z^4  .Z^>Z^   >Z^~#Z^$Z^
 JZ^$Z^2Z^ VZ^~#Z^JZ^ bZ^>Z^VZ^ bZ^  .Z^&Z^ /Z^Z^4 !DZ/Z^Z^4  .Z^>Z^4  .Z^>Z^4  .Z^>Z^4  .Z^>Z^4  .Z^>Z^4  .Z^>Z^ 2-Z^Z^ >Z^2-Z^Z^ >Z^" : 
 2-Z^2-Z^&Z^D/Z^Z^CZ^Z/Z^Z^$ CZ^/Z^/Z^$ CZ^/Z^/Z^$  J-Z^&Z^ >Z^J-Z^Z^ >Z^$  >Z^B/Z^Z^ >Z^ DN/Z^*/Z^ $  >Z^B/Z^&Z^ >Z^ DN/Z^6/Z^ V-Z^&Z^ >Z^V-Z^N/Z^ >Z^Z  JZ^J-Z^&Z^ VZ^JZ^Z^ bZ^V-Z^&Z^
 2-Z^VZ^bZ^: 
 V-Z^V-Z^&Z^U V-Z^&Z^ >Z^V-Z^Z^ >Z^  JZ^J-Z^&Z^ VZ^JZ^Z^ bZ^V-Z^&Z^
 2-Z^VZ^bZ^ >Z^J-Z^&Z^ JZ^>Z^Z^$  
 b-Z^JZ^VZ^4  n-Z^>Z^4 : : 
 V-Z^V-Z^&Z^HC/Z^/Z^&Z^C/Z^/Z^N/Z^CZ^/Z^/Z^$ CZ^/Z^/Z^$ 
 J-Z^J-Z^&Z^UCZ^R.Z^2Z^C-Z^:.Z^Z^CZ^R.Z^2Z^C-Z^F.Z^Z^CZ^R.Z^2Z^CZ^:.Z^Z^C-Z^Z^&Z^CZ^R.Z^2Z^CZ^F.Z^Z^C.Z^Z^&Z^: : : 4 4 4 '  -Z^ZZ^% (   J-Z^&Z^ >Z^J-Z^Z^ >Z^ V-Z^&Z^ >Z^V-Z^Z^ >Z^b JZ^J-Z^&Z^ VZ^Z^JZ^
 bZ^V-Z^VZ^ z-Z^bZ^&Z^4  JZ^>Z^/Z^ JZ^ : : : 4 4 4 '  -Z^/Z^ >Z^V-Z^&Z^CZ^Z^>Z^C-Z^-Z^Z^ >Z^J-Z^&Z^CZ^Z^>Z^C-Z^-Z^Z^CZ^Z^&Z^C-Z^-Z^Z^CZ^Z^&Z^C
.Z^-Z^Z^% ( 
 V-Z^V-Z^&Z^ (
 J-Z^J-Z^&Z^ ^ /Z^"Z^ :1Z^Z^ F1Z^&Z^ R1Z^2Z^$y  CZ^Z^Z^C1Z^Z^VZ^$x  CZ^Z^Z^C"1Z^Z^bZ^C.1Z^Z^Z^C-Z^.1Z^VZ^C-Z^.1Z^bZ^ >Z^/Z^&Z^ >Z^ JZ^/Z^/Z^ JZ^b4  ^1Z^VZ^4  j1Z^>Z^4  v1Z^>Z^4   1Z^>Z^4   1Z^>Z^4   1Z^>Z^ /Z^Z^ >Z^/Z^Z^ >Z^" : 
 /Z^/Z^&Z^4 !C0Z^Z^Z^ 0Z^Z^C>Z^0Z^0Z^ >Z^" : 
 0Z^0Z^&Z^U /Z^Z^ >Z^/Z^Z^ >Z^L $  4  J0Z^>Z^4 : : 
 /Z^/Z^&Z^  >Z^/Z^/Z^ >Z^p4   ^1Z^JZ^4   j1Z^>Z^4   v1Z^>Z^4  1Z^>Z^4  1Z^>Z^4  1Z^>Z^ /Z^Z^ >Z^/Z^Z^ >Z^" : 
 /Z^/Z^&Z^U4 !CZ^&Z^Z^C
1Z^Z^Z^ 0Z^Z^C>Z^0Z^
1Z^ >Z^" : 
 0Z^0Z^&Z^U /Z^Z^ >Z^/Z^Z^ >Z^L $  4  J0Z^>Z^4 : : 
 /Z^/Z^&Z^-CZ^.1Z^2Z^C0Z^1Z^Z^CZ^.1Z^2Z^C0Z^"1Z^Z^CZ^.1Z^2Z^CZ^1Z^Z^C0Z^Z^&Z^CZ^.1Z^2Z^CZ^"1Z^Z^C0Z^Z^&Z^: #: #: #4 #4 #4 #' $ b0Z^ZZ^% %( &  &0Z^&Z^ >Z^&0Z^Z^ >Z^ 20Z^&Z^ >Z^20Z^Z^ >Z^ JZ^&0Z^&Z^ VZ^Z^JZ^
 bZ^20Z^VZ^ V0Z^bZ^&Z^ >Z^/Z^/Z^ >Z^4  VZ^JZ^/Z^ VZ^ : # : #!: #"4 #4 #4 #' ' b0Z^/Z^ >Z^20Z^&Z^CZ^Z^>Z^C0Z^0Z^Z^ >Z^&0Z^&Z^CZ^Z^>Z^C0Z^0Z^Z^CZ^Z^&Z^C0Z^0Z^Z^CZ^Z^&Z^C0Z^0Z^Z^% (( ) & >Z^/Z^/Z^ >Z^4  VZ^JZ^/Z^ VZ^ : # : #!: #"4 #4 #4 #' * b0Z^/Z^ >Z^20Z^&Z^CZ^Z^>Z^C0Z^0Z^Z^ >Z^&0Z^&Z^CZ^Z^>Z^C0Z^0Z^Z^CZ^Z^&Z^C0Z^0Z^Z^CZ^Z^&Z^C0Z^0Z^Z^% +( ,
 20Z^20Z^&Z^ Z
 &0Z^&0Z^&Z^ U& >Z^Z^^Z^ >Z^  2Z^"
Z^   2Z^	Z^
 	Z^~#Z^&Z^DZ^2Z^DZ^2Z^CZ^Z^Z^CZ^Z^Z^CZ^Z^Z^$~  UCZ^Z^Z^$ $}  CZ^Z^Z^& <//$ =DZ)Z^Z^Dr)Z^Z^D,Z^Z^ 6,Z^2Z^ N,Z^Z^Df,Z^VZ^D~,Z^bZ^	+Z^@ +Z^DZ)Z^
Z^Dr)Z^Z^D,Z^Z^ 6,Z^Z^ N,Z^Z^Df,Z^nZ^D~,Z^zZ^	+Z^@ +Z^ & >00$ ?DZ)Z^Z^Dr)Z^Z^D,Z^Z^ 6,Z^2Z^ N,Z^Z^Df,Z^VZ^D~,Z^bZ^	+Z^@ +Z^ & @11$ ADZ)Z^Z^Dr)Z^Z^D,Z^Z^ 6,Z^2Z^ N,Z^Z^Df,Z^VZ^D~,Z^bZ^	+Z^@ +Z^DZ)Z^	Z^Dr)Z^	Z^D,Z^	Z^ 6,Z^	Z^ N,Z^Z^Df,Z^VZ^D~,Z^bZ^	+Z^@ +Z^ & B22$ CDZ)Z^Z^Dr)Z^Z^D,Z^Z^ 6,Z^2Z^ N,Z^Z^Df,Z^VZ^D~,Z^bZ^	+Z^@ +Z^ 2Z^Z^ >Z^2Z^
Z^ >Z^| DZ)Z^Z^4 R6Dr)Z^Z^4 Q6D,Z^Z^ 6,Z^	Z^ N,Z^Z^Df,Z^VZ^D~,Z^bZ^	+Z^@ +Z^
 2Z^2Z^&Z^zDZ)Z^
Z^Dr)Z^Z^D,Z^Z^ 6,Z^Z^ N,Z^Z^Df,Z^nZ^D~,Z^zZ^	+Z^@ +Z^ & D33$ EDZ)Z^Z^Dr)Z^Z^D,Z^Z^ 6,Z^2Z^ N,Z^Z^Df,Z^VZ^D~,Z^bZ^	+Z^@ +Z^ 2Z^Z^ >Z^2Z^
Z^ >Z^| DZ)Z^Z^4 R6Dr)Z^Z^4 Q6D,Z^Z^ 6,Z^	Z^ N,Z^Z^Df,Z^VZ^D~,Z^bZ^	+Z^@ +Z^
 2Z^2Z^&Z^ z & F44$ G 2Z^Z^ >Z^2Z^
Z^ >Z^| DZ)Z^Z^4 R6Dr)Z^Z^4 Q6D,Z^Z^ 6,Z^	Z^ N,Z^Z^Df,Z^VZ^D~,Z^bZ^	+Z^@ +Z^
 2Z^2Z^&Z^ zDZ)Z^
Z^Dr)Z^Z^D,Z^Z^ 6,Z^Z^ N,Z^Z^Df,Z^nZ^D~,Z^zZ^	+Z^@ +Z^ & H55$ I 2Z^Z^ >Z^2Z^
Z^ >Z^| DZ)Z^Z^4 R6Dr)Z^Z^4 Q6D,Z^Z^ 6,Z^	Z^ N,Z^Z^Df,Z^VZ^D~,Z^bZ^	+Z^@ +Z^
 2Z^2Z^&Z^z & J..$ KDZ^2Z^DZ^2Z^CZ^Z^Z^CZ^Z^Z^CZ^Z^Z^$~  UCZ^Z^Z^$ $}  CZ^Z^Z^& SOO$ TDZ)Z^Z^Dr)Z^Z^D,Z^Z^ 6,Z^	Z^ N,Z^Z^Df,Z^VZ^D~,Z^bZ^	+Z^@ +Z^DZ)Z^
Z^Dr)Z^Z^D,Z^Z^ 6,Z^Z^ N,Z^Z^Df,Z^nZ^D~,Z^zZ^	+Z^@ +Z^ & UPP$ VDZ)Z^Z^Dr)Z^Z^D,Z^Z^ 6,Z^	Z^ N,Z^Z^Df,Z^VZ^D~,Z^bZ^	+Z^@ +Z^ & WQQ$ XDZ)Z^Z^Dr)Z^Z^D,Z^Z^ 6,Z^	Z^ N,Z^Z^Df,Z^VZ^D~,Z^bZ^	+Z^@ +Z^DZ)Z^
Z^Dr)Z^RZ^D,Z^vZ^ 6,Z^	Z^ N,Z^Z^Df,Z^VZ^D~,Z^bZ^	+Z^@ +Z^DZ)Z^
Z^Dr)Z^^Z^D,Z^Z^ 6,Z^

Z^ N,Z^Z^Df,Z^VZ^D~,Z^bZ^	+Z^@ +Z^DZ)Z^
Z^Dr)Z^Z^D,Z^Z^ 6,Z^Z^ N,Z^Z^Df,Z^nZ^D~,Z^zZ^	+Z^@ +Z^ & YRR$ ZDZ)Z^Z^Dr)Z^Z^D,Z^Z^ 6,Z^	Z^ N,Z^Z^Df,Z^VZ^D~,Z^bZ^	+Z^@ +Z^DZ)Z^
Z^Dr)Z^RZ^D,Z^vZ^ 6,Z^	Z^ N,Z^Z^Df,Z^VZ^D~,Z^bZ^	+Z^@ +Z^DZ)Z^
Z^Dr)Z^^Z^D,Z^Z^ 6,Z^

Z^ N,Z^Z^Df,Z^VZ^D~,Z^bZ^	+Z^@ +Z^ & [MM$ \DZ^2Z^DZ^2Z^CZ^Z^Z^CZ^Z^Z^CZ^Z^Z^$~  UCZ^Z^Z^$ $}  CZ^Z^Z^ Z^&Z^ 4Z^v4Z^$ w$ x% y % z % {% |CZ^BZ^JZ^$ % }:  2  
 >Z^ Z^&Z^  Z^>Z^ Z^% ~h# ) D65Z^>Z^:  '  
 >Z^ Z^&Z^  Z^>Z^ Z^$ % i%l  Z^t >Z^4Z^v4Z^ >Z^  (Z^T # ) Dr5Z^JZ^DZ^r5Z^:  *  
 >Z^ Z^&Z^  Z^>Z^ Z^ 4Z^4Z^ h # ) CZ^65Z^Z^CJZ^>Z^Z^ JZ^B  rZ^Z^% g%l %l $  Z^Z^  >Z^4Z^4Z^ >Z^@ JZ^(Z^ Z^# ) CZ^r5Z^fZ^CbZ^VZ^Z^ nZ^JZ^bZ^ nZ^F  rZ^Z^% g%l %l $  Z^Z^  # ) CZ^r5Z^#Z^CJZ^>Z^Z^ VZ^(Z^JZ^ VZ^ # ) DB5Z^bZ^% j% 0% kCZ^BZ^JZ^$ CN5Z^B5Z^Z^$ % l%l  4Z^4Z^ J >Z^4Z^4Z^ >Z^  JZ^(Z^ Z^ JZ^V  rZ^Z^ Z^Z^% g%l %l 	 +Z^$  Z^Z^ | # ) CZ^N5Z^#Z^CJZ^>Z^Z^ VZ^(Z^JZ^ VZ^H % m# ) DZ5Z^>Z^$ % n%l  4Z^4Z^ T >Z^4Z^4Z^ >Z^  JZ^(Z^ Z^ JZ^b # ) Df5Z^VZ^:  /  
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^f5Z^Z5Z^%  4Z^4Z^  # ) CZ^Z5Z^NZ^CJZ^>Z^Z^ VZ^(Z^JZ^ VZ^R  rZ^Z^ Z^Z^% g%l %l $ 	 +Z^ Z^Z^ H >Z^4Z^4Z^ >Z^R )Z^n # ) D~5Z^JZ^:  S  
 >Z^ Z^&Z^  Z^>Z^ Z^ 4Z^4Z^:  8  
 >Z^ Z^&Z^  Z^>Z^ Z^   )Z^n # ) D5Z^>Z^:  S  
 >Z^ Z^&Z^  Z^>Z^ Z^ 4Z^4Z^:  9  
 >Z^ Z^&Z^  Z^>Z^ Z^ n # ) CZ^f5Z^ZZ^CJZ^>Z^Z^ JZ^H  rZ^Z^% g%l %l $ 	 +Z^ Z^Z^  >Z^4Z^4Z^ >Z^  JZ^)Z^ Z^ JZ^P  rZ^Z^ Z^Z^% g%l %l $  Z^Z^  # ) CZ^~5Z^fZ^CJZ^>Z^Z^ VZ^)Z^JZ^ VZ^L  rZ^Z^ Z^Z^$ % g%l %l  Z^Z^   >Z^4Z^4Z^ >Z^  JZ^)Z^ Z^ JZ^P  rZ^JZ^ Z^Z^% g%l %l $  Z^Z^  # ) CZ^5Z^fZ^CJZ^>Z^Z^ VZ^)Z^JZ^ VZ^L  rZ^VZ^ Z^Z^$ % g%l %l  Z^Z^ DZ^2Z^DZ^2Z^CZ^Z^Z^CZ^Z^Z^CZ^Z^Z^$~  UCZ^Z^Z^$ $}  CZ^Z^Z^ Z^&Z^ 7Z^^7Z^$ $ %  %  % :  2  
 >Z^ Z^&Z^  Z^>Z^ Z^% # ) D7Z^>Z^:  '  
 >Z^ Z^&Z^  Z^>Z^ Z^$ % %l  Z^ >Z^7Z^^7Z^ >Z^ # ) CZ^*8Z^fZ^CVZ^JZ^Z^ bZ^(Z^VZ^ bZ^T # ) D*8Z^nZ^DZ^*8Z^:  +  
 >Z^ Z^&Z^  Z^>Z^ Z^ 7Z^j7Z^ ^ # ) CZ^7Z^Z^CJZ^>Z^Z^ JZ^8  rZ^Z^% %l $  Z^Z^  >Z^7Z^j7Z^ >Z^  JZ^(Z^ Z^ JZ^<  rZ^Z^% %l $  Z^Z^  # ) CZ^*8Z^#Z^CJZ^>Z^Z^ VZ^(Z^JZ^ VZ^R % # ) D8Z^>Z^$ % %l %l  7Z^v7Z^  >Z^7Z^v7Z^ >Z^  JZ^(Z^ Z^ JZ^b # ) D8Z^VZ^:  /  
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^8Z^8Z^%  7Z^7Z^  # ) CZ^8Z^NZ^CJZ^>Z^Z^ VZ^(Z^JZ^ VZ^R  rZ^bZ^% %l %l %l $ 	 +Z^ Z^Z^  >Z^7Z^7Z^ >Z^\ *)Z^n # ) D68Z^JZ^:  S  
 >Z^ Z^&Z^  Z^>Z^ Z^ 7Z^7Z^:  :  
 >Z^ Z^&Z^  Z^>Z^ Z^   6)Z^n # ) D68Z^>Z^:  S  
 >Z^ Z^&Z^  Z^>Z^ Z^ 7Z^7Z^:  ;  
 >Z^ Z^&Z^  Z^>Z^ Z^ x # ) CZ^8Z^ZZ^CJZ^>Z^Z^ JZ^R  rZ^bZ^% %l %l %l $ 	 +Z^ Z^Z^ p >Z^7Z^7Z^ >Z^* JZ^*)Z^ Z^ JZ^P  rZ^nZ^% %l %l %l $  Z^Z^  # ) CZ^68Z^fZ^CJZ^>Z^Z^ VZ^*)Z^JZ^ VZ^  Z^zZ^$ % %l %l %l  Z^Z^ >Z^~Z^Z^ >Z^  rZ^Z^ $  >Z^~Z^VZ^ >Z^  rZ^Z^ 8 >Z^7Z^7Z^ >Z^& JZ^6)Z^ Z^ JZ^P  rZ^nZ^% %l %l %l $  Z^Z^  # ) CZ^68Z^fZ^CJZ^>Z^Z^ VZ^6)Z^JZ^ VZ^  Z^Z^$ % %l %l %l  Z^Z^ >Z^~Z^Z^ >Z^  rZ^Z^ $  >Z^~Z^VZ^ >Z^  rZ^Z^ U6DZ^2Z^DZ^2Z^CZ^Z^Z^CZ^Z^Z^CZ^Z^Z^$~  UCZ^Z^Z^$ $}  CZ^Z^Z^ Z^&Z^ ::Z^9Z^$ $ %  %  % % CZ^BZ^JZ^$ % :  2  
 >Z^ Z^&Z^  Z^>Z^ Z^% # ) D:Z^>Z^:  '  
 >Z^ Z^&Z^  Z^>Z^ Z^$ % %l  Z^ >Z^::Z^9Z^ >Z^  (Z^T # ) D;Z^JZ^DZ^;Z^:  *  
 >Z^ Z^&Z^  Z^>Z^ Z^ ::Z^9Z^ h # ) CZ^:Z^Z^CJZ^>Z^Z^ JZ^B  rZ^Z^% %l %l $  Z^Z^  >Z^::Z^9Z^ >Z^@ JZ^(Z^ Z^# ) CZ^;Z^fZ^CbZ^VZ^Z^ nZ^JZ^bZ^ nZ^F  rZ^Z^% %l %l $  Z^Z^  # ) CZ^;Z^#Z^CJZ^>Z^Z^ VZ^(Z^JZ^ VZ^ # ) D:Z^bZ^% %  0% CZ^BZ^JZ^$ C:Z^:Z^Z^$ % %l  ::Z^9Z^ b >Z^::Z^9Z^ >Z^  JZ^(Z^ Z^ JZ^V  rZ^Z^ Z^Z^% %l %l 	 +Z^$  Z^Z^  # ) CZ^:Z^#Z^CJZ^>Z^Z^ VZ^(Z^JZ^ VZ^T % # ) D;Z^>Z^$ % %l  ::Z^9Z^	 3Z^@ 3Z^ ` >Z^::Z^9Z^ >Z^  JZ^(Z^ Z^ JZ^b # ) D;Z^VZ^:  /  
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^;Z^;Z^% 	 ::Z^9Z^  # ) CZ^;Z^NZ^CJZ^>Z^Z^ VZ^(Z^JZ^ VZ^R  rZ^Z^ Z^Z^% 
%l %l $ 	 +Z^ Z^Z^ T
 >Z^::Z^9Z^ >Z^R )Z^n # ) D*;Z^JZ^:  S  
 >Z^ Z^&Z^  Z^>Z^ Z^ ::Z^9Z^:  8  
 >Z^ Z^&Z^  Z^>Z^ Z^   )Z^n # ) D6;Z^>Z^:  S  
 >Z^ Z^&Z^  Z^>Z^ Z^ ::Z^9Z^:  9  
 >Z^ Z^&Z^  Z^>Z^ Z^ n # ) CZ^;Z^ZZ^CJZ^>Z^Z^ JZ^H  rZ^Z^% %l %l $ 	 +Z^ Z^Z^  >Z^::Z^9Z^ >Z^, JZ^)Z^ Z^ JZ^P  rZ^Z^ Z^Z^% %l %l $  Z^Z^  # ) CZ^*;Z^fZ^CJZ^>Z^Z^ VZ^)Z^JZ^ VZ^  ~Z^Z^ Z^Z^$ % # ) D:Z^>Z^:  '  
 >Z^ Z^&Z^  Z^>Z^ Z^$ % %l %l  ::Z^9Z^  >Z^::Z^9Z^ >Z^" JZ^)Z^ Z^ JZ^P  rZ^JZ^ Z^Z^% %l %l $  Z^Z^  # ) CZ^6;Z^fZ^CJZ^>Z^Z^ VZ^)Z^JZ^ VZ^  ~Z^VZ^ Z^Z^$ % # ) D:Z^>Z^:  '  
 >Z^ Z^&Z^  Z^>Z^ Z^$ % %l  ::Z^9Z^  >Z^::Z^9Z^ >Z^  (Z^J # ) D;Z^JZ^:  +  
 >Z^ Z^&Z^  Z^>Z^ Z^ ::Z^9Z^ ^ # ) CZ^:Z^Z^CJZ^>Z^Z^ JZ^8  rZ^Z^% %l $  Z^Z^  >Z^::Z^9Z^ >Z^  JZ^(Z^ Z^ JZ^<  rZ^Z^% %l $  Z^Z^  # ) CZ^;Z^#Z^CJZ^>Z^Z^ VZ^(Z^JZ^ VZ^R % # ) D:Z^>Z^$ %  %l %l  ::Z^
:Z^  >Z^::Z^
:Z^ >Z^  JZ^(Z^ Z^ JZ^b # ) D;Z^VZ^:  /  
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^;Z^:Z^% ! ::Z^:Z^  # ) CZ^:Z^NZ^CJZ^>Z^Z^ VZ^(Z^JZ^ VZ^R  rZ^bZ^% "%l %l %l $ #	 +Z^ Z^Z^  >Z^::Z^:Z^ >Z^\ *)Z^n # ) DB;Z^JZ^:  S  
 >Z^ Z^&Z^  Z^>Z^ Z^ ::Z^":Z^:  :  
 >Z^ Z^&Z^  Z^>Z^ Z^   6)Z^n # ) DB;Z^>Z^:  S  
 >Z^ Z^&Z^  Z^>Z^ Z^ ::Z^.:Z^:  ;  
 >Z^ Z^&Z^  Z^>Z^ Z^ x # ) CZ^;Z^ZZ^CJZ^>Z^Z^ JZ^R  rZ^bZ^% $%l %l %l $ %	 +Z^ Z^Z^ p >Z^::Z^":Z^ >Z^* JZ^*)Z^ Z^ JZ^P  rZ^nZ^% &%l %l %l $ ' Z^Z^  # ) CZ^B;Z^fZ^CJZ^>Z^Z^ VZ^*)Z^JZ^ VZ^  Z^zZ^$ (% )%l %l %l  >Z^~Z^Z^ >Z^  rZ^Z^ $  >Z^~Z^VZ^ >Z^  rZ^Z^ Z^Z^ 8 >Z^::Z^.:Z^ >Z^& JZ^6)Z^ Z^ JZ^P  rZ^nZ^% *%l %l %l $ + Z^Z^  # ) CZ^B;Z^fZ^CJZ^>Z^Z^ VZ^6)Z^JZ^ VZ^  Z^Z^$ ,% -%l %l %l  Z^Z^ >Z^~Z^Z^ >Z^  rZ^Z^ $  >Z^~Z^VZ^ >Z^  rZ^Z^ xDZ^2Z^DZ^2Z^CZ^Z^Z^CZ^Z^Z^CZ^Z^Z^$~  UCZ^Z^Z^$ $}  CZ^Z^Z^ Z^&Z^ >Z^6>Z^$ T$ U% V % W % X% YCZ^BZ^JZ^$ % Z:  2  
 >Z^ Z^&Z^  Z^>Z^ Z^% [?:  '  
 >Z^ Z^&Z^  Z^>Z^ Z^$ \% ]@%l  Z^ >Z^>Z^6>Z^ >Z^  (Z^T # ) D?Z^JZ^DZ^?Z^:  )  
 >Z^ Z^&Z^  Z^>Z^ Z^ >Z^B>Z^ h # ) CZ^z?Z^Z^CJZ^>Z^Z^ JZ^B  rZ^Z^% ^>%l %l $ _ Z^Z^ T >Z^>Z^B>Z^ >Z^F JZ^(Z^ Z^# ) CZ^?Z^fZ^CbZ^VZ^Z^ nZ^JZ^bZ^ nZ^F  rZ^Z^% `>%l %l $ a Z^Z^  # ) CZ^?Z^#Z^CJZ^>Z^Z^ VZ^(Z^JZ^ VZ^ # ) D?Z^bZ^% bA% c0% dBCZ^BZ^JZ^$ C?Z^?Z^Z^$ e% fC%l  >Z^N>Z^	 3Z^   >Z^>Z^N>Z^ >Z^ JZ^(Z^ Z^ JZ^V  rZ^Z^ Z^Z^% g>%l %l 	 +Z^$ h Z^Z^  # ) CZ^?Z^#Z^CJZ^>Z^Z^ VZ^(Z^JZ^ VZ^| # ) D?Z^bZ^% iF# ) D?Z^>Z^$ j% kG:  +  
 >Z^ Z^&Z^  Z^>Z^ Z^%l  >Z^Z>Z^  >Z^>Z^Z>Z^ >Z^  JZ^(Z^ Z^ JZ^<  rZ^Z^% l>%l $ m Z^Z^  # ) CZ^?Z^#Z^CJZ^>Z^Z^ VZ^(Z^JZ^ VZ^X % nH# ) D?Z^>Z^$ o% pI%l %l  >Z^f>Z^	 2Z^  >Z^>Z^f>Z^ >Z^  JZ^(Z^ Z^ JZ^b # ) D?Z^VZ^:  /  
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^?Z^?Z^% q >Z^r>Z^  # ) CZ^?Z^NZ^CJZ^>Z^Z^ VZ^(Z^JZ^ VZ^R  rZ^bZ^% r>%l %l %l $ s	 +Z^ Z^Z^  >Z^>Z^r>Z^ >Z^\ *)Z^n # ) D?Z^JZ^:  S  
 >Z^ Z^&Z^  Z^>Z^ Z^ >Z^~>Z^:  :  
 >Z^ Z^&Z^  Z^>Z^ Z^   6)Z^n # ) D?Z^>Z^:  S  
 >Z^ Z^&Z^  Z^>Z^ Z^ >Z^>Z^:  ;  
 >Z^ Z^&Z^  Z^>Z^ Z^ x # ) CZ^?Z^ZZ^CJZ^>Z^Z^ JZ^R  rZ^bZ^% t>%l %l %l $ u	 +Z^ Z^Z^ t >Z^>Z^~>Z^ >Z^, JZ^*)Z^ Z^ JZ^P  rZ^nZ^% v>%l %l %l $ w Z^Z^  # ) CZ^?Z^fZ^CJZ^>Z^Z^ VZ^*)Z^JZ^ VZ^  Z^zZ^$ x% y>%l %l  >Z^>Z^% z?# ) Dz?Z^>Z^:  '  
 >Z^ Z^&Z^  Z^>Z^ Z^$ {% |@ : >Z^>Z^>Z^ >Z^( JZ^6)Z^ Z^ JZ^P  rZ^nZ^% }>%l %l %l $ ~ Z^Z^  # ) CZ^?Z^fZ^CJZ^>Z^Z^ VZ^6)Z^JZ^ VZ^  Z^Z^$ % >%l %l  >Z^>Z^% ?# ) Dz?Z^>Z^:  '  
 >Z^ Z^&Z^  Z^>Z^ Z^$ % @ >Z^>Z^>Z^ >Z^  (Z^J # ) D?Z^JZ^:  *  
 >Z^ Z^&Z^  Z^>Z^ Z^ >Z^>Z^ h # ) CZ^z?Z^Z^CJZ^>Z^Z^ JZ^B  rZ^Z^% >%l %l $  Z^Z^  >Z^>Z^>Z^ >Z^  JZ^(Z^ Z^ JZ^F  rZ^Z^% >%l %l $  Z^Z^  # ) CZ^?Z^#Z^CJZ^>Z^Z^ VZ^(Z^JZ^ VZ^\ % BCZ^BZ^JZ^$ C?Z^?Z^Z^$ % C%l  >Z^>Z^  >Z^>Z^>Z^ >Z^  JZ^(Z^ Z^ JZ^b # ) D?Z^VZ^:  /  
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^?Z^?Z^%  >Z^>Z^  # ) CZ^?Z^NZ^CJZ^>Z^Z^ VZ^(Z^JZ^ VZ^R  rZ^Z^ Z^Z^% >%l %l $ 	 +Z^ Z^Z^  >Z^>Z^>Z^ >Z^R )Z^n # ) D?Z^JZ^:  S  
 >Z^ Z^&Z^  Z^>Z^ Z^ >Z^>Z^:  8  
 >Z^ Z^&Z^  Z^>Z^ Z^   )Z^n # ) D?Z^>Z^:  S  
 >Z^ Z^&Z^  Z^>Z^ Z^ >Z^>Z^:  9  
 >Z^ Z^&Z^  Z^>Z^ Z^ n # ) CZ^?Z^ZZ^CJZ^>Z^Z^ JZ^H  rZ^Z^% >%l %l $ 	 +Z^ Z^Z^ f >Z^>Z^>Z^ >Z^  JZ^)Z^ Z^ JZ^F  rZ^Z^ Z^Z^%l %l $  Z^Z^  # ) CZ^?Z^fZ^CJZ^>Z^Z^ VZ^)Z^JZ^ VZ^  ~Z^Z^ Z^Z^$ % >%l %l  Z^Z^ >Z^Z^zZ^ >Z^  rZ^Z^ $  >Z^Z^Z^ >Z^  rZ^Z^ 8 >Z^>Z^>Z^ >Z^& JZ^)Z^ Z^ JZ^P  rZ^JZ^ Z^Z^% >%l %l $  Z^Z^  # ) CZ^?Z^fZ^CJZ^>Z^Z^ VZ^)Z^JZ^ VZ^  ~Z^VZ^ Z^Z^$ % >%l %l  Z^Z^ >Z^Z^zZ^ >Z^  rZ^Z^ $  >Z^Z^Z^ >Z^  rZ^Z^ D "CZ^Z^ >Z^!Z^&Z^ >Z^J  JZ^"CZ^*Z^ JZ^4 : : "
 "CZ^"CZ^&Z^ !Z^Z^  >Z^J Z^NZ^ >Z^  JZ^rZ^Z^ VZ^rZ^Z^ bZ^JZ^VZ^ nZ^rZ^Z^ Z^bZ^nZ^ "Z^rZ^Z^ .Z^Z^"Z^ .Z^ 4 "
 FZ^:Z^&Z^: "4 "%  >Z^rZ^Z^ JZ^rZ^Z^ VZ^>Z^JZ^ VZ^& 4 #
 nZ^bZ^&Z^: # ~ >Z^J Z^BZ^ >Z^l JZ^rZ^Z^ VZ^rZ^&Z^ bZ^JZ^VZ^ bZ^:4 "
 Z^nZ^&Z^: " >Z^~#Z^$Z^ JZ^rZ^Z^ VZ^>Z^JZ^
 bZ^$Z^2Z^ nZ^~#Z^bZ^ Z^rZ^Z^ "Z^nZ^Z^ .Z^VZ^"Z^ :Z^~#Z^$Z^ FZ^rZ^&Z^ RZ^:Z^FZ^ ^Z^.Z^RZ^
 jZ^$Z^2Z^ Z^~#Z^jZ^ Z^rZ^&Z^ ~)Z^Z^Z^ )Z^^Z^~)Z^ )Z^& 4 w
 )Z^)Z^&Z^: xC.CZ^:Z^~Z^ >Z^J Z^NZ^ >Z^J 4 # VZ^~Z^JZ^4 " nZ^VZ^bZ^DZ^nZ^:  X  >Z^J Z^BZ^ >Z^F 4  VZ^~Z^JZ^4 " nZ^VZ^bZ^DZ^nZ^:  >Z^J Z^NZ^4 CJZ^:Z^Z^ VZ^>Z^JZ^ bZ^J Z^BZ^4 CnZ^:Z^Z^ Z^bZ^nZ^ "Z^VZ^Z^ "Z^: %l %l 4 DJZ^Z^&k  >Z^J Z^NZ^4 CJZ^:Z^Z^ VZ^>Z^JZ^ bZ^J Z^BZ^4 CnZ^:Z^Z^ Z^bZ^nZ^ "Z^VZ^Z^ "Z^: %l %l 4 DJZ^Z^&k  >Z^J Z^NZ^4 CJZ^:Z^Z^ VZ^>Z^JZ^ bZ^J Z^BZ^4 CnZ^:Z^Z^ Z^bZ^nZ^ "Z^VZ^Z^ "Z^: %l %l 4 DJZ^Z^&k  >Z^J Z^NZ^4 CJZ^:Z^Z^ VZ^>Z^JZ^ bZ^J Z^BZ^4 CnZ^:Z^Z^ Z^bZ^nZ^ "Z^VZ^Z^ "Z^: %l %l 4 DJZ^Z^&k  >Z^J Z^NZ^4 CJZ^:Z^Z^ VZ^>Z^JZ^ bZ^J Z^BZ^4 CnZ^:Z^Z^ Z^bZ^nZ^ "Z^VZ^Z^ "Z^: %l %l 4 DJZ^Z^&k  >Z^J Z^NZ^4 CJZ^:Z^Z^ VZ^>Z^JZ^ bZ^J Z^BZ^4 CnZ^:Z^Z^ Z^bZ^nZ^ "Z^VZ^Z^ "Z^: %l %l 4 DJZ^Z^&k  >Z^J Z^NZ^4 CJZ^:Z^Z^ VZ^>Z^JZ^ bZ^J Z^BZ^4 CnZ^:Z^Z^ Z^bZ^nZ^ "Z^VZ^Z^ "Z^: %l %l 4 DJZ^Z^&k  >Z^J Z^NZ^4 CJZ^:Z^Z^ VZ^>Z^JZ^ bZ^J Z^BZ^4 CnZ^:Z^Z^ Z^bZ^nZ^ "Z^VZ^Z^ "Z^: %l %l 4 DJZ^Z^&k  >Z^J Z^NZ^4 CJZ^:Z^Z^ VZ^>Z^JZ^ bZ^J Z^BZ^4 CnZ^:Z^Z^ Z^bZ^nZ^ "Z^VZ^Z^ "Z^: %l %l 4 DJZ^Z^&k  >Z^J Z^NZ^4 CJZ^:Z^Z^ VZ^>Z^JZ^ bZ^J Z^BZ^4 CnZ^:Z^Z^ Z^bZ^nZ^ "Z^VZ^Z^ "Z^: %l %l 4 DJZ^Z^&k 4   ^CZ^>Z^4   jCZ^>Z^4   vCZ^>Z^4   CZ^>Z^4   CZ^>Z^4   CZ^>Z^4   CZ^>Z^4   CZ^>Z^4   CZ^>Z^5   CZ^>Z^5   CZ^>Z^5   CZ^>Z^4  CZ^>Z^4  CZ^>Z^4  DZ^>Z^4  DZ^>Z^4  DZ^>Z^4  *DZ^>Z^4   6DZ^>Z^4   BDZ^>Z^4   NDZ^>Z^4  ZDZ^>Z^4  fDZ^>Z^4  rDZ^>Z^4   ~DZ^>Z^4   DZ^>Z^4   DZ^>Z^4   DZ^>Z^4   DZ^>Z^4   DZ^>Z^4   DZ^>Z^4   DZ^>Z^4   DZ^>Z^4   DZ^>Z^4   DZ^>Z^4   EZ^>Z^4   EZ^>Z^4   EZ^>Z^4   &EZ^>Z^:  f  
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^ZZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^~#Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^&Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^Z^ZZ^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^CZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^CZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^CZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^Z^ZZ^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^Z^ZZ^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^CZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^CZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^CZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^*Z^ZZ^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^ZZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^NZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^rZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^vCZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^jCZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^^CZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^Z^ZZ^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^Z^ZZ^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^	Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^CZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^CZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^CZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^	Z^ZZ^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^fZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^	Z^ZZ^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^rZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^Z^>EZ^C>Z^Z^~Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^RZ^ZZ^CZ^Z^Z^C>Z^Z^~Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^Z^JEZ^C>Z^Z^~Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^^Z^ZZ^CZ^Z^Z^C>Z^Z^~Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^BZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^#Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^#Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^CZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^CZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^DZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^DZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^DZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^*DZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^Z^ZZ^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^-Z^ZZ^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^-Z^ZZ^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^Z^ZZ^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^	Z^ZZ^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^	Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^2	Z^ZZ^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^&	Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^&Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^$Z^ZZ^$ C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^6DZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^BDZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^NDZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^ZDZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^fDZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^rDZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^jZ^ZZ^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^ 2EZ^Z^ >Z^2EZ^ZZ^ >Z^T 4 CVZ^Z^JZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^
 2EZ^2EZ^&Z^CZ^Z^ZZ^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^#Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^#Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^RZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^vZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^~DZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^DZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^DZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^DZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^DZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^DZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^DZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^DZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^DZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^DZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^DZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^EZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^EZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^EZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^C>Z^Z^&EZ^:   
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^Z^ZZ^C>Z^Z^Z^:   
 >Z^ Z^&Z^  Z^>Z^ Z^:  g  
 >Z^ Z^&Z^  Z^>Z^ Z^# ) DEZ^Z^DJZ^EZ^$  VZ^Z^>Z^ bZ^VZ^ZZ^$ CZ^Z^EZ^ Z^Z^ >Z^rZ^Z^ >Z^2  JZ^Z^FZ^$ DZ^Z^ Z^Z^ >Z^J Z^Z^ JZ^J Z^*Z^ VZ^>Z^JZ^ bZ^J Z^Z^ nZ^VZ^bZ^ Z^J Z^Z^ "Z^nZ^Z^ .Z^J Z^BZ^ :Z^"Z^.Z^ FZ^J Z^6Z^ RZ^:Z^FZ^ ^Z^J Z^fZ^ jZ^RZ^^Z^ jZ^ Z^rZ^Z^ Z^rZ^Z^ ~)Z^Z^Z^ )Z^rZ^Z^ )Z^~)Z^)Z^ )Z^rZ^Z^ )Z^)Z^)Z^ )Z^rZ^Z^ )Z^)Z^)Z^ )Z^rZ^Z^ )Z^)Z^)Z^ )Z^Z :  7  
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^Z^bZ^$ DZ^Z^ Z^Z^   >Z^rZ^Z^CJZ^EZ^6Z^ VZ^>Z^JZ^ VZ^  "Z^Z^ "Z^Z^	*Z^# ) :  ?  
 >Z^ Z^&Z^  Z^>Z^ Z^:  A  
 >Z^ Z^&Z^  Z^>Z^ Z^
 Z^Z^&Z^4  
 JZ^>Z^&Z^:   Z^Z^&Z^ >Z^J Z^6Z^ >Z^ JZ^rZ^Z^ JZ^   Z^Z^2Z^ Z^Z^ >Z^rZ^Z^ JZ^rZ^Z^ VZ^>Z^JZ^ VZ^  bZ^rZ^Z^ bZ^&  "Z^Z^ "Z^Z^	*Z^ 4  >Z^rZ^Z^ >Z^"  "Z^Z^ "Z^Z^	*Z^# ) :  ?  
 >Z^ Z^&Z^  Z^>Z^ Z^:  A  
 >Z^ Z^&Z^  Z^>Z^ Z^
 Z^Z^&Z^4  
 JZ^>Z^&Z^:   Z^Z^&Z^  >Z^rZ^Z^ JZ^rZ^Z^ VZ^>Z^JZ^ VZ^  bZ^rZ^Z^ bZ^&  "Z^&Z^ "Z^Z^	*Z^ 4  >Z^rZ^Z^ >Z^"  "Z^2Z^ "Z^Z^	*Z^# )  Z^Z^ Z^Z^:  ?  
 >Z^ Z^&Z^  Z^>Z^ Z^:  @  
 >Z^ Z^&Z^  Z^>Z^ Z^   >Z^rZ^Z^ >Z^ $  "Z^2Z^ "Z^Z^	*Z^# ) CZ^Z^bZ^ Z^Z^:  ?  
 >Z^ Z^&Z^  Z^>Z^ Z^:  @  
 >Z^ Z^&Z^  Z^>Z^ Z^ >Z^rZ^Z^ JZ^~#Z^Z^ VZ^>Z^JZ^ VZ^H CZ^Z^ZZ^CZ^&Z^Z^CZ^Z^Z^$ gUDZ^(Z^ r  >Z^rZ^Z^ JZ^~#Z^&Z^ VZ^>Z^JZ^ VZ^D CZ^Z^ZZ^CZ^&Z^Z^CZ^Z^Z^$ gUDZ^(Z^ >Z^Z^Z^ >Z^ 
 Z^Z^&Z^ >Z^J Z^BZ^ >Z^ JZ^rZ^Z^ JZ^   Z^Z^2Z^ Z^Z^ >Z^rZ^Z^ >Z^  "Z^Z^ "Z^Z^	*Z^# ) :  ?  
 >Z^ Z^&Z^  Z^>Z^ Z^:  A  
 >Z^ Z^&Z^  Z^>Z^ Z^
 Z^Z^&Z^4  
 JZ^>Z^&Z^:   Z^Z^&Z^ >Z^rZ^Z^ >Z^  "Z^Z^ "Z^Z^	*Z^ >Z^z Z^Z^ >Z^( CZ^Z^EZ^$ DZ^Z^# ) :  ?  
 >Z^ Z^&Z^  Z^>Z^ Z^:  A  
 >Z^ Z^&Z^  Z^>Z^ Z^
 Z^Z^&Z^4  
 JZ^>Z^&Z^:   Z^Z^&Z^ x >Z^rZ^Z^ JZ^rZ^2Z^ VZ^>Z^JZ^ VZ^  "Z^&Z^ "Z^Z^	*Z^# ) CZ^Z^EZ^ >Z^rZ^Z^ >Z^,  JZ^Z^FZ^$ DZ^Z^ $  >Z^rZ^2Z^ >Z^  Z^Z^:  ?  
 >Z^ Z^&Z^  Z^>Z^ Z^:  @  
 >Z^ Z^&Z^  Z^>Z^ Z^
 Z^Z^&Z^ d >Z^rZ^Z^ >Z^ $  "Z^2Z^ "Z^Z^	*Z^# )  Z^Z^FZ^ Z^Z^:  ?  
 >Z^ Z^&Z^  Z^>Z^ Z^:  @  
 >Z^ Z^&Z^  Z^>Z^ Z^  >Z^rZ^&Z^ >Z^  JZ^Z^FZ^$ DZ^Z^ Z^Z^# )  "Z^Z^ "Z^Z^	*Z^
 Z^Z^&Z^:  ?  
 >Z^ Z^&Z^  Z^>Z^ Z^:  @  
 >Z^ Z^&Z^  Z^>Z^ Z^  >Z^rZ^Z^ JZ^rZ^JZ^ VZ^>Z^JZ^ VZ^  Z^Z^:  7  
 >Z^ Z^&Z^  Z^>Z^ Z^ "Z^fZ^ "Z^
FZ^	*Z^CZ^Z^bZ^$ DZ^Z^ >Z^Z^Z^ JZ^rZ^Z^ VZ^>Z^JZ^ VZ^@  Z^Z^ >Z^Z^2Z^$ DZ^Z^
 Z^Z^&Z^ >Z^rZ^Z^ JZ^~#Z^Z^ VZ^~#Z^2Z^ bZ^JZ^VZ^ nZ^>Z^bZ^ nZ^H CZ^Z^ZZ^CZ^&Z^Z^CZ^Z^Z^$ gUDZ^(Z^   >Z^rZ^Z^ JZ^~#Z^&Z^ VZ^~#Z^FZ^ bZ^JZ^VZ^ nZ^>Z^bZ^ nZ^D CZ^Z^ZZ^CZ^&Z^Z^CZ^Z^Z^$ gUDZ^(Z^ >Z^rZ^Z^ >Z^ 
 Z^Z^Z^ >Z^rZ^>Z^ JZ^rZ^Z^ VZ^>Z^JZ^ VZ^2  bZ^Z^RZ^$ DZ^Z^ Z^Z^ >Z^J Z^NZ^ >Z^ JZ^rZ^Z^ JZ^   Z^Z^2Z^ Z^Z^ >Z^rZ^Z^ JZ^rZ^Z^ VZ^>Z^JZ^ VZ^  bZ^rZ^Z^ bZ^&  "Z^Z^ "Z^Z^	*Z^ 4  >Z^rZ^Z^ >Z^"  "Z^Z^ "Z^Z^	*Z^# ) :  ?  
 >Z^ Z^&Z^  Z^>Z^ Z^:  A  
 >Z^ Z^&Z^  Z^>Z^ Z^
 Z^Z^&Z^4  
 JZ^>Z^&Z^:   Z^Z^&Z^ 8 >Z^rZ^Z^ >Z^  "Z^&Z^ "Z^Z^	*Z^# )  Z^Z^ Z^Z^:  ?  
 >Z^ Z^&Z^  Z^>Z^ Z^:  @  
 >Z^ Z^&Z^  Z^>Z^ Z^   >Z^rZ^Z^ >Z^ $  "Z^2Z^ "Z^Z^	*Z^# ) CZ^Z^bZ^ Z^Z^:  ?  
 >Z^ Z^&Z^  Z^>Z^ Z^:  @  
 >Z^ Z^&Z^  Z^>Z^ Z^ >Z^rZ^Z^ >Z^ 
 Z^Z^Z^ >Z^Z^Z^ >Z^ 
 Z^Z^&Z^ >Z^J Z^ZZ^ >Z^ JZ^rZ^Z^ VZ^rZ^Z^ bZ^JZ^VZ^ bZ^P  "Z^2Z^ "Z^Z^2Z^	*Z^ >Z^Z^2Z^$ DZ^Z^ Z^Z^ >Z^rZ^Z^ >Z^> $ >DZ^Z^ "Z^Z^ "Z^Z^	*Z^# )    >Z^rZ^VZ^ >Z^V  Z^Z^CZ^Z^EZ^$ DZ^Z^ "Z^Z^ "Z^Z^	*Z^# )  p  >Z^rZ^Z^ JZ^rZ^JZ^ VZ^>Z^JZ^ VZ^B  Z^Z^$ =DZ^Z^ "Z^2Z^ "Z^Z^2Z^	*Z^ >Z^Z^:Z^ >Z^  JZ^rZ^Z^ JZ^L  VZ^Z^2Z^$ DZ^Z^ "Z^>Z^ "Z^Z^	*Z^# )   >Z^rZ^Z^ >Z^L CZ^Z^bZ^$ DZ^Z^ "Z^JZ^ "Z^Z^	*Z^# )  h >Z^rZ^Z^ >Z^V  Z^Z^ >Z^Z^FZ^$ DZ^Z^ "Z^VZ^ "Z^Z^	*Z^# )   >Z^rZ^Z^ >Z^H $ >DZ^Z^ Z^Z^ "Z^bZ^ "Z^Z^	*Z^# )    >Z^rZ^nZ^ >Z^>  Z^Z^ Z^Z^ "Z^2Z^ "Z^Z^2Z^	*Z^ b  >Z^rZ^bZ^ >Z^P  Z^Z^ >Z^Z^2Z^$ DZ^Z^ "Z^2Z^ "Z^Z^2Z^	*Z^ >Z^J Z^fZ^ >Z^x JZ^rZ^Z^ VZ^rZ^Z^ bZ^JZ^VZ^ nZ^rZ^Z^ Z^bZ^nZ^ Z^V :  7  
 >Z^ Z^&Z^  Z^>Z^ Z^CZ^Z^bZ^$ DZ^Z^ Z^Z^ >Z^rZ^Z^ JZ^rZ^Z^ VZ^>Z^JZ^ VZ^  "Z^Z^ "Z^Z^	*Z^# ) :  ?  
 >Z^ Z^&Z^  Z^>Z^ Z^:  A  
 >Z^ Z^&Z^  Z^>Z^ Z^
 Z^Z^&Z^4 m
 JZ^>Z^&Z^: m Z^Z^&Z^ >Z^Z^Z^ JZ^J Z^Z^ VZ^>Z^JZ^ VZ^R # ) 
 nZ^zEZ^Z^ Z^bZ^nZ^ Z^  U "Z^jZ^ "Z^Z^	j"Z^# ) 
 JZ^EZ^Z^ VZ^>Z^JZ^ VZ^   >Z^Z^Z^ JZ^Z^Z^ VZ^>Z^JZ^ bZ^J Z^Z^ nZ^VZ^bZ^ nZ^, :  >  
 >Z^ Z^&Z^  Z^>Z^ Z^
 vZ^vZ^&Z^ # ) :  F  
 >Z^ Z^&Z^  Z^>Z^ Z^	 RCZ^@ RCZ^  >Z^zZ^Z^ >Z^P # ) # ) 
 JZ^bEZ^nZ^ VZ^>Z^JZ^ VZ^  U zZ^zZ^&Z^ >Z^Z^Z^ >Z^ $%  J Z^Z^ Z^J # ) 
 JZ^Z^Z^
 VZ^JZ^Z^ bZ^>Z^VZ^ bZ^  U 4 # ) 
 JZ^nEZ^Z^ VZ^>Z^JZ^ VZ^   :FZ^ZZ^ >Z^
Z^Z^ >Z^  FFZ^Z^   FFZ^
Z^ >Z^Z^Z^ >Z^  RFZ^Z^   RFZ^Z^ "Z^jZ^ "Z^:FZ^	j"Z^ >Z^J Z^Z^ >Z^$ 
 JZ^~#Z^&Z^ ~#Z^JZ^Z^ >Z^J Z^Z^ >Z^6  ~#Z^~#Z^&Z^ >Z^~#Z^ZZ^ >Z^  ~#Z^zZ^ zZ^2Z^ FZ^rZ^ >Z^nZ^2Z^$ DFZ^Z^ "Z^Z^ "Z^FZ^	*Z^@ *Z^ "Z^~Z^ "Z^FZ^	*Z^@ *Z^ "Z^vZ^ "Z^Z^	"Z^ FZ^"Z^CFZ^FZ^FZ^# *  FZ^Z^ >Z^FZ^FZ^ >Z^. # *  VZ^JZ^FZ^ FZ^VZ^FZ^" GZ^"Z^%  >Z^GZ^GZ^% B >Z^GZ^zZ^ JZ^>Z^*GZ^% %  "Z^ZZ^	FZ^@ FZ^% % %  &Z^  ZGZ^Z^ >Z^ZGZ^^Z^ JZ^NGZ^ Z^ VZ^>Z^JZ^ VZ^T 4   "Z^bZ^	FZ^@ FZ^
 >Z^NGZ^&Z^ NGZ^>Z^ Z^
 ZGZ^ZGZ^&Z^ Un# * $ $ % %  $ $ $ 	 Z^	 !Z^	 *Z^	 BGZ^$  $ $%  >Z^n Z^ Z^ >Z^ $% $% $%  rGZ^ V Z^Z^ b Z^Z^ >Z^J Z^Z^ >Z^z  rGZ^Z^ vZ^&Z^ Z^Z^ Z^&Z^$  Z^ %    % $ 	 :+Z^	 +Z^ b Z^&Z^  >Z^J Z^ZZ^ JZ^>Z^b Z^ JZ^	 Z^@ Z^	 Z^@ Z^	 Z^@ Z^ vZ^&Z^ >Z^V Z^ Z^ >Z^  ):  N  
 >Z^ Z^&Z^  Z^>Z^ Z^:  O  
 >Z^ Z^&Z^  Z^>Z^ Z^:    
 >Z^ Z^&Z^  Z^>Z^ Z^ >Z^J Z^ZZ^ >Z^	 $Z^@ $Z^	 'Z^@ 'Z^ >Z^Z^:Z^ >Z^$ 	 2Z^@ 2Z^	 j4Z^@ j4Z^   >Z^Z^FZ^ >Z^$ 	 3Z^@ 3Z^	 R7Z^@ R7Z^ d  >Z^Z^RZ^ >Z^$ 	 2Z^@ 2Z^	 9Z^@ 9Z^ 2  >Z^Z^^Z^ >Z^  	 2Z^@ 2Z^	 *>Z^@ *>Z^	 VEZ^@ VEZ^: f    Z^   Uf%m %m  ~GZ^&Z^ >Z^~GZ^Z^ >Z^" $j 
 ~GZ^~GZ^&Z^U rGZ^&Z^	 > Z^       }              #                       <              ,#      #               m              J2      2                              6      6                             $6      6                             8      8                            , ;      ;                            X ;      ;                            <F<      F<                             >=      =                             N?      ?               N              X      X              p              h      h                             >n      >n                            6 (p      (p                              ^p      ^p                             ~q      ~q                              s      s                              s      s                              ft      ft                            |zt      zt                            u      u                            vv}      v}               -                                   L              z      z               ^                                                  \      \                             \      \               .              D      D                             R
P      P                                                                ,      ,                                                                 2 z      z                             D                                    t                                     d      d                            d ~      ~                                                                 r      r                                                                    K d       e      m         - )                         C         z                                                                      C       C      C       @       @    g   pA    O       P          B    ) g@    hu@                     j                                     0    A      G    	        
               G d
      e
      f
      g
       [
       \
      & ]
      W 
             ]
      8       
      
      
       
      X <
       (
      )
      5 *
      +
      
      
      9 
                   	       w      
      
      
                                                  !      "             \       #      $       
       _
       `
      %      ; 
      &
      H 
       
       
       o      h p      $ q      Y Z
      '^
             (             )      *             +        ;E    ,        N        -       .               /       }                         	        
       0        1        2                3       4       5                        6       7        	       8
       9               :       ;               <       =       >                               ?       @       A       B       C               ~        D                                E       F       G       H       I       J       K       L       M        {         N               O                 P                 Q        	        R        S        @         S        T                 U        V        W        X        Y        Z        [        \                          ]                 Z         _        ^        _        [         `        a        k         b        c        L         d      e      f"      g*      h2      i:      jB      kJ      lR      m        n        o       p       q       r       s       t       u       v       w       x       y       z       {       |       }       ~                      Z      b              j      a         U         y                           w                                                                                                     r      |                                                                J                                                                                                                                                                          4                                                         T                                                                            =                                                  7                 <                 M                                                                                                                                                                                                                           $     ,     4     <                                                                                                             D                             L     T                    \     d     l     t     |                    F                         X      F                             ^                     I                                                                                                 (       7        <       F         B      B      dB     +         HB    	        
QB     )\B    -        $       #        !                                                    333?              4C    D Z         B              C    y                           4              ?    f        @            d       l                            (
      !x              "p      #=    $  @@    %	       &   @    'fff?    i         (        )	      *             +~      : F      ,K               -L      .       /  4B    0  0A     yA    1      2X      3  @    4  @    5   A    6  HA    7  pA    8  A    9  A                      :        ;        <        =                 >        ?      @      A  @    B  A            C  @A    D       E  A            F  A    G       H  A    I  A            J  A     
       K  B    L       M  B    N    O>    Pff>    Q>    R?    S?    T=
?    U  ?     6       V>    W33>    Xff&?    YY?    ZH       [*       \  @    ]       ^    _      `  C    | j    a      b  ?    c2       d       e       f        g        h       i C            j C    k  hB    l       m  A    n       o  A    p  A    q        r   B    s&       t  B    u)       v  $B    wL?    xL@     >    y  @    z  A    {%       |  B    }/       ~  <B    9       =
>    >    ?    z?                    P                    ?         aC     C                      A             B    C         "B      @        ~I                                                  H        zD    RgA    g      w      >       ?                             A              #      F      W       ~                                                   >      H      Y      v                                            2      U      f                                                                      $      :      Q      h                                           	              7      N      e      |                                                                                                             C    @             @      9?    N?                                                              p        /                                                                                            c                         #                         V                                                                                                                                                                                          n         o                 q                             *                            	       
                                                    ]                                    
       Z                             Z                    ] 	   	      	       	            
   
     
       
       
       
  G               '         (                          !        "        #        $        %        &        '        (        )       *        +        ,        -        .        /        0     1     2        3        4        5        6        7            8       9       :       ;       <       =       >       ?       @       A       B       `      =I         C      D      E  >    F?    G'      H  B    I  @?    J       K#       *#       9#      L        M        N        O        P        Q        R        S        T        U        V        W        X        Y        Z        [        \        ]        ^        _        `        a        b        c        d        e        f        g        h        i        j        k        l        m        n        o        p      q       +        b        r       s                               t       u       v       w       x       y       .        z       {       |       }       ~                   I         >                    *&                                                                                                                                                                                                                                              9    *'      4'       J'                                                            }      >      @                                      5                                                           3                                                                                _                                                                                                 (      (      )                                        =                                                                                                                                                                      o     p      q                                                                                                                                           o+      +      +      +      e       +      +              	        
                     =                                                                                                                                                                                             ! 0,      " G,      T,      j,      ,      , ,      ,      ,      ,            %                                                eI                               !  B    "  /C    #j-      1 z-      2 -      $-      %-      &-      '-      (-      )-      *-      +-      ,-      B .      -.      . .      /1.      0    .%        1      2      3      4      5       6k.      7|.      8.      9.      :.      ;.      <.      =.      >.      ?.      @        A      B      C      D      E      F      G      H      I     M%      /    0    1    2    3    4    5      J       K       L       M       N       O       P       Q        R/      S/      T/      U0      V0      W70      XX0      Yw0      Z0      [0      \0      ]0      ^0      _0      `0      a1      b1      c 1      d11      e>1      fK1      gk1      hx1      i1      j1      k1      l1      m1      n1      o2      p2      q82      rQ2      s^2      tk2      u2      v2      w    _B    `C      x    cF      y      z    fI     g%      N1    O2    P3    Q4    R5    oJ       {     rM     sN     tO       |        }3      ~3      93      D3      Z3      v3      3      3      3      3      3      3      3      4      4      #4      =4      J4      d4      q4      4      4      4      4      4      4      &5      ?5          B    C    aD    bE    F    dG    eH            	    x
          y    z    I     %      h    i    j    k    l    m    n    2    3    4    5    J     pK     qL     {     M     N     O     uP     vQ     |        z5      5      E 5      5      5      5      6      .6      Q ;6      R L6      Y6      f6      6      6      6      6      6      6      6      6      7      d "7      /7      @7      M7      g7      t7      7      7      7      7      7      8      8      &8      38      @8      i8      8      8      8      8      8      8      8      9      9      .9      ;9      U9      b9      |9      9      9      9      9      9      :      :      >:      W:          B    C    D        x        y    z      	      
          F    G    H    I     %                                  2    3    4    5    J     K     L     {     M     N     O     P     Q     |        :      :      :      :      :      ;      ";      A;      N;      _;      l;      y;      ;      ;      ;      ;      ;      ;      ;      <      <      5<      B<      S<      `<      m<      <      <      <      <      <      <      <      =      (=      5=      ^=      x=       =      =      =      =      =      =      =      >      >      	*>      
7>      D>      a>      n>      >      >      >      >      >      >      >      ?      )?      N?      g?      t?      ?      ?      ?                                !?      "      #       $       %       &       '       (       )       *       +       ,       -       .       /       0       1       2       3       4       5       6       7       8       9       :       ;       <       =       >       ?       @       A       B       C       D       E       F       G       H       I             JC    KC    L        M        N        O        P        Q        R        S        T        U        V        WC      Xff?    Y?    Z0C      [,      \JC      ]^C      ^!   !   _    !   `    !   a        b"       c#       d$   $ `    $ a        e%       f&   &   g    &   h    &     &   i        ju?    k      l'   '   m    '   n       o                       p(   (   q    (   r    )     )   s   ) 6I         t:D      uHD      vQD      w      xD      yD      zD      {D      |D      }E      ~E      #E      1E        n |  m 'Y      88  @ 9_  4#(I#) nIR's |I{'}      i1   "  s"
 0c +
 (  { B,$O,%Ki^ ,>. Z !  Df%P,)$  L%]^# -=->-(=mK:       X22 t> G%W u4",IJ N .H=  p5        ( Y     
^   g6Ktj     	F6
S6 "	 ez  / 17 _  SHP  {"w	 k%Q%)7  S    ] #  [m  5                                	         	   N 	 l   o  L09
 U d{T f      0 J^h dF(VF(  o    qq 
&6       	         	 @       D  	D  a               #p x  y4=(                      /  P%U  %V    l' #w w&p    
 _}%T  ; J            2  }H[         @H rAP 5ST	 o\ ..-     
 !
 WJZb\c]=      sS - av ftHf ur vNx yiz {!| |l}5r~, Yp q  i:9O   hHDXzm ?Me  c  t      2}GF Z bU XB )  X 
         0   <  H! T" i$   u%   & 	)   * + 1   3   4   5 A9 T;   \<   g= |?   A   C   D E G   H I J K L M  *N !UQ   fR   V "X   `   %b %7d   ?e   Tg   hi (}k l   n   t u 0v 1x   y   z 4+}   2~ 6E   L 7^   e :{ ; <       ?    A        E$F. G9 HC IO JY   e K{    - 
           Q U( V4 W@ XL YX Zd [~        ^ _ a       d e f$ g3 hE iV jg kx > m n o p q r s t u v w x	 y	 z	 {'	 |2	 }=	 ~H	 9N	 lX	 c	 Ln	 	   
 P/
  E
  L
 2X
 f
 o
   |
 
   
   
 b
 

  "  2CR	=\
u    &0FO  ]w !#$`%&')   *+  :.  A/]H0L1  h3z5  7  89  :;  <=>?	@  AR-B=CMDWE'pGK  MNOPQRST+U4V<WKYSTZ[[  `\m]y^_c`abc\d  efghijk+l8mInWoepnqyr  stuvwxz}  '+  /3  7  ;DN  S  ^iy+    	  !'8CHY  `gsy  #  $&          '/29  ?0J3U4`5k6v78        9ABCE)FH#I3J>  CKN  S^MitPTS  UWV$ X.\_`a$	)
.3  88>CCSi^bi nky  ~mo  p-r,tvw!x"y#1 $z%  &|' (T+)6*sA+DL,  Q-gW.  \/b0fn2~y3j4  67 895:;<>  ?[A  BODC  MD&QE\FsG+H@KL  MLORQ  yR  U  V  W=X  Y>9ZC[eT\q]^  _:`;a<-dnPe?afh~g  h@j  kn  Ls  ct{zuvwBxMy  {  |I~}`/wR  #    ))4.:SX%cnt{                4  ?Z  j  !*  6BO\2h*t(             & 0 9 C P   W   {    G               !,!*! 6!B!R!#c!$r!%! !!!!*!+!!!-!.!	!
0"	"  """*"56"
?"J"8Q"'\"3i";r" y",">"/"?"A"" "!D""Y"#"$E#%H#&  %#'N#*[#+i#,  v#-#.L#/M#0N#1O#2P#3Q#4R#5S#6T#7U$8V$9W&$:X7$;YI$<ZZ$=[i$>\y$?]$@^$A_$B`$Ca$Db$Ec$Fd$Ge%Hf%Ig%Jh-%Ki=%LjL%MkY%Na%Onq%R  w%S%W%X  %Y%Z=%[4%\	%^p%_  %`z%a2%b}%c~&d&fI"&g&&h :&i
?&jI&kT&l_&mrj&nx&o&q&s&r<&t  &u  &vd&w&x&y&z&{  &|  &}  &~&  &K&  &&  ''&'G''/'E'  W'\'f'l'p''''"'''  's'  '6''  '''(  (( (6(O(W(b(]n(x(x(c(F((  (  ((((((  (  (  ( )))/)D)NM)y\)d)Qi)q)@{))))	C)
7))))  )*  *l*'*2*  =*J*W*  f*u**  **3* *!*"*# +  	+)+(+%+3+  =+H+  M+  R+  ]+e+  +++  ++++O+B++N+,,,$,e,&|,'q,(,*  ,+{,,|,-,?,@-A-B-CD&-D.-E3-7@-8K-9T-:_-;!u-<-?  -@-A-B-C-D-E  -F.G  .I+.J6.K<.LD.*G.FQ.GX.H^c.Iv.S.T.U.V.W.X.Y.Z.[.\.] /^	///0  /1#/+/:m5/;?/<  M/=#S/Ja/KJk/LKu/NL/OM/PN/QO/RP/w/x  /y0zt10{uR0|  q0}  ~0~0000A00v 1w111  +1u81E1"e1r111h1111 2222K2X2e2  222  2]2325R26\2MQ2S{3  33>3T3p3}33  3  333  3  34474ID4  ^4  k4$444'4(4)41 5+95,F5  L5wU53a52Cm54F}5-55  5	6(6  56  `6}666o6  6 66  626  7E:7G7a7	.n7
/767778797:8;8< 8-8>:8?c8y8S8T8U8V8W8X8
9Z9[(9z59 O9!^\9"_v9#`9$a9%b9&9'd9(e:)f:*g8:+iQ:,^:-jd:.m:7By:8:9:Tk:Ul:V:Wn:Xo;Yp;;ZqH;[rY;\sf;]ts;^u;_v;`;a~;b;c;d;e<f<g/<h<<iM<j Z<kg<l<m<n<o<p<q<r<s =t&"=u/=vX=wr=x=y=z={=|=}=~=>>$>1>>>  [>  h>>>>>>>>?#?H?a?  n?{????????m@@  @ @,@8@#F@$T@%b@&m@'x@(@)@*@+@,@-@.@/@0A1A20A3AA4RA5eA6xA7A8A9A:A;A<A=A>A?A@BABB"BC0BD>BELBFZB*eBpBxB|B|BNBBBQBBB	BOCC%C >CDCXCcCiCRrCCCCC`C  CC  CCCCTCCCCDDlD(DU3DBDKDwD}DDkDDjD EEE +EI:Ec                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ? SETS SPEED SPEED_UNITS __debug_op IDLE state beginTaskFlag allowTaskToBegin setMonkey monkey Pause Last_task Event_fifo_N Event_fifo Set_event Room screenWidth screenHeight subjDist pdLeft pdBottom pdSize screenPixelX screenPixelY screenRefreshRate eyeXGain eyeYGain eyeXOffset eyeYOffset juiceChannel stimChannel eyeXChannel eyeYChannel pdChannel maxVoltage analogUnits checkMouthFlag checkBodyFlag FixSpotOn_ Fixate_ ProFixate_ DecFixate_ BetFixate_ Target_ Choice_ Cue_ Saccade_ FixSpotOff_ StopSignal_ TrialStart_ FixError_ GoSaccade_ GoError_ NOGOWrong_ Abort_ Correct_ Distract_ HighBet_ LowBet_ GOCorrect_ NOGOCorrect_ Reward_ Tone_ Error_tone Reward_tone Error_sacc ExtraReward_ SoundOnReward_ SoundNoReward_ Eot_ CmanHeader_ MemHeader_ ChCmanHeader_ VisHeader_ AmpHeader_ GoNoGoHeader_ DelayHeader_ MaskBetHeader_ Identify_Room_ Stimulation_ ZeroEyePosition_ VSyncSynced_ Decide_ MouthBegin_ MouthEnd_ MapHeader_ FixWindow_ TargetWindow_ Staircase_ Neg2Reinforcement_ Feedback_ RewardSize_ TrialInBlock SendPenatrInfo_ TargetPre_ StopOn_ StimFailed_ VWMHeader_ MemOn_ TestOn_ TestOff_ StartInfos_ EndInfos_ InfosZero stateNoTask stateFIX stateVIS stateAMP stateDEL stateMEM stateCMD stateCCM stateGNG stateMCM stateVWM trialOutcome maskOutcome betOutcome noFix brokeFix goIncorrect nogoCorrect saccOut brokeTarg goTarg nogoTarg saccEarly noSacc saccTarg bodyMove goDist nogoDist checkerAbort brokeDist saccDist betAbort brokeBet highBet lowBet targHighBet distHighBet targLowBet distLowBet hitCorSac hitIncSac cr miss fa miscError goTrial stopTrial ignoreTrial nogoTrial tMaskTrial tBetTrial tRetroTrial tProTrial loadDefault nTrial nTrialComplete Block_number nTrialArray nTrialPerTarget nTrialRemain trialType nObject trl_running success failure noChange goPct NogoPct stopPct ignorePct Bonus_weight Dealer_wins_weight BigR_weight MedR_weight SmlR_weight SmlP_weight MedP_weight BigP_weight pdAmp pdAngle opposite adjacent open fill fixSize fixAngle fixAmp targSize targAngle targAmp distAngle distAmp Classic targColorArray stopColorArray ignoreColorArray fixColorArray maskColorArray highBetColorArray lowBetColorArray betFixColorArray proFixColorArray targColor nogoColor fixColor stopColor ignoreColor maskColor highBetColor lowBetColor betFixColor proFixColor redColor greenColor blueColor magentaColor cyanColor yellowColor brownColor whiteColor blackColor nTarg sizeArray angleArray ampDefault ampArray Set_Tones Success_Tone_bigR Success_Tone_medR Success_Tone_smlR Failure_Tone_smlP Failure_Tone_medP Failure_Tone_bigP TargetSizeConversion AutoTargetSizeFlag targDuration trialAmp ssd decideSSD decideIndex nIndex lastOutcome randomAmpFlag ampIndex nTrialAmpSSD nSaccAmpSSD nCheckerColumn nCheckerRow nSquare checkerAmp checkerAngle decideCheckerAngle checkerTarg iSquareSizePixels nDiscriminate maxDiscriminate minDiscriminate targetRightRate fiftyPercentRate targ1PropArray trialDist trialRate trialRateBound Targ2SquareColor Targ1SquareColor checkerboardArray nTrialPsySSD nSaccPsySSD nTarg1PsySSD lastStopArray decideSSDArray targ1ExtraPct targ2ExtraPct checkerIsTarg checkerTargRate distIndex ccmDelayFlag psyValue psyIndex nTarg1Respond goPropArray goCheckerProp NoGoSquareColor GoSquareColor proportionIndex nPsy nPsyRespond fixWinSize targWinSize chkrWinSize betWinSize trialStartTime allowFixTime expoJitterFlag expoJitterFlag_SOA holdtimeMin holdtimeMax soaMin soaMax soa saccTimeMax saccDurationMax targHoldtime nSSD ssdMax ssdMin Staircase ssdArray holdStopDuration toneDuration rewardDelay baseRewardDuration basePunishDuration rewardDuration punishDuration toneChoiceSuccess toneChoiceFailure toneStopSuccess toneStopFailure toneAbort toneTargHigh toneTargLow toneDistHigh toneDistLow Bmove_tout Move_ct Max_move_ct TrainingStill Canc_alert fixedTrialDuration trialDuration interTrialDuration maskAmpArray maskAngleArray betAmpArray betAngleArray maskSize betSize maskPct betPct retroPct proPct nBet highBetAngle lowBetAngle acceptBetAngle highBetAmp lowBetAmp highBetRightRate soaArray nSOA decideSOA lastMaskOutcome lastMaskArray decideSOAArray fakeCorrectRate stimDuration setSizeArray sameDiffArray nTrialsArray condCounterArray vwmColorArray vwmAngleArray LocArray ColorArray memRefresh retDuration fixDuration saccadeInitiationDuration testDuration testRefresh testHoldDuration nTrialsperCond testAmp lorr vwm_performance DEFAULT i r_ g_ b_ #I0 #I1 #I2 #L0 #L1 #L2 #L3 #L4 #I40 #I55 #I60 #I70 #M42820000 #M420C0000 #M42640000 #I43 #M42480000 #M00000000 #M420551EC #M42055C29 #I45 #I36 #I35 #I33 #I27 #I3 #I4 #I5 #I6 #I7 #M3F333333 #I180 #M43340000 #I90 #M42B40000 #I135 #M43070000 #I-135 #MC3070000 #I-90 #MC2B40000 #I-45 #MC2340000 #I15 #M3F000000 #I800 #I1600 #I3200 #I100 #I200 #I400 #I1000 #I3800 #I2600 #I1400 #I20 #I6000 #M3DCCCCCD #M40400000 #I9 #M40200000 #M3F666666 #F0 #F1 #I2500 #I500 #I1500 #I1150 #I1350 #I75 #I150 #I1100 #I8 #M42340000 #M41300000 #M4179999A #I1200 #I600 #M40A00000 #M40F00000 #M41200000 #M41480000 #M41700000 #M41A00000 #M41C80000 #L5 #L6 #L7 #L8 #L9 #L10 #L11 #L12 #I2200 #I1050 #M40C00000 #M41100000 #I12 #M41400000 #I18 #M41900000 #I21 #M41A80000 #I24 #M41C00000 #M41D80000 #I30 #M41F00000 #I10 #M42040000 #I11 #M42100000 #I-1 #M3ED1EB85 #M3EE66666 #M3EF5C28F #M3F051EB8 #M3F0CCCCD #M3F170A3D #M3F800000 #I54 #M3E19999A #M3EB33333 #M3F266666 #M3F59999A #I72 #I42 #M40800000 #I25 #I-30 #MC1F00000 #M43160000 #I-150 #MC3160000 #M3FC00000 #I50 #I13 #I17 #I19 broca #I28 #M43ED8000 #I29 #M43E88000 #M42680000 #I23 #M41B80000 #I26 #M41D00000 #M41E80000 #I32 #M42000000 #I38 #M42180000 #I41 #M42240000 #M3F4CCCCD #M404CCCCD #M3EEA0EA1 #M40E00000 #M41880000 #I37 #M42140000 #I47 #M423C0000 #I57 #M3ED70A3D #M3EF0A3D7 #M3F07AE14 #M3F147AE1 #I31 cajal #I80 #I700 #I3000 #I63 #M43610000 #M439D8000 euler #I4000 #M41840000 #I16 #M42870000 #I67 #M42220000 #M40D00000 GOODVARS j sumDist trialRateFactor WARNING!!!
 #S0 Trial weights do not sum to 100.
 #S1 CHANGE PARAMETERS BEFORE RECORDING
 #S2 dpop #S3 #M447A0000 #M4167E252 WARNING!!!
 #S4 SSDs exceed Max time allowed...
 #S5 ...for saccade to target.
 #S6 CHANGE PARAMETERS BEFORE RECORDING
 #S7 dpop #S8 #L13 #L14 WARNING!!!
 #S9 Trial length too short
 #S10 Extending trial length to %d
 #S11 WARNING!!!
 #S12 Trial weights do not sum to 100.
 #S13 CHANGE PARAMETERS BEFORE RECORDING
 #S14 dpop #S15 #F2 %d
 #S16 WARNING!!!
 #S17 SSDs exceed Max time allowed...
 #S18 ...for saccade to target.
 #S19 CHANGE PARAMETERS BEFORE RECORDING
 #S20 dpop #S21 WARNING!!!
 #S22 Trial length too short
 #S23 Extending trial length to %d
 #S24 WARNING!!!
 #S25 Trial weights do not sum to 100.
 #S26 CHANGE PARAMETERS BEFORE RECORDING
 #S27 dpop #S28 WARNING!!!
 #S29 Trial length too short
 #S30 Extending trial length to %d
 #S31 WARNING!!!
 #S32 Trial length too short
 #S33 Extending trial length to %d
 #S34 WARNING!!!
 #S35 Trial weights do not sum to 100.
 #S36 CHANGE PARAMETERS BEFORE RECORDING
 #S37 dpop #S38 SET_CLRS color_num cm %d %d %d %d;
 #S39 cm 255 %d %d %d;
 #S40 cm 254 %d %d %d;
 #S41 cm 253 %d %d %d;
 #S42 cm 252 %d %d %d;
 #S43 cm 251 %d %d %d;
 #S44 cm 250 %d %d %d;
 #S45 cm 249 %d %d %d;
 #S46 cm 248 %d %d %d;
 #S47 cm 247 %d %d %d;
 #S48 cm 246 %d %d %d;
 #S49 cm 245 %d %d %d;
 #S50 cm 244 %d %d %d;
 #S51 cm 243 %d %d %d;
 #S52 cm 242 %d %d %d;
 #S53 cm 241 %d %d %d;
 #S54 cm 240 %d %d %d;
 #S55 cm 239 %d %d %d;
 #S56 PORTA PORTB PORTC Deg2Pix_X Deg2Pix_Y Unit2Pix_X Unit2Pix_Y SET_COOR half_width half_height deg_x deg_y #M43020000 #I320 #I240 vc %d, %d, %d, %d
 #S57 #M3FE38E39 #M3FEC4EC5 gLEFT gRIGHT tPOINT tBOX tCROSS tXCROSS tELLIPSE aXOR aREPLACE aVISIBLE aINVISIBLE aFILLED aUNFILLED aSIZE aRANGE aTITLE aCLEAR object_fixwin object_eye object_targwin object_distwin object_chkrwin object_fix object_targ object_checker object_distwin1 object_distwin2 object_distwin3 object_highBet object_lowBet object_highBetwin object_lowBetwin object_ssd0 object_ssd1 object_ssd2 object_ssd3 object_ssd4 object_ssd5 object_ssd6 object_ssd7 object_ssd8 object_ssd9 object_ssd10 object_ssd11 object_psy0 object_psy1 object_psy2 object_psy3 object_psy4 object_psy5 object_psy6 object_psy7 object_psy8 object_psy9 GRAPHS left right down up #I-2 #I-320 #I-240 *** TASK *** #S58 FirstTrial SET_PSY psy_range psy_left psy_right psy_box_size #I1025 #I-25 *** PSYCHOMETRIC FUNCTION *** #S59 JUICE channel duration #P1 #P2 closed STIM STIMULATION
 #S60 STAIR plus_minus randStep STAIR_DSC lowBound hiBound targIndex distIndex1 distIndex2 distIndex3 highBetIndex lowBetIndex signalColor preTargHoldtime postTargHoldtime preBetHoldtime preProHoldtime targ1CheckerProp targ1 targ2 acceptCondFlag acceptColorFlag acceptLocFlag condIndex colorIndex locIndex nColorsArray nLocsArray setsize samediff testColor color_counter loc_counter SETTRIAL per_jitter jitter randomProp holdtimeDiff soa_diff iLevel acceptTargetFlag acceptPropFlag ampArrayIndex useMiddleStimFlag agreeFlag randomPct #I1001 #MBF800000 #M3E800000 #M3F19999A #I10001 #M42C80000 #M3F400000 #I247 Color = %d
 #S61 Loc = %d
 #S62 targAngle = %d
 #S63 Fix_win_left Fix_win_right Fix_win_down Fix_win_up Targ_win_left Targ_win_right Targ_win_down Targ_win_up Dist_win_left Dist_win_right Dist_win_down Dist_win_up Chkr_win_left Chkr_win_right Chkr_win_down Chkr_win_up highBet_win_left highBet_win_right highBet_win_down highBet_win_up lowBet_win_left lowBet_win_right lowBet_win_down lowBet_win_up Dist1_win_left Dist1_win_right Dist1_win_down Dist1_win_up Dist2_win_left Dist2_win_right Dist2_win_down Dist2_win_up Dist3_win_left Dist3_win_right Dist3_win_down Dist3_win_up WINDOWS fixX fixY targX targY distX distY chkrX chkrY dist1X dist1Y dist2X dist2Y dist3X dist3Y hbetX hbetY lbetX lbetY old_fix_win_size old_targ_win_size old_chkr_win_size old_bet_win_size #M3ECCCCCD #F3 #F4 targAngle = %d
 #S64 In_FixWin In_TargWin In_DistWin In_ChkrWin In_HighBetWin In_LowBetWin LOCATE_I eyeX eyeY #Q1 #Q2 #L15 #L16 #L17 #L18 #L19 #L20 #L21 #L22 #L23 Eye_on_VDOSync CenterEyeNow WATCHEYE eye_x eye_y oldx oldy lasttime plot_x plot_y #M39A00000 cl;
 #S65 ru %d,%d,%d,%d;
 #S66 co %d;
 #S67 TONE frequency count off #I10000000 TONESWEP #I64000 #I32000 #I16000 #I8000 #I2000 #I250 CheckMotion WATCHMTH mouth_channel mouth_thresh still moving mouth_status last_status mouth mouth_time WATCHBOD body_channel sample_n a_sets SVR_BELL SVR_BEL2 DRW_SQR squareSize squareAngle squareAmp squareColor conversion_X conversion_Y #Q3 #P4 #P5 #Q6 #Q7 stim_ecc_x stim_ecc_y half_size ulx uly lrx lry co %d;
 #S68 ru %d,%d,%d,%d;
 #S69 rf %d,%d,%d,%d;
 #S70 CheckerWidthDegrees CheckerHeightDegrees DRW_CHKR changeStimulus iSquare iRow iColumn tempIndex tempColor iSquareIndex iSquareColorChannel iSquareCenterX iSquareCenterY iSquareEccentricity iSquareAngle iSquareULX checkerULX iSquareULY checkerULY iSquareLRX checkerLRX iSquareLRY checkerLRY nTarg1Square nTarg2Square checkerOffsetX checkerOffsetY checkerSizePixels largeSquareColorR largeSquareColorG largeSquareColorB smallSquareColorR smallSquareColorG smallSquareColorB iSquareColor iChecker nTarg2 nTarg1 majorityColor minorityColor nMinority nRowRemain nMax nMin randInsert nInsert minorityP cm 100 %d %d %d;
 #S71 co %d;
 #S72 rf %d,%d,%d,%d;
 #S73 cm 101 %d %d %d;
 #S74 #I101 co %d;
 #S75 rf %d,%d,%d,%d;
 #S76 GoNoGoFlag Go Nogo DRW_GNG iGoSquare iNoGoSquare nGoSquare nNoGoSquare cm 100 %d %d %d;
 #S77 co %d;
 #S78 rf %d,%d,%d,%d;
 #S79 cm 101 %d %d %d;
 #S80 co %d;
 #S81 rf %d,%d,%d,%d;
 #S82 cm 101 %d %d %d;
 #S83 co %d;
 #S84 rf %d,%d,%d,%d;
 #S85 MSK_PGS blank fixation_pd fixation fixation_target fix_mask_pd fix_mask mask_pd mask tempFixColor iMaskAngle iMaskAmp #M42FA0000 #M432F0000 rw %d,%d;
 #S86 cl:
 #S87 rw %d,%d;
 #S88 cl:
 #S89 rw %d,%d;
 #S90 cl:
 #S91 rw %d,%d;
 #S92 cl:
 #S93 rw %d,%d;
 #S94 cl:
 #S95 rw %d,%d;
 #S96 cl:
 #S97 rw %d,%d;
 #S98 cl:
 #S99 rw %d,%d;
 #S100 cl:
 #S101 BET_PGS pd betFix_pd betFix fix_bet_pd fix_bet rw %d,%d;
 #S102 cl:
 #S103 rw %d,%d;
 #S104 cl:
 #S105 rw %d,%d;
 #S106 cl:
 #S107 rw %d,%d;
 #S108 cl:
 #S109 rw %d,%d;
 #S110 cl:
 #S111 nSuccess MSKTRIAL need_fix fixating mask_on fix_off in_flight on_target on_distractor stage fix_spot_time targ_time mask_time fix_off_time saccade_time aquire_fix_time aquire_targ_time aquire_dist_time  
 #S112  ********   DECISION TRIAL  ********
 #S113 # %d #S114  (%d complete)
 #S115 pre-target holdtime = %d
 #S116 post-target holdtime = %d
 #S117                soa = %d
 #S118 vp %d
 #S119 XM RFRSH:
 #S120 vp %d
 #S121 vp %d
 #S122 Aborted (no fixation)
 #S123 vp %d
 #S124 Aborted (broke fixation)
 #S125 vp %d
 #S126 vw %d
 #S127 vp %d
 #S128 XM RFRSH:
 #S129 vp %d
 #S130 vp %d
 #S131 Aborted (broke fixation)
 #S132 vp %d
 #S133 XM RFRSH:
 #S134 vp %d
 #S135            rt = %d
 #S136 vp %d
 #S137 Error (no saccade)
 #S138 vp %d
 #S139 Error (inaccurate saccade)
 #S140 vp %d
 #S141 Error (broke target fixation)
 #S142 Correct (saccade)
 #S143 vp %d
 #S144 vp %d
 #S145 Error (broke distractor fixation)
 #S146 Error to distractor (saccade)
 #S147 vp %d
 #S148 BETTRIAL bet_on on_Highbet on_Lowbet betTarg_time aquire_bet_time  
 #S149  ********   BET TRIAL   ********
 #S150 # %d #S151  (%d complete)
 #S152 preBet Holdtime = %d
 #S153 vp %d
 #S154 XM RFRSH:
 #S155 vp %d
 #S156 vp %d
 #S157 Aborted (no fixation)
 #S158 vp %d
 #S159 Aborted (broke fixation)
 #S160 vp %d
 #S161 XM RFRSH:
 #S162 vp %d
 #S163            rt = %d
 #S164 vp %d
 #S165 Error (no saccade)
 #S166 vp %d
 #S167 Error (inaccurate saccade)
 #S168 vp %d
 #S169 Error (broke bet target fixation)
 #S170 High Bet (saccade)
 #S171 vp %d
 #S172 vp %d
 #S173 Error (broke bet target fixation)
 #S174 Low Bet (saccade)
 #S175 vp %d
 #S176 RETTRIAL need_betFix betFixating in_betFlight  
 #S177  ********   RETRO TRIAL   ********
 #S178 # %d #S179  (%d complete)
 #S180 pre-target holdtime = %d
 #S181 post-target holdtime = %d
 #S182                soa = %d
 #S183 vp %d
 #S184 XM RFRSH:
 #S185 vp %d
 #S186 vp %d
 #S187 Aborted (no fixation)
 #S188 vp %d
 #S189 Aborted (broke fixation)
 #S190 vp %d
 #S191 vw %d
 #S192 vp %d
 #S193 XM RFRSH:
 #S194 vp %d
 #S195 vp %d
 #S196 Aborted (broke fixation)
 #S197 vp %d
 #S198 XM RFRSH:
 #S199 vp %d
 #S200            rt = %d
 #S201 vp %d
 #S202 Error (no saccade)
 #S203 vp %d
 #S204 Error (inaccurate saccade)
 #S205 vp %d
 #S206 Error (broke target fixation)
 #S207 Correct (saccade)
 #S208 vp %d
 #S209 XM RFRSH:
 #S210 vp %d
 #S211 vp %d
 #S212 Error (broke distractor fixation)
 #S213 Error to distractor (saccade)
 #S214 vp %d
 #S215 XM RFRSH:
 #S216 vp %d
 #S217 vp %d
 #S218 Aborted (no fixation)
 #S219 vp %d
 #S220 Aborted (broke fixation)
 #S221 vp %d
 #S222 XM RFRSH:
 #S223 vp %d
 #S224            rt = %d
 #S225 vp %d
 #S226 Error (no saccade)
 #S227 vp %d
 #S228 Error (inaccurate saccade)
 #S229 vp %d
 #S230 Error (broke bet target fixation)
 #S231 High Bet (saccade)
 #S232 vp %d
 #S233 vp %d
 #S234 Error (broke bet target fixation)
 #S235 Low Bet (saccade)
 #S236 vp %d
 #S237 PROTRIAL need_proFix proFixating proMaskOn  
 #S238  ********   PRO TRIAL   ********
 #S239 # %d #S240  (%d complete)
 #S241 pre-target holdtime = %d
 #S242 post-target holdtime = %d
 #S243                soa = %d
 #S244 vp %d
 #S245 XM RFRSH:
 #S246 vp %d
 #S247 vp %d
 #S248 Aborted (no fixation)
 #S249 vp %d
 #S250 Aborted (broke fixation)
 #S251 vp %d
 #S252 vw %d
 #S253 vp %d
 #S254 XM RFRSH:
 #S255 vp %d
 #S256 vp %d
 #S257 Aborted (broke fixation)
 #S258 vp %d
 #S259 XM RFRSH:
 #S260 vp %d
 #S261 vp %d
 #S262 Aborted (broke fixation)
 #S263 vp %d
 #S264 XM RFRSH:
 #S265 vp %d
 #S266            rt = %d
 #S267 vp %d
 #S268 Error (no saccade)
 #S269 vp %d
 #S270 Error (inaccurate saccade)
 #S271 vp %d
 #S272 Error (broke bet target fixation)
 #S273 High Bet (saccade)
 #S274 vp %d
 #S275 vp %d
 #S276 XM RFRSH:
 #S277 vp %d
 #S278 vp %d
 #S279 Error (broke bet target fixation)
 #S280 Low Bet (saccade)
 #S281 vp %d
 #S282 vp %d
 #S283 XM RFRSH:
 #S284 vp %d
 #S285 vp %d
 #S286 Aborted (no fixation)
 #S287 vp %d
 #S288 Aborted (broke fixation)
 #S289 vp %d
 #S290 XM RFRSH:
 #S291 vp %d
 #S292            rt = %d
 #S293 vp %d
 #S294 Error (no saccade)
 #S295 vp %d
 #S296 Error (inaccurate saccade)
 #S297 Error (broke target fixation)
 #S298 Correct (saccade)
 #S299 vp %d
 #S300 vp %d
 #S301 Error (broke distractor fixation)
 #S302 Error to distractor (saccade)
 #S303 vp %d
 #S304 UPD8_PSY ct position_x position_y nPsy: %d
 #S305 INFOS stopColor_r stopColor_g stopColor_b ignoreColor_r ignoreColor_g ignoreColor_b fixColor_r fixColor_g fixColor_b targColor_r targColor_g targColor_b targ1CheckerColor_r targ1CheckerColor_g targ1CheckerColor_b targ2CheckerColor_r targ2CheckerColor_g targ2CheckerColor_b goCheckerColor_r goCheckerColor_g goCheckerColor_b nogoCheckerColor_r nogoCheckerColor_g nogoCheckerColor_b maskColor_r maskColor_g maskColor_b highBetColor_r highBetColor_g highBetColor_b lowBetColor_r lowBetColor_g lowBetColor_b betFixColor_r betFixColor_g betFixColor_b proFixColor_r proFixColor_g proFixColor_b #M43B5199A #M43BFD999 REWARDS now trl_end_time tone_time tone_type noFix_punish abort_punish play_the_odds rewardRandomIncrease rewardMaxIncreasePercent rewards_start_time goIncorrect 
 #S306 #M3FA66666 #M3F99999A goIncorrect 
 #S307 #I300 goIncorrect 
 #S308 dpop #S309 KEY_REWD juice_duration tone_freq tone_durr KEY_T_UP KEY_T_DN KEY_MOVE KEY_STIM WAIT_MU u_sec start clock_cycles #M3F989375 #I65535 SEND_TTL value output #I255 #I128 #I127 QUE_TTL send_event n_evs_sent idling vi 256; #S310 ca #S311 flushing video memory please wait...
 #S312 #I5000 done!
 #S313 dialog Choose_Task #S314 dialog Select_Monkey #S315 key curup = spawn KEY_REWD #S316 key pgup = spawn KEY_STIM #S317 DM RFRSH #S318 vw %d:
 #S319 vw %d:
 #S320 EM RFRSH #S321             
   8    D    P    \    h    t              	    	    	       D       
    
    
    
  $    0    <  d       P          X             
     
   !    ,!    8!  
  `!  
  !    !    !    !    !    !  
  "     "    0"    `"    "    "    "  	   \#    l#    |#    #    #    $    8$    D$    P$  
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         3
T/10/20/03   \@  #            
       C                                         FAT32                   J//--------------------------------------------------------------------------------------------------
// process MSK_PGS();
//
// Figure out all stimuli that will be needed on the next mem guided trial and
// place it all into video memory.
//
// written by david.c.godlove@vanderbilt.edu 	July, 2011


declare MSK_PGS();                       										// see GRAPHS.pro

process MSK_PGS()	                       										// see GRAPHS.pro
{

// number the pgs that need to be drawn
declare hide int   	blank       		= 0;
declare hide int	fixation_pd			= 1;
declare hide int	fixation    		= 2;
declare hide int	fixation_target		= 3;
declare hide int	fix_mask_pd			= 4;
declare hide int	fix_mask    		= 5;
declare hide int	mask_pd   			= 6;
declare hide int	mask      			= 7;

declare int i;
declare int tempFixColor;

declare float iMaskAngle, iMaskAmp;
if (trialType == tProTrial)
	{
	tempFixColor = proFixColor;
	}
else
	{
	tempFixColor = fixColor;
	}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Calculate screen coordinates for stimuli on this trial

targColor        = targIndex + 1;												// zero is reserved for black.  see SET_CLRS.pro

opposite = ((screenHeight/2)-pdBottom);														// Figure out angle and eccentricity of photodiode marker in pixels
adjacent = ((screenWidth/2)-pdLeft);                                                         // NOTE: I am assuming your pd is in the lower left quadrant of your screen
pdAmp = sqrt((opposite * opposite) + (adjacent * adjacent));
pdAngle = rad2deg(atan (opposite / adjacent));
pdAngle = pdAngle + 180; 																	//change this for different quadrent or write some code for flexibility


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 1
// print("fixation with photodiode");
dsendf("rw %d,%d;\n",fixation_pd,fixation_pd); 												// draw second pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, tempFixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 2
// print("fixation");
dsendf("rw %d,%d;\n",fixation,fixation); 												// draw second pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, tempFixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
nexttick;


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 3
// print("fixation target and photodiode");
dsendf("rw %d,%d;\n",fixation_target,fixation_target);   								// draw 4th pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, tempFixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 4
// print("fixation target and photodiode");
dsendf("rw %d,%d;\n",fix_mask_pd,fix_mask_pd);   								// draw 4th pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, tempFixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
i = 0;
while (i < nTarg)
	{
	// iMaskAngle = maskAngleArray[i];
	// iMaskAmp = maskAmpArray[i];
	// spawnwait DRW_SQR(maskSize, iMaskAngle, iMaskAmp, maskColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
	spawnwait DRW_SQR(maskSize, maskAngleArray[i], maskAmpArray[i], maskColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
	i = i + 1;
	}
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 5
// print("fixation target and photodiode");
dsendf("rw %d,%d;\n",fix_mask,fix_mask);   								// draw 4th pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, tempFixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
i = 0;
while (i < nTarg)
	{
	spawnwait DRW_SQR(maskSize, maskAngleArray[i], maskAmpArray[i], maskColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
	i = i + 1;
	}
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 6
// print("fixation target and photodiode");
dsendf("rw %d,%d;\n",mask_pd,mask_pd);   								// draw 4th pg of video memory
dsendf("cl:\n");																			// clear screen
i = 0;
while (i < nTarg)
	{
	spawnwait DRW_SQR(maskSize, maskAngleArray[i], maskAmpArray[i], maskColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
	i = i + 1;
	}
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 7
// print("fixation target and photodiode");
dsendf("rw %d,%d;\n",mask,mask);   								// draw 4th pg of video memory
dsendf("cl:\n");																			// clear screen
i = 0;
while (i < nTarg)
	{
	spawnwait DRW_SQR(maskSize, maskAngleArray[i], maskAmpArray[i], maskColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
	i = i + 1;
	}
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 0 (last is displayed first)
// print("blank");
dsendf("rw %d,%d;\n",blank,blank);                                          				// draw the blank screen last so that it shows up first
dsendf("cl:\n");                                                                            // clear screen (that's all)

}//--------------------------------------------------------------------------------------------
// Run a reverse masking trial based on the variables calculated by SETCCTRL.pro and those 
// given by the user.
//

declare hide int lastOutcome = 1;	// Global output used to staircase SSD
declare int nSuccess;

declare MSKTRIAL();			// animated graph object

process MSKTRIAL()        		// animated graph object
{


// Number the trial stages to make them easier to read below
declare hide int 	need_fix  		= 1;
declare hide int 	fixating  		= 2;
declare hide int 	mask_on   		= 3;
declare hide int 	fix_off  		= 4;
declare hide int 	in_flight 		= 5;
declare hide int 	on_target 		= 6;	
declare hide int 	on_distractor 	= 7;	// pgm
declare hide int 	stage;

// number the pgs that need to be drawn: need to be same as MSK_PGS
declare hide int   	blank       		= 0;
declare hide int	fixation_pd			= 1;
declare hide int	fixation    		= 2;
declare hide int	fixation_target		= 3;
declare hide int	fix_mask_pd			= 4;
declare hide int	fix_mask    		= 5;
declare hide int	mask_pd   			= 6;
declare hide int	mask      			= 7;

											
// Timing variables which will be used to time task
declare hide float 	fix_spot_time; 					
declare hide float  targ_time; 					
declare hide float  mask_time; 					
declare hide float  fix_off_time; 					
declare hide float  saccade_time;
declare hide float 	aquire_fix_time;
declare hide float	aquire_targ_time;	
declare hide float	aquire_dist_time;	



opposite = ((screenHeight/2)-pdBottom);														// Figure out angle and eccentricity of photodiode marker in pixels
adjacent = ((screenWidth/2)-pdLeft);                                                         // NOTE: I am assuming your pd is in the lower left quadrant of your screen
pdAmp = sqrt((opposite * opposite) + (adjacent * adjacent));
pdAngle = rad2deg(atan (opposite / adjacent));
pdAngle = pdAngle + 180; 																	//change this for different quadrent or write some code for flexibility


// Have to be reset on every iteration since 
// variable declaration only occurs at load time
trl_running 		= 1;
stage 				= need_fix;

// Tell the user what's up
printf(" \n");
printf(" ********   DECISION TRIAL  ********\n");
printf("# %d",nTrial);
printf(" (%d complete)\n",nTrialComplete);
printf("pre-target holdtime = %d\n",preTargHoldtime);
printf("post-target holdtime = %d\n",postTargHoldtime);
printf("               soa = %d\n",round(soa * (1000.0/screenRefreshRate)));


																		// HERE IS WHERE THE FUN BEGINS
Event_fifo[Set_event] = TrialStart_;									// queue TrialStart_ strobe
Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
dsendf("vp %d\n",fixation_pd);											// flip the pg to the fixation stim with pd marker
fix_spot_time = time();  													// record the time
Event_fifo[Set_event] = FixSpotOn_;										// queue strobe
Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
dsendf("XM RFRSH:\n"); 													// wait for one retrace
dsendf("vp %d\n",fixation);												// flip the pg to the fixation stim without pd marker
oSetAttribute(object_fix, aVISIBLE); 									// turn on the fixation point in animated graph


while (trl_running)														// trials ending will set trl_running = 0
	{	
	
//--------------------------------------------------------------------------------------------
// STAGE need_fix (the fixation point is on, but the subject hasn't looked at it)
	if (stage == need_fix)
		{		
		if (In_FixWin)													// If the eyes have entered the fixation window (before time, see below)...
			{
			aquire_fix_time = time();									// ...function call to time to note current time and...
			trialStartTime = aquire_fix_time;							// Global output for timing iti
			Event_fifo[Set_event] = DecFixate_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = fixating;											// ...advance to the next stage.
			}
		else if (time() > fix_spot_time + allowFixTime)				// But if time runs out...
			{
			trialOutcome = noFix;    									// TRIAL OUTCOME ABORT (no fixation)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen,...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Aborted (no fixation)\n");							// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}			
		}
		
		

//--------------------------------------------------------------------------------------------
// STAGE fixating (the subject is looking at the fixation point waiting for target onset)		
	else if (stage == fixating)
		{
		if (!In_FixWin && time() > aquire_fix_time + 200)													// If the eyes stray out of the fixation window...
			{
			trialOutcome = brokeFix;									// TRIAL OUTCOME ABORT (broke fixation)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}
		else if (In_FixWin && time() > aquire_fix_time + preTargHoldtime)	// But if the eyes are still in the window at end of holdtime...
			{
			targ_time = time(); 										// ...record the time...
			dsendf("vp %d\n",fixation_target);						// ...flip the pg to the target with pd marker...	
			dsendf("vw %d\n",soa);							// Wait so many vertical retraces 
			dsendf("vp %d\n",fix_mask_pd);							// ...flip the pg to the signal with the pd marker...
			mask_time = targ_time + 
				(round(soa * (1000.0 / screenRefreshRate))); 		// ...record TEMPO time of presentation...
			dsendf("XM RFRSH:\n"); 									// ...wait 1 vertical retrace...
			dsendf("vp %d\n",fix_mask);								// ...and flip the pg to the signal without pd marker.
	

			oSetAttribute(object_targ, aVISIBLE); 						// ...show target in animated graph...
													
			stage = mask_on;											// Advance to the next trial stage.				
			}
		}
		
		

//--------------------------------------------------------------------------------------------
// STAGE mask_on (the subject is looking at the fixation point waiting for cue to make saccade)		
	else if (stage == mask_on)
		{
		if (!In_FixWin)													// If the eyes stray out of the fixation window...
			{
			trialOutcome = brokeFix;									// TRIAL OUTCOME ERROR (broke fixation)
			lastOutcome = noChange;								// Don't change SSD
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			spawn SVR_BELL();
			printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}
		else if (In_FixWin && time() > mask_time + postTargHoldtime)	// But if the eyes are still in the window at end of holdtime...
			{
			dsendf("vp %d\n",mask_pd);								// ...flip the pg to the choice stim pd marker...	
			fix_off_time = time(); 										// ...record the time...
			dsendf("XM RFRSH:\n"); 										// ...wait one vetical retrace...
			dsendf("vp %d\n",mask);									// ...flip the pg to the choice stim without pd marker.

			oSetAttribute(object_fix, aINVISIBLE); 					// ...remove fixation point from animated graph.
				
			stage = fix_off;											// Advance to the next trial stage.				
			}
		}
		
		

//--------------------------------------------------------------------------------------------
// STAGE fix_off (the fixation spot has been extinguished but the masks are still visible)		
	else if (stage == fix_off)
		{		
		if (!In_FixWin)													// If the eyes leave the fixation window...
			{															// ...we have a saccade, so...
			saccade_time = time();										// ...record the time...
			Event_fifo[Set_event] = Saccade_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			printf("           rt = %d\n",saccade_time - fix_off_time);	// ...tell the user whats up...
			stage = in_flight;											// ...and advance to the next stage.
			}
		else if (In_FixWin &&  											// But if no saccade occurs...
			time() > fix_off_time + saccTimeMax)					// ...and time for a saccade runs out...
			{
			trialOutcome = noSacc;           							// TRIAL OUTCOME ERROR
			lastOutcome = noChange;								// Don't change SSD
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (no saccade)\n");								// ...tell the user whats up...
			spawn SVR_BELL();
			trl_running = 0;											// ...and terminate the trial.
			}				
		}
		
		
		
//--------------------------------------------------------------------------------------------
// STAGE in_flight (eyes have left fixation window but have not entered target window)		
	else if (stage == in_flight)
		{
		if (In_TargWin)													// If the eyes get into the target window...
			{
			aquire_targ_time = time();									// ...record the time...
			Event_fifo[Set_event] = Decide_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = on_target;											// ...and advance to the next stage of the trial.
			Event_fifo[Set_event] = Correct_;					// ...queue strobe for Neuro Explorer
			Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.					
			}
		else if (In_DistWin)											// If the eyes get into the distractor window...
			{
			aquire_dist_time = time();									// ...record the time...
			Event_fifo[Set_event] = Decide_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = on_distractor;										// ...and advance to the next stage of the trial.
			Event_fifo[Set_event] = Distract_;					// ...queue strobe for Neuro Explorer
			Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.					
			}
		else if (time() > saccade_time + saccDurationMax)				// But, if the eyes are out of the target window and time runs out...
			{
			trialOutcome = saccOut;   									// TRIAL OUTCOME ERROR (innacurrate saccade)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (inaccurate saccade)\n");						// ...tell the user whats up...
			spawn SVR_BELL();
			trl_running = 0; 											// ...and terminate the trial.
			}
		}
	
	
	
//--------------------------------------------------------------------------------------------
// STAGE on_target (eyes have entered the target window.  will they remain there for duration?)	
	else if (stage == on_target)
		{
		if (!In_TargWin)												// If the eyes left the target or distractor window...
			{			
			trialOutcome = brokeTarg;									// TRIAL OUTCOME ERROR (broke target fixation)
			lastOutcome = noChange;								// Don't change SSD
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (broke target fixation)\n");					// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}		
		else if (In_TargWin  											// But if the eyes are still in the target window...
			&&  time() > aquire_targ_time + targHoldtime)				// ...and the target hold time is up...
			{
			trialOutcome = saccTarg;								//TRIAL OUTCOME CORRECT (correct go trial)
			lastOutcome = success;
			printf("Correct (saccade)\n");							// ...tell the user whats up...
			dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			trl_running = 0;											// ...and terminate the trial.
			}			
		}
		

// STAGE on_distractor (eyes have entered the distractor window.  will they remain there for duration?)	
	else if (stage == on_distractor)
		{
		if (!In_DistWin)												// If the eyes left the distractor or distractor window...
			{			
			trialOutcome = brokeDist;									// TRIAL OUTCOME ERROR (broke target fixation)
			lastOutcome = noChange;								// Don't change SSD
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (broke distractor fixation)\n");				// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}		
		else if (In_DistWin  											// But if the eyes are still in the target window...
			&&  time() > aquire_dist_time + targHoldtime)				// ...and the target hold time is up...
			{
			trialOutcome = saccDist;								//TRIAL OUTCOME CORRECT (correct go trial)
			lastOutcome = failure;								// Don't change SSD
			printf("Error to distractor (saccade)\n");	//pgm						// ...tell the user whats up...
			dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			trl_running = 0;											// ...and terminate the trial.
			}			
		}
		
	nexttick;
	}
}/* OBJECT.PRO - Definitions for use with TEMPO's object functions
** Copyright 1994-2002 Reflective Computing.  All rights reserved.
**
*/

// Graph references used in oCreate() and oSetGraph()

hide constant gLEFT           =0;             // Left graph
hide constant gRIGHT          =1;             // Right graph

// Object types for use with oCreate()

hide constant tPOINT          =1;             // A single pixel
hide constant tBOX            =2;             // A rectangle
hide constant tCROSS          =3;             // '+' Horizontal/Vertical Cross
hide constant tXCROSS         =4;             // 'x' Diagonal Cross
hide constant tELLIPSE        =5;             // An ellipse (VideoSYNC only)

// Object attributes used by oSetAttribute()

hide constant aXOR            =1;             // Erase object when moving
hide constant aREPLACE        =2;             // Replace pixels
hide constant aVISIBLE        =3;             // Make object visible
hide constant aINVISIBLE      =4;             // Don't draw object
hide constant aFILLED         =5;             // Filled rectangle
hide constant aUNFILLED       =6;             // Hollow rectangle
hide constant aSIZE           =7;             // Resize box, cross, plus

// Graph attributes used by oSetGraph()

hide constant aRANGE          =1;             // Define graph coordinate system
hide constant aTITLE          =2;             // Define graph title
hide constant aCLEAR          =3;             // Clear graph

declare hide oB, oE;                    	  // Eye and Box objects (left graph)
declare hide oB1, oE1;                        // Eye and Box objects (right graph)


declare GRAPHS(int screenPixelX, int screenPixelY);

process GRAPHS(int screenPixelX, int screenPixelY)
	{
	// SETUP UP TARGET & EYE OBJECTS IN LEFT GRAPH
	left = screenPixelX/-2;
	right = screenPixelX/2;
	down = screenPixelY/-2;
	up = screenPixelY/2;
    oSetGraph(gleft, arange, left, right, down, up); // Object graph virt. coord
    // oB = oCreate(tBOX, gLEFT, 0.5, 0.5);    // Create TARGET object
    // oSetAttribute(oB, aINVISIBLE);              // Not visible yet

    oE = oCreate(tCross, gLEFT, 50, 50);       // Create EYE object
    oSetAttribute(oE, aVISIBLE);                // It's always visible

    // dsendf("oc 1,3\n");                          // Cross hair for "eye"
    // dsendf("ow 1,20,20\n");                      // width & height
    // dsendf("oi 1,13\n");                         // targColor
    // dsendf("os 1\n");                            // make visible
	}//--------------------------------------------------------------------------------------------
// Run a reverse masking prospective monitoring trial based on the variables calculated by SETTRIAL.pro and those 
// given by the user.
//

declare hide int lastOutcome = 1;	// Global output used to staircase SSD
declare int nSuccess;

declare PROTRIAL();			// 

process PROTRIAL()        		// 
{


// Number the trial stages to make them easier to read below
declare hide int 	need_fix  		= 1;
declare hide int 	fixating  		= 2;
declare hide int 	mask_on   		= 3;
declare hide int 	betFixating  	= 4;
declare hide int 	bet_on   		= 5;
declare hide int 	in_betFlight 	= 6;
declare hide int 	on_Highbet 		= 7;	
declare hide int 	on_Lowbet 		= 8;	
declare hide int 	need_proFix  	= 9;
declare hide int 	proFixating  	= 10;
declare hide int 	proMaskOn   	= 11;
declare hide int 	in_flight 		= 12;
declare hide int 	on_target 		= 13;	
declare hide int 	on_distractor 	= 14;
declare hide int 	stage;

// number the pgs that need to be drawn: need to be same as MSK_PGS and BET_PGS
// from MSK_PGS
declare hide int   	blank       		= 0;
declare hide int	fixation_pd			= 1;
declare hide int	fixation    		= 2;
declare hide int	fixation_target		= 3;
declare hide int	fix_mask_pd			= 4;
declare hide int	fix_mask    		= 5;
declare hide int	mask_pd   			= 6;
declare hide int	mask      			= 7;
// from BET_PGS
declare hide int	betFix_pd			= 2;
declare hide int	betFix    			= 3;
declare hide int	fix_bet_pd			= 4;
declare hide int	fix_bet				= 5;

											
// Timing variables which will be used to time task
declare hide float 	fix_spot_time; 					
declare hide float  targ_time; 					
declare hide float  mask_time; 					
declare hide float  betTarg_time; 					
declare hide float  fix_off_time; 					
declare hide float  saccade_time;
declare hide float 	aquire_fix_time;
declare hide float	aquire_targ_time;	
declare hide float	aquire_dist_time;	
declare hide float	aquire_bet_time;	



opposite = ((screenHeight/2)-pdBottom);														// Figure out angle and eccentricity of photodiode marker in pixels
adjacent = ((screenWidth/2)-pdLeft);                                                         // NOTE: I am assuming your pd is in the lower left quadrant of your screen
pdAmp = sqrt((opposite * opposite) + (adjacent * adjacent));
pdAngle = rad2deg(atan (opposite / adjacent));
pdAngle = pdAngle + 180; 																	//change this for different quadrent or write some code for flexibility


// Have to be reset on every iteration since 
// variable declaration only occurs at load time
trl_running 		= 1;
stage 				= need_fix;

// Tell the user what's up
printf(" \n");
printf(" ********   PRO TRIAL   ********\n");
printf("# %d",nTrial);
printf(" (%d complete)\n",nTrialComplete);
printf("pre-target holdtime = %d\n",preTargHoldtime);
printf("post-target holdtime = %d\n",postTargHoldtime);
printf("               soa = %d\n",round(soa * (1000.0/screenRefreshRate)));


																		// HERE IS WHERE THE FUN BEGINS
Event_fifo[Set_event] = TrialStart_;									// queue TrialStart_ strobe
Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
dsendf("vp %d\n",fixation_pd);											// flip the pg to the fixation stim with pd marker
Event_fifo[Set_event] = FixSpotOn_;										// queue strobe
Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
dsendf("XM RFRSH:\n"); 													// wait for one retrace
dsendf("vp %d\n",fixation);												// flip the pg to the fixation stim without pd marker
oSetAttribute(object_fix, aVISIBLE); 									// turn on the fixation point in animated graph


while (trl_running)														// trials ending will set trl_running = 0
	{	
	
//--------------------------------------------------------------------------------------------
// STAGE need_fix (the fixation point is on, but the subject hasn't looked at it)
	if (stage == need_fix)
		{		
		if (In_FixWin)													// If the eyes have entered the fixation window (before time, see below)...
			{
			aquire_fix_time = time();									// ...function call to time to note current time and...
			trialStartTime = aquire_fix_time;							// Global output for timing iti
			Event_fifo[Set_event] = ProFixate_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = fixating;											// ...advance to the next stage.
			}
		else if (time() > fix_spot_time + allowFixTime)				// But if time runs out...
			{
			trialOutcome = noFix;    									// TRIAL OUTCOME ABORT (no fixation)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen,...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Aborted (no fixation)\n");							// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}			
		}
		
		

//--------------------------------------------------------------------------------------------
// STAGE fixating (the subject is looking at the fixation point waiting for target onset)		
	else if (stage == fixating)
		{
		if (!In_FixWin && time() > aquire_fix_time + 200)													// If the eyes stray out of the fixation window...
			{
			trialOutcome = brokeFix;									// TRIAL OUTCOME ABORT (broke fixation)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}
		else if (In_FixWin && time() > aquire_fix_time + preTargHoldtime)	// But if the eyes are still in the window at end of holdtime...
			{
			targ_time = time(); 										// ...record the time...
			dsendf("vp %d\n",fixation_target);						// ...flip the pg to the target with pd marker...	
			dsendf("vw %d\n",soa);							// Wait so many vertical retraces 
			dsendf("vp %d\n",fix_mask_pd);							// ...flip the pg to the signal with the pd marker...
			mask_time = targ_time + 
				(round(soa * (1000.0 / screenRefreshRate))); 		// ...record TEMPO time of presentation...
			dsendf("XM RFRSH:\n"); 									// ...wait 1 vertical retrace...
			dsendf("vp %d\n",fix_mask);								// ...and flip the pg to the signal without pd marker.
	

			oSetAttribute(object_targ, aVISIBLE); 						// ...show target in animated graph...
													
			stage = mask_on;											// Advance to the next trial stage.				

			//********************************************************************************		
			//********************************************************************************		
			// LOAD BET-PGS HERE TO PREPARE FOR THE BET STAGE OF THIS TRIAL
				spawn BET_PGS();	
			//********************************************************************************		
			//********************************************************************************		
			}
		}
		
		

//--------------------------------------------------------------------------------------------
// STAGE mask_on (the subject is looking at the fixation point waiting for bet stage)		
	else if (stage == mask_on)
		{
		if (!In_FixWin)													// If the eyes stray out of the fixation window...
			{
			trialOutcome = brokeFix;									// TRIAL OUTCOME ERROR (broke fixation)
			lastOutcome = noChange;								// Don't change SSD
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			spawn SVR_BELL();
			printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}
		else if (In_FixWin && time() > mask_time + postTargHoldtime)	// But if the eyes are still in the window at end of holdtime...
			{
			aquire_fix_time = time();									// ...function call to time to note current time and...
			dsendf("vp %d\n",betFix_pd);								// ...flip the pg to the choice stim pd marker...	
			fix_off_time = time(); 										// ...record the time...
			dsendf("XM RFRSH:\n"); 										// ...wait one vetical retrace...
			dsendf("vp %d\n",betFix);									// ...flip the pg to the choice stim without pd marker.

			Event_fifo[Set_event] = BetFixate_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			oSetAttribute(object_fix, aINVISIBLE); 					// ...remove fixation point from animated graph.
				
			stage = betFixating;											// Advance to the next trial stage.				
			}
		}
		
//--------------------------------------------------------------------------------------------
// STAGE fixating (the subject is looking at the fixation point waiting for target onset)		
	else if (stage == betFixating)
		{
		if (!In_FixWin)													// If the eyes stray out of the fixation window...
			{
			trialOutcome = brokeFix;									// TRIAL OUTCOME ABORT (broke fixation)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}
		else if (In_FixWin && time() > aquire_fix_time + preTargHoldtime)	// But if the eyes are still in the window at end of holdtime...
			{
			dsendf("vp %d\n",fix_bet_pd);						// ...flip the pg to the target with pd marker...	
			betTarg_time = time(); 										// ...record the time...
			dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
			dsendf("vp %d\n",fix_bet);						// ...flip the pg to the target with pd marker...	
	

			oSetAttribute(object_highBet, aVISIBLE); 						// ...show target in animated graph...
			oSetAttribute(object_lowBet, aVISIBLE); 						// ...show target in animated graph...
													
			stage = bet_on;											// Advance to the next trial stage.				

			//********************************************************************************		
			//********************************************************************************		
			// LOAD MSK_PGS HERE TO PREPARE FOR THE DECISION STAGE OF THIS TRIAL
				spawn MSK_PGS();
			//********************************************************************************		
			//********************************************************************************		
			}
		}
		
		

	

//--------------------------------------------------------------------------------------------
// STAGE bet_on (the fixation spot has been extinguished but the masks are still visible)		
	else if (stage == bet_on)
		{		
		if (!In_FixWin)													// If the eyes leave the fixation window...
			{															// ...we have a saccade, so...
			saccade_time = time();										// ...record the time...
			Event_fifo[Set_event] = Saccade_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			printf("           rt = %d\n",saccade_time - betTarg_time);	// ...tell the user whats up...
			stage = in_betFlight;											// ...and advance to the next stage.
			}
		else if (In_FixWin &&  											// But if no saccade occurs...
			time() > betTarg_time + saccTimeMax)					// ...and time for a saccade runs out...
			{
			trialOutcome = betAbort;           							// TRIAL OUTCOME ERROR
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_highBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_lowBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (no saccade)\n");								// ...tell the user whats up...
			spawn SVR_BELL();
			trl_running = 0;											// ...and terminate the trial.
			}				
		}
		
		
		
//--------------------------------------------------------------------------------------------
// STAGE in_betFlight (eyes have left fixation window but have not entered either bet window)		
	else if (stage == in_betFlight)
		{
		if (In_HighBetWin)													// If the eyes get into the target window...
			{
			aquire_bet_time = time();									// ...record the time...
			Event_fifo[Set_event] = Decide_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = on_HighBet;											// ...and advance to the next stage of the trial.
			Event_fifo[Set_event] = HighBet_;					// ...queue strobe for Neuro Explorer
			Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.					
			}
		else if (In_LowBetWin)											// If the eyes get into the distractor window...
			{
			aquire_bet_time = time();									// ...record the time...
			Event_fifo[Set_event] = Decide_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = on_LowBet;										// ...and advance to the next stage of the trial.
			Event_fifo[Set_event] = LowBet_;					// ...queue strobe for Neuro Explorer
			Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.					
			}
		else if (time() > saccade_time + saccDurationMax)				// But, if the eyes are out of the target window and time runs out...
			{
			trialOutcome = betAbort;   									// TRIAL OUTCOME ERROR (innacurrate saccade)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_highBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_lowBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (inaccurate saccade)\n");						// ...tell the user whats up...
			spawn SVR_BELL();
			trl_running = 0; 											// ...and terminate the trial.
			}
		}
	
	
	
//--------------------------------------------------------------------------------------------
// STAGE on_HighBet (eyes have entered the target window.  will they remain there for duration?)	
	else if (stage == on_HighBet)
		{
		if (!In_HighBetWin)												// If the eyes left the target or distractor window...
			{			
			trialOutcome = brokeBet;									// TRIAL OUTCOME ERROR (broke target fixation)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_highBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_lowBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (broke bet target fixation)\n");					// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}		
		else if (In_HighBetWin  											// But if the eyes are still in the target window...
			&&  time() > aquire_targ_time + targHoldtime)				// ...and the target hold time is up...
			{
			betOutcome = highBet;								//TRIAL OUTCOME CORRECT (correct go trial)
			printf("High Bet (saccade)\n");							// ...tell the user whats up...
			dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
			oSetAttribute(object_highBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_lowBet, aINVISIBLE); 					// ...remove target from animated graph...
			stage = need_proFix;											// ...and terminate the trial.
			dsendf("vp %d\n",fixation_pd);											// flip the pg to the fixation stim with pd marker
			fix_spot_time = time();  													// record the time
			Event_fifo[Set_event] = FixSpotOn_;										// queue strobe
			Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
			dsendf("XM RFRSH:\n"); 													// wait for one retrace
			dsendf("vp %d\n",fixation);												// flip the pg to the fixation stim without pd marker
			}			
		}
		

// STAGE on_LowBet (eyes have entered the distractor window.  will they remain there for duration?)	
	else if (stage == on_LowBet)
		{
		if (!In_LowBetWin)												// If the eyes left the distractor or distractor window...
			{			
			trialOutcome = brokeBet;									// TRIAL OUTCOME ERROR (broke target fixation)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_highBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_lowBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (broke bet target fixation)\n");				// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}		
		else if (In_LowBetWin  											// But if the eyes are still in the target window...
			&&  time() > aquire_dist_time + targHoldtime)				// ...and the target hold time is up...
			{
			betOutcome = lowBet;								//TRIAL OUTCOME CORRECT (correct go trial)
			printf("Low Bet (saccade)\n");	//pgm						// ...tell the user whats up...
			dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
			oSetAttribute(object_highBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_lowBet, aINVISIBLE); 					// ...remove target from animated graph...
			stage = need_proFix;											// ...and terminate the trial.
			dsendf("vp %d\n",fixation_pd);											// flip the pg to the fixation stim with pd marker
			fix_spot_time = time();  													// record the time
			Event_fifo[Set_event] = FixSpotOn_;										// queue strobe
			Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
			dsendf("XM RFRSH:\n"); 													// wait for one retrace
			dsendf("vp %d\n",fixation);												// flip the pg to the fixation stim without pd marker
			}			
		}
	

//--------------------------------------------------------------------------------------------
// STAGE need_proFix (the fixation point is on, but the subject hasn't looked at it)
	if (stage == need_proFix)
		{		
		if (In_FixWin)													// If the eyes have entered the fixation window (before time, see below)...
			{
			aquire_fix_time = time();									// ...function call to time to note current time and...
			Event_fifo[Set_event] = DecFixate_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = proFixating;											// ...advance to the next stage.
			}
		else if (time() > fix_spot_time + allowFixTime)				// But if time runs out...
			{
			trialOutcome = noFix;    									// TRIAL OUTCOME ABORT (no fixation)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen,...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Aborted (no fixation)\n");							// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}			
		}
		
		

//--------------------------------------------------------------------------------------------
// STAGE proFixating (the subject is looking at the fixation point waiting for target onset)		
	else if (stage == proFixating)
		{
		if (!In_FixWin)													// If the eyes stray out of the fixation window...
			{
			trialOutcome = brokeFix;									// TRIAL OUTCOME ABORT (broke fixation)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}
		else if (In_FixWin && time() > aquire_fix_time + preTargHoldtime)	// But if the eyes are still in the window at end of holdtime...
			{
			dsendf("vp %d\n",fix_mask_pd);							// ...flip the pg to the signal with the pd marker...
			mask_time = targ_time + 
				(round(soa * (1000.0 / screenRefreshRate))); 		// ...record TEMPO time of presentation...
			dsendf("XM RFRSH:\n"); 									// ...wait 1 vertical retrace...
			dsendf("vp %d\n",fix_mask);								// ...and flip the pg to the signal without pd marker.
	

			oSetAttribute(object_targ, aVISIBLE); 						// ...show target in animated graph...
													
			stage = proMaskOn;											// Advance to the next trial stage.				
			}
		}
		
		

//--------------------------------------------------------------------------------------------
// STAGE mask_on (the subject is looking at the fixation point waiting for cue to make saccade)		
	else if (stage == proMaskOn)
		{		
		if (!In_FixWin)													// If the eyes leave the fixation window...
			{															// ...we have a saccade, so...
			saccade_time = time();										// ...record the time...
			Event_fifo[Set_event] = Saccade_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			// dsendf("vp %d\n",target);									// Flip the pg to the blank screen...
			printf("           rt = %d\n",saccade_time - fix_off_time);	// ...tell the user whats up...
			stage = in_flight;											// ...and advance to the next stage.
			}
		else if (In_FixWin &&  											// But if no saccade occurs...
			time() > fix_off_time + saccTimeMax)					// ...and time for a saccade runs out...
			{
			trialOutcome = noSacc;           							// TRIAL OUTCOME ERROR
			lastOutcome = noChange;								// Don't change SSD
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (no saccade)\n");								// ...tell the user whats up...
			spawn SVR_BELL();
			trl_running = 0;											// ...and terminate the trial.
			}				
		}
		
		
		
//--------------------------------------------------------------------------------------------
// STAGE in_flight (eyes have left fixation window but have not entered target window)		
	else if (stage == in_flight)
		{
		if (In_TargWin)													// If the eyes get into the target window...
			{
			aquire_targ_time = time();									// ...record the time...
			Event_fifo[Set_event] = Decide_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = on_target;											// ...and advance to the next stage of the trial.
			Event_fifo[Set_event] = Correct_;					// ...queue strobe for Neuro Explorer
			Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.					
			}
		else if (In_DistWin)											// If the eyes get into the distractor window...
			{
			aquire_dist_time = time();									// ...record the time...
			Event_fifo[Set_event] = Decide_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = on_distractor;										// ...and advance to the next stage of the trial.
			Event_fifo[Set_event] = Distract_;					// ...queue strobe for Neuro Explorer
			Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.					
			}
		else if (time() > saccade_time + saccDurationMax)				// But, if the eyes are out of the target window and time runs out...
			{
			trialOutcome = saccOut;   									// TRIAL OUTCOME ERROR (innacurrate saccade)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (inaccurate saccade)\n");						// ...tell the user whats up...
			spawn SVR_BELL();
			trl_running = 0; 											// ...and terminate the trial.
			}
		}
	
	
	
//--------------------------------------------------------------------------------------------
// STAGE on_target (eyes have entered the target window.  will they remain there for duration?)	
	else if (stage == on_target)
		{
		if (!In_TargWin)												// If the eyes left the target or distractor window...
			{			
			trialOutcome = brokeTarg;									// TRIAL OUTCOME ERROR (broke target fixation)
			lastOutcome = noChange;								// Don't change SSD
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (broke target fixation)\n");					// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}		
		else if (In_TargWin  											// But if the eyes are still in the target window...
			&&  time() > aquire_targ_time + targHoldtime)				// ...and the target hold time is up...
			{
			maskOutcome = saccTarg;								//TRIAL OUTCOME CORRECT (correct go trial)
			lastOutcome = success;
			printf("Correct (saccade)\n");							// ...tell the user whats up...
			dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			trl_running = 0;											// ...and terminate the trial.
			if (betOutcome == highBet)
				{
				trialOutcome = targHighBet;
				}
			else if (betOutcome == lowBet)
				{
				trialOutcome = targLowBet;
				}
			}			
		}
		

// STAGE on_distractor (eyes have entered the distractor window.  will they remain there for duration?)	
	else if (stage == on_distractor)
		{
		if (!In_DistWin)												// If the eyes left the distractor or distractor window...
			{			
			trialOutcome = brokeDist;									// TRIAL OUTCOME ERROR (broke target fixation)
			lastOutcome = noChange;								// Don't change SSD
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (broke distractor fixation)\n");				// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}		
		else if (In_DistWin  											// But if the eyes are still in the target window...
			&&  time() > aquire_dist_time + targHoldtime)				// ...and the target hold time is up...
			{
			maskOutcome = saccDist;								//TRIAL OUTCOME CORRECT (correct go trial)
			lastOutcome = failure;								// Don't change SSD
			printf("Error to distractor (saccade)\n");	//pgm						// ...tell the user whats up...
			dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			trl_running = 0;											// ...and terminate the trial.
			if (betOutcome == highBet)
				{
				trialOutcome = distHighBet;
				}
			else if (betOutcome == lowBet)
				{
				trialOutcome = distLowBet;
				}
			}			
		}



		
		
		
		
		

		
		nexttick;
	}
}//-------------------------------------------------------------------------
// Process QUE_TTL() runs in the background and sends up to 5 event codes
// per process cycle to the remote system, drawing them from the Event_fifo[] buffer.
// This process should be the last process in your protocol so that any
// preceeding process that adds an event code to the Event_fifo[] will do so
// before QUE_TTL() runs.
// NOTE: Two problems may arise when sending TTLs.  First, TTLs may be sent 
// too quickly for plexon to keep up and plexon may drop them.  This won't
// result in any errors you can see.  Second, too much time may be allotted
// to individual TTLs causing more time to be allotted to TTLs than is possible
// on a process cycle.  This will result in buffer overflow messages in TEMPO.
// The balance between too little time and too much time is struck by 1) the 
// number of micro seconds allotted to each TTL, 2) the number of TTLs sent
// per process cycle, and 3) the amount of other stuff you allow to happen while
// TTLs are being sent.  In rig 028 I have found that 100 microseconds between TTLs
// and 5 TTLs per process cycle results in zero drops and zero overflows AS LONG AS
// I HAVE APPROPRIATELY PLACED nextticks IN AREAS OF HEAVY TTL VOLUME.  That way
// other processes (e.g. rdx communication) don't use up all of the buffer while I am
// trying to strobe.  All of this may depend on plexon settings that I am 
// currently unaware of, and tests should be performed in each rig to find 
// appropriate parameters.
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011

#include C:/TEMPO/ProcLib/SEND_TTL.pro

declare QUE_TTL();

process QUE_TTL()
		{
		declare int send_event;									// current event to send (if == to set_event we are...
																// ...caught up meaning no events are in the Event_fifo.
		declare int n_evs_sent;									// # of TTLs which have been sent this process cycle		
					
		while (1)  												// run in the background                         
			{			
			n_evs_sent = 0;			
			while (n_evs_sent < 5 								// While we have not sent 5 events on this process cycle...
					&& send_event != Set_event)					// ...and we are not caught up on the Event_fifo... (GLOBAL ALERT)
				{	
				spawnwait SEND_TTL(Event_fifo[send_event]);		// ...send the next event to plexon and...
				send_event = (send_event + 1) % Event_fifo_N;	// ...advance to the next event in the Event_fifo and...
				n_evs_sent = n_evs_sent + 1;					// ... count that another code was sent.
				}	
					
			nexttick;                       					// wait one process cycle
																// Note that we may wait on process cycle because we are..
																// ...just waiting on data to be added to the Event_fifo, or...
																// ...we may wait because we have too many events for a...
																// ...single cycle.
			}
	}//--------------------------------------------------------------------------------------------
// Run a reverse masking retrospective monitoring trial based on the variables calculated by SETTRIAL.pro and those 
// given by the user.
//

declare hide int lastOutcome = 1;	// Global output used to staircase SSD
declare int nSuccess;

declare RETTRIAL();			// 

process RETTRIAL()        		// 
{


// Number the trial stages to make them easier to read below
declare hide int 	need_fix  		= 1;
declare hide int 	fixating  		= 2;
declare hide int 	mask_on   		= 3;
declare hide int 	fix_off  		= 4;
declare hide int 	in_flight 		= 5;
declare hide int 	on_target 		= 6;	
declare hide int 	on_distractor 	= 7;
declare hide int 	need_betFix  	= 8;
declare hide int 	betFixating  	= 9;
declare hide int 	bet_on   		= 10;
declare hide int 	in_betFlight 	= 11;
declare hide int 	on_Highbet 		= 12;	
declare hide int 	on_Lowbet 		= 13;	
declare hide int 	stage;

// number the pgs that need to be drawn: need to be same as MSK_PGS and BET_PGS
// from MSK_PGS
declare hide int   	blank       		= 0;
declare hide int	fixation_pd			= 1;
declare hide int	fixation    		= 2;
declare hide int	fixation_target		= 3;
declare hide int	fix_mask_pd			= 4;
declare hide int	fix_mask    		= 5;
declare hide int	mask_pd   			= 6;
declare hide int	mask      			= 7;
// from BET_PGS
declare hide int	betFix_pd			= 2;
declare hide int	betFix    			= 3;
declare hide int	fix_bet_pd			= 4;
declare hide int	fix_bet				= 5;

											
// Timing variables which will be used to time task
declare hide float 	fix_spot_time; 					
declare hide float  targ_time; 					
declare hide float  mask_time; 					
declare hide float  betTarg_time; 					
declare hide float  fix_off_time; 					
declare hide float  saccade_time;
declare hide float 	aquire_fix_time;
declare hide float	aquire_targ_time;	
declare hide float	aquire_dist_time;	
declare hide float	aquire_bet_time;	



opposite = ((screenHeight/2)-pdBottom);														// Figure out angle and eccentricity of photodiode marker in pixels
adjacent = ((screenWidth/2)-pdLeft);                                                         // NOTE: I am assuming your pd is in the lower left quadrant of your screen
pdAmp = sqrt((opposite * opposite) + (adjacent * adjacent));
pdAngle = rad2deg(atan (opposite / adjacent));
pdAngle = pdAngle + 180; 																	//change this for different quadrent or write some code for flexibility


// Have to be reset on every iteration since 
// variable declaration only occurs at load time
trl_running 		= 1;
stage 				= need_fix;

// Tell the user what's up
printf(" \n");
printf(" ********   RETRO TRIAL   ********\n");
printf("# %d",nTrial);
printf(" (%d complete)\n",nTrialComplete);
printf("pre-target holdtime = %d\n",preTargHoldtime);
printf("post-target holdtime = %d\n",postTargHoldtime);
printf("               soa = %d\n",round(soa * (1000.0/screenRefreshRate)));


																		// HERE IS WHERE THE FUN BEGINS
Event_fifo[Set_event] = TrialStart_;									// queue TrialStart_ strobe
Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
dsendf("vp %d\n",fixation_pd);											// flip the pg to the fixation stim with pd marker
fix_spot_time = time();  													// record the time
Event_fifo[Set_event] = FixSpotOn_;										// queue strobe
Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
dsendf("XM RFRSH:\n"); 													// wait for one retrace
dsendf("vp %d\n",fixation);												// flip the pg to the fixation stim without pd marker
oSetAttribute(object_fix, aVISIBLE); 									// turn on the fixation point in animated graph


while (trl_running)														// trials ending will set trl_running = 0
	{	
	
//--------------------------------------------------------------------------------------------
// STAGE need_fix (the fixation point is on, but the subject hasn't looked at it)
	if (stage == need_fix)
		{		
		if (In_FixWin)													// If the eyes have entered the fixation window (before time, see below)...
			{
			aquire_fix_time = time();									// ...function call to time to note current time and...
			trialStartTime = aquire_fix_time;							// Global output for timing iti
			Event_fifo[Set_event] = DecFixate_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = fixating;											// ...advance to the next stage.
			}
		else if (time() > fix_spot_time + allowFixTime)				// But if time runs out...
			{
			trialOutcome = noFix;    									// TRIAL OUTCOME ABORT (no fixation)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen,...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Aborted (no fixation)\n");							// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}			
		}
		
		

//--------------------------------------------------------------------------------------------
// STAGE fixating (the subject is looking at the fixation point waiting for target onset)		
	else if (stage == fixating)
		{
		if (!In_FixWin && time() > aquire_fix_time + 200)													// If the eyes stray out of the fixation window...
			{
			trialOutcome = brokeFix;									// TRIAL OUTCOME ABORT (broke fixation)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}
		else if (In_FixWin && time() > aquire_fix_time + preTargHoldtime)	// But if the eyes are still in the window at end of holdtime...
			{
			targ_time = time(); 										// ...record the time...
			dsendf("vp %d\n",fixation_target);						// ...flip the pg to the target with pd marker...	
			dsendf("vw %d\n",soa);							// Wait so many vertical retraces 
			dsendf("vp %d\n",fix_mask_pd);							// ...flip the pg to the signal with the pd marker...
			mask_time = targ_time + 
				(round(soa * (1000.0 / screenRefreshRate))); 		// ...record TEMPO time of presentation...
			dsendf("XM RFRSH:\n"); 									// ...wait 1 vertical retrace...
			dsendf("vp %d\n",fix_mask);								// ...and flip the pg to the signal without pd marker.
	

			oSetAttribute(object_targ, aVISIBLE); 						// ...show target in animated graph...
													
			stage = mask_on;											// Advance to the next trial stage.				
			}
		}
		
		

//--------------------------------------------------------------------------------------------
// STAGE mask_on (the subject is looking at the fixation point waiting for cue to make saccade)		
	else if (stage == mask_on)
		{
		if (!In_FixWin)													// If the eyes stray out of the fixation window...
			{
			trialOutcome = brokeFix;									// TRIAL OUTCOME ERROR (broke fixation)
			lastOutcome = noChange;								// Don't change SSD
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			spawn SVR_BELL();
			printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}
		else if (In_FixWin && time() > mask_time + postTargHoldtime)	// But if the eyes are still in the window at end of holdtime...
			{
			dsendf("vp %d\n",mask_pd);								// ...flip the pg to the choice stim pd marker...	
			fix_off_time = time(); 										// ...record the time...
			dsendf("XM RFRSH:\n"); 										// ...wait one vetical retrace...
			dsendf("vp %d\n",mask);									// ...flip the pg to the choice stim without pd marker.

			oSetAttribute(object_fix, aINVISIBLE); 					// ...remove fixation point from animated graph.
				
			stage = fix_off;											// Advance to the next trial stage.			
			
			//********************************************************************************		
			//********************************************************************************		
			// LOAD BET-PGS HERE TO PREPARE FOR THE BET STAGE OF THIS TRIAL
				spawnwait BET_PGS();
			//********************************************************************************		
			//********************************************************************************		
			}
		}
		




//--------------------------------------------------------------------------------------------
// STAGE fix_off (the fixation spot has been extinguished but the masks are still visible)		
	else if (stage == fix_off)
		{		
		if (!In_FixWin)													// If the eyes leave the fixation window...
			{															// ...we have a saccade, so...
			saccade_time = time();										// ...record the time...
			Event_fifo[Set_event] = Saccade_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			// dsendf("vp %d\n",target);									// Flip the pg to the blank screen...
			printf("           rt = %d\n",saccade_time - fix_off_time);	// ...tell the user whats up...
			stage = in_flight;											// ...and advance to the next stage.
			}
		else if (In_FixWin &&  											// But if no saccade occurs...
			time() > fix_off_time + saccTimeMax)					// ...and time for a saccade runs out...
			{
			trialOutcome = noSacc;           							// TRIAL OUTCOME ERROR
			lastOutcome = noChange;								// Don't change SSD
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (no saccade)\n");								// ...tell the user whats up...
			spawn SVR_BELL();
			trl_running = 0;											// ...and terminate the trial.
			}				
		}
		
		
		
//--------------------------------------------------------------------------------------------
// STAGE in_flight (eyes have left fixation window but have not entered target window)		
	else if (stage == in_flight)
		{
		if (In_TargWin)													// If the eyes get into the target window...
			{
			aquire_targ_time = time();									// ...record the time...
			Event_fifo[Set_event] = Decide_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = on_target;											// ...and advance to the next stage of the trial.
			Event_fifo[Set_event] = Correct_;					// ...queue strobe for Neuro Explorer
			Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.					
			}
		else if (In_DistWin)											// If the eyes get into the distractor window...
			{
			aquire_dist_time = time();									// ...record the time...
			Event_fifo[Set_event] = Decide_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = on_distractor;										// ...and advance to the next stage of the trial.
			Event_fifo[Set_event] = Distract_;					// ...queue strobe for Neuro Explorer
			Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.					
			}
		else if (time() > saccade_time + saccDurationMax)				// But, if the eyes are out of the target window and time runs out...
			{
			trialOutcome = saccOut;   									// TRIAL OUTCOME ERROR (innacurrate saccade)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (inaccurate saccade)\n");						// ...tell the user whats up...
			spawn SVR_BELL();
			trl_running = 0; 											// ...and terminate the trial.
			}
		}
	
	
	
//--------------------------------------------------------------------------------------------
// STAGE on_target (eyes have entered the target window.  will they remain there for duration?)	
	else if (stage == on_target)
		{
		if (!In_TargWin)												// If the eyes left the target or distractor window...
			{			
			trialOutcome = brokeTarg;									// TRIAL OUTCOME ERROR (broke target fixation)
			lastOutcome = noChange;								// Don't change SSD
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (broke target fixation)\n");					// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}		
		else if (In_TargWin  											// But if the eyes are still in the target window...
			&&  time() > aquire_targ_time + targHoldtime)				// ...and the target hold time is up...
			{
			maskOutcome = saccTarg;								//TRIAL OUTCOME CORRECT (correct go trial)
			lastOutcome = success;
			printf("Correct (saccade)\n");							// ...tell the user whats up...
			dsendf("vp %d\n",betFix_pd);											// flip the pg to the fixation stim with pd marker
			fix_spot_time = time();  													// record the time
			Event_fifo[Set_event] = FixSpotOn_;										// queue strobe
			Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
			dsendf("XM RFRSH:\n"); 													// wait for one retrace
			dsendf("vp %d\n",betFix);												// flip the pg to the fixation stim without pd marker
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			stage = need_betFix;											// 
			}			
		}
		

// STAGE on_distractor (eyes have entered the distractor window.  will they remain there for duration?)	
	else if (stage == on_distractor)
		{
		if (!In_DistWin)												// If the eyes left the distractor or distractor window...
			{			
			trialOutcome = brokeDist;									// TRIAL OUTCOME ERROR (broke target fixation)
			lastOutcome = noChange;								// Don't change SSD
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (broke distractor fixation)\n");				// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}		
		else if (In_DistWin  											// But if the eyes are still in the target window...
			&&  time() > aquire_dist_time + targHoldtime)				// ...and the target hold time is up...
			{
			maskOutcome = saccDist;								//TRIAL OUTCOME CORRECT (correct go trial)
			lastOutcome = failure;								// Don't change SSD
			printf("Error to distractor (saccade)\n");	//pgm						// ...tell the user whats up...
			dsendf("vp %d\n",betFix_pd);											// flip the pg to the fixation stim with pd marker
			fix_spot_time = time();  													// record the time
			Event_fifo[Set_event] = FixSpotOn_;										// queue strobe
			Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
			dsendf("XM RFRSH:\n"); 													// wait for one retrace
			dsendf("vp %d\n",betFix);												// flip the pg to the fixation stim without pd marker
			oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
			stage = need_betFix;											// 
			}			
		}
		
//--------------------------------------------------------------------------------------------
// STAGE need_betfix (the fixation point is on, but the subject hasn't looked at it)
	else if (stage == need_betFix)
		{
		if (In_FixWin)													// If the eyes have entered the fixation window (before time, see below)...
			{
			aquire_fix_time = time();									// ...function call to time to note current time and...
			Event_fifo[Set_event] = BetFixate_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = betFixating;											// ...advance to the next stage.
			}
		else if (time() > fix_spot_time + allowFixTime)				// But if time runs out...
			{
			trialOutcome = noFix;    									// TRIAL OUTCOME ABORT (no fixation)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen,...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Aborted (no fixation)\n");							// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}			
		}
		
		

//--------------------------------------------------------------------------------------------
// STAGE fixating (the subject is looking at the fixation point waiting for target onset)		
	else if (stage == betFixating)
		{
		if (!In_FixWin)													// If the eyes stray out of the fixation window...
			{
			trialOutcome = brokeFix;									// TRIAL OUTCOME ABORT (broke fixation)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}
		else if (In_FixWin && time() > aquire_fix_time + preTargHoldtime)	// But if the eyes are still in the window at end of holdtime...
			{
			dsendf("vp %d\n",fix_bet_pd);						// ...flip the pg to the target with pd marker...	
			betTarg_time = time(); 										// ...record the time...
			dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
			dsendf("vp %d\n",fix_bet);						// ...flip the pg to the target with pd marker...	
	

			oSetAttribute(object_highBet, aVISIBLE); 						// ...show target in animated graph...
			oSetAttribute(object_lowBet, aVISIBLE); 						// ...show target in animated graph...
													
			stage = bet_on;											// Advance to the next trial stage.				
			}
		}
		
		

	

//--------------------------------------------------------------------------------------------
// STAGE bet_on (the fixation spot has been extinguished but the masks are still visible)		
	else if (stage == bet_on)
		{		
		if (!In_FixWin)													// If the eyes leave the fixation window...
			{															// ...we have a saccade, so...
			saccade_time = time();										// ...record the time...
			Event_fifo[Set_event] = Saccade_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			// dsendf("vp %d\n",target);									// Flip the pg to the blank screen...
			printf("           rt = %d\n",saccade_time - betTarg_time);	// ...tell the user whats up...
			stage = in_betFlight;											// ...and advance to the next stage.
			}
		else if (In_FixWin &&  											// But if no saccade occurs...
			time() > betTarg_time + saccTimeMax)					// ...and time for a saccade runs out...
			{
			trialOutcome = betAbort;           							// TRIAL OUTCOME ERROR
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_highBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_lowBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (no saccade)\n");								// ...tell the user whats up...
			spawn SVR_BELL();
			trl_running = 0;											// ...and terminate the trial.
			}				
		}
		
		
		
//--------------------------------------------------------------------------------------------
// STAGE in_betFlight (eyes have left fixation window but have not entered either bet window)		
	else if (stage == in_betFlight)
		{
		if (In_HighBetWin)													// If the eyes get into the target window...
			{
			aquire_bet_time = time();									// ...record the time...
			Event_fifo[Set_event] = Decide_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = on_HighBet;											// ...and advance to the next stage of the trial.
			Event_fifo[Set_event] = HighBet_;					// ...queue strobe for Neuro Explorer
			Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.					
			}
		else if (In_LowBetWin)											// If the eyes get into the distractor window...
			{
			aquire_bet_time = time();									// ...record the time...
			Event_fifo[Set_event] = Decide_;							// ...queue strobe...
			Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
			stage = on_LowBet;										// ...and advance to the next stage of the trial.
			Event_fifo[Set_event] = LowBet_;					// ...queue strobe for Neuro Explorer
			Set_event = (Set_event + 1) % Event_fifo_N;				// ...incriment event queue.					
			}
		else if (time() > saccade_time + saccDurationMax)				// But, if the eyes are out of the target window and time runs out...
			{
			trialOutcome = betAbort;   									// TRIAL OUTCOME ERROR (innacurrate saccade)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_highBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_lowBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (inaccurate saccade)\n");						// ...tell the user whats up...
			spawn SVR_BELL();
			trl_running = 0; 											// ...and terminate the trial.
			}
		}
	
	
	
//--------------------------------------------------------------------------------------------
// STAGE on_HighBet (eyes have entered the target window.  will they remain there for duration?)	
	else if (stage == on_HighBet)
		{
		if (!In_HighBetWin)												// If the eyes left the target or distractor window...
			{			
			trialOutcome = brokeBet;									// TRIAL OUTCOME ERROR (broke target fixation)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_highBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_lowBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (broke bet target fixation)\n");					// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}		
		else if (In_HighBetWin  											// But if the eyes are still in the target window...
			&&  time() > aquire_bet_time + targHoldtime)				// ...and the target hold time is up...
			{
			betOutcome = highBet;								//TRIAL OUTCOME CORRECT (correct go trial)
			printf("High Bet (saccade)\n");							// ...tell the user whats up...
			dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
			oSetAttribute(object_highBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_lowBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			if (maskOutcome == saccTarg)
				{
				trialOutcome = targHighBet;
				}
			else if (maskOutcome == saccDist)
				{
				trialOutcome = distHighBet;
				}
			trl_running = 0;											// ...and terminate the trial.
			}			
		}
		

// STAGE on_LowBet (eyes have entered the distractor window.  will they remain there for duration?)	
	else if (stage == on_LowBet)
		{
		if (!In_LowBetWin)												// If the eyes left the distractor or distractor window...
			{			
			trialOutcome = brokeBet;									// TRIAL OUTCOME ERROR (broke target fixation)
			dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
			oSetAttribute(object_highBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_lowBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			printf("Error (broke bet target fixation)\n");				// ...tell the user whats up...
			trl_running = 0;											// ...and terminate the trial.
			}		
		else if (In_LowBetWin  											// But if the eyes are still in the target window...
			&&  time() > aquire_bet_time + targHoldtime)				// ...and the target hold time is up...
			{
			betOutcome = lowBet;								//TRIAL OUTCOME CORRECT (correct go trial)
			printf("Low Bet (saccade)\n");	//pgm						// ...tell the user whats up...
			dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
			oSetAttribute(object_highBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_lowBet, aINVISIBLE); 					// ...remove target from animated graph...
			oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
			trl_running = 0;											// ...and terminate the trial.
			if (maskOutcome == saccTarg)
				{
				trialOutcome = targLowBet;
				}
			else if (maskOutcome == saccDist)
				{
				trialOutcome = distLowBet;
				}
			}			
		}
	
		
		nexttick;
	}
}//-------------------------------------------------------------------------------------------------------
// This Code combines END_TRL, SUCCESS, FAILURE, and ABORT, to allow a higher degree of freedom for 
// rewards. That is, one may want to give variable amounts of reward for various outcomes.


#include C:/TEMPO/ProcLib/pgm/JUICE.pro


declare REWARDS();

process REWARDS()
{	

declare					  now;			
declare hide int trl_end_time, tone_time, tone_type, noFix_punish, abort_punish;	
declare hide float play_the_odds;					// see if subject will randomly be rewarded or punished on this trial and by how much
declare float rewardRandomIncrease, rewardMaxIncreasePercent;
declare int rewards_start_time;


//	play_the_odds = random(10001)/100.0;				// choose medium small or large outcome
//	if (play_the_odds <= SmlR_weight)					// the number line is divided by the weights the user chooses
//		{
//		rewardDuration = baseRewardDuration / 2;			//GLOBAL for use in INFOS.pro
//		toneSuccess = Success_Tone_smlR;				//GLOBAL for use in INFOS.pro
//		}
//	else if(play_the_odds > SmlR_weight &&
//			play_the_odds < SmlR_weight + MedR_weight)
//		{
//		rewardDuration = baseRewardDuration;				//GLOBAL for use in INFOS.pro
//		toneSuccess = Success_Tone_medR;               //GLOBAL for use in INFOS.pro
//		}
//	else
//		{
//		rewardDuration = baseRewardDuration * 2;			//GLOBAL for use in INFOS.pro
//		toneSuccess = Success_Tone_bigR;               //GLOBAL for use in INFOS.pro
//		}
//	
//	
//	if (play_the_odds <= SmlP_weight)					// choose medium small or large outcome	
//		{                                               // the number line is divided by the weights the user chooses
//		punishDuration = basePunishDuration / 2;				//GLOBAL for use in INFOS.pro
//		toneFailure = Failure_Tone_smlP;               //GLOBAL for use in INFOS.pro
//		}
//	else if(play_the_odds > SmlP_weight &&
//			play_the_odds < SmlP_weight + MedP_weight)
//		{
//		punishDuration = basePunishDuration;					//GLOBAL for use in INFOS.pro
//		toneFailure = Failure_Tone_medP;               //GLOBAL for use in INFOS.pro
//		}
//	else
//		{
//		punishDuration = basePunishDuration * 2;				//GLOBAL for use in INFOS.pro
//		toneFailure = Failure_Tone_bigP;               //GLOBAL for use in INFOS.pro
//		}
//	
//	play_the_odds = random(10001)/100.0;				// probability of an outcome reversal

rewards_start_time = time();
rewardMaxIncreasePercent = 70;
rewardRandomIncrease = round(baseRewardDuration * random(rewardMaxIncreasePercent) / 100);
rewardDuration = baseRewardDuration + rewardRandomIncrease;
punishDuration = 0;




// 	SOME REWARDS/PUNISHMENTS ARE GENERAL TO ALL OR MULTIPLE TASKS: DO THOSE FIRST, THEN SPECIFIC TASKS BELOW
//----------------------------------------------------------------------------------------------------
//   Never attained fixation trial
if (	trialOutcome == noFix) 						// If the subject failed to initiate the trial properly...
	{
	punishDuration = round(basePunishDuration * 3);
	rewardDuration = 0;
	}

	
if (state == stateVIS ||
	state == stateMEM ||
	state == stateDEL ||
	state == stateAMP ||
	state == stateCCM ||
	state == stateCMD ||
	state == stateVWM)
	{
	//----------------------------------------------------------------------------------------------------
	//   Aborted trial-- broke central fixation or moved
	if (	trialOutcome == brokeFix 			||			// If the subject failed to initiate the trial properly...
			trialOutcome == noSacc			||
			trialOutcome == saccOut			||
			trialOutcome == saccEarly			||
			trialOutcome == brokeTarg			||
			trialOutcome == bodyMove)
		{
		Event_fifo[Set_event] = Abort_;				// ...queue strobe...
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue...
		punishDuration = round(basePunishDuration / 1.5);
		rewardDuration = 0;
		}


	//----------------------------------------------------------------------------------------------------
	//    Correct trial

	else if (	trialOutcome == saccTarg	||
				play_the_odds < Bonus_weight)			// ...or if the trial is chosen as a surprise rewarded trial...
		{
		
		spawn TONE(toneChoiceSuccess,toneDuration);				// give the secondary reinforcer tone
		tone_time = time();									// record the time

		Event_fifo[Set_event] = Tone_;						// ...queue strobe...
		Set_event = (Set_event + 1) % Event_fifo_N;			// ...incriment event queue...

		Event_fifo[Set_event] = Reward_tone;				// ...queue strobe for Neuro Explorer...
		Set_event = (Set_event + 1) % Event_fifo_N;			// ...incriment event queue...



		nTrialComplete = nTrialComplete + 1;
		nTrialArray[targIndex] = nTrialArray[targIndex] + 1;
		nTrialRemain = nTrialRemain - 1;
		}
	}









// 		SIMPLE COUNTERMANDING
//-----------------------------------------------------------------------------------------------------
if (state == stateCMD)
	{
	if (trialOutcome == brokeFix)
		{
		punishDuration = basePunishDuration * 2;
		rewardDuration = 0;
		}
	//    Correct trial
	if (	trialOutcome == goTarg 	||			// If the subject got the trial right...
				trialOutcome == nogoCorrect)			// ...or if the trial is chosen as a surprise rewarded trial...
		{
		if (trialOutcome == goTarg)
			spawn TONE(toneChoiceSuccess,toneDuration);				// give the secondary reinforcer tone
		else if (trialOutcome == nogoCorrect)
			spawn TONE(toneStopSuccess,toneDuration);				// give the secondary reinforcer tone
		
		
		tone_time = time();									// record the time
	
		Event_fifo[Set_event] = Tone_;						// ...queue strobe...
		Set_event = (Set_event + 1) % Event_fifo_N;			// ...incriment event queue...
	
		Event_fifo[Set_event] = Reward_tone;				// ...queue strobe for Neuro Explorer...
		Set_event = (Set_event + 1) % Event_fifo_N;			// ...incriment event queue...
	
	
	
		nTrialComplete = nTrialComplete + 1;
		nTrialArray[targIndex] = nTrialArray[targIndex] + 1;
		nTrialRemain = nTrialRemain - 1;
		}
		
	//----------------------------------------------------------------------------------------------------
	//    Error trial
	else if (	trialOutcome == nogoTarg 	||			// If the subject got the trial ...
				trialOutcome == brokeTarg)		// 
		{
		if (trialOutcome == nogoTarg)
			spawn TONE(toneStopFailure,toneDuration);				// give the secondary reinforcer tone
		else if (trialOutcome == brokeTarg)
			spawn TONE(toneAbort,toneDuration);				// give the secondary reinforcer tone
		
		tone_time = time();											// record the time
		punishDuration = basePunishDuration;
		rewardDuration = 0;
	
		Event_fifo[Set_event] = Tone_;								// ...queue strobe...
		Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
	
		Event_fifo[Set_event] = Error_tone;							// ...queue strobe for Neuro Explorer...
		Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
		}
	else if (	trialOutcome	== goIncorrect)						// 
		{
		printf("goIncorrect \n");
		spawn TONE(toneAbort,toneDuration);						// present negative tone
		tone_time = time();											// record the time
		punishDuration = basePunishDuration * 1.5;	
		rewardDuration = 0;
	
		Event_fifo[Set_event] = Tone_;								// ...queue strobe...
		Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
	
		Event_fifo[Set_event] = Error_tone;							// ...queue strobe for Neuro Explorer...
		Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
		}
		
	// Extra reward for a given target (on top of rewardRandomIncrease)
	if (trialOutcome == goTarg	&&
		targIndex == 0)							// if correct to the right target
		{
		rewardDuration = round(rewardDuration * (1 + targ1ExtraPct / 100));
		}
	else if (trialOutcome == goTarg	&&
		targIndex == 1)							// if correct to the left target
		{
		rewardDuration = round(rewardDuration * (1 + targ2ExtraPct / 100));
		}
	if (trialType == nogoTarg)					// noncanceled stop is  still a "complete" trial
		{
		nTrialComplete = nTrialComplete + 1;
		}

	}




// 		CHOICE COUNTERMANDING
//-----------------------------------------------------------------------------------------------------
if (state == stateCCM)
	{
	if (trialOutcome == brokeFix)
		{
		punishDuration = basePunishDuration * 2;
		rewardDuration = 0;
		}
	//    Correct Go Trial
	if (	trialOutcome == goTarg )			// ...or if the trial is chosen as a surprise rewarded trial...
		{
		spawn TONE(toneChoiceSuccess,toneDuration);				// give the secondary reinforcer tone
		
		tone_time = time();									// record the time
	
		Event_fifo[Set_event] = Tone_;						// ...queue strobe...
		Set_event = (Set_event + 1) % Event_fifo_N;			// ...incriment event queue...
	
		Event_fifo[Set_event] = Reward_tone;				// ...queue strobe for Neuro Explorer...
		Set_event = (Set_event + 1) % Event_fifo_N;			// ...incriment event queue...
	
	
		nTrialComplete = nTrialComplete + 1;
		nTrialArray[targIndex] = nTrialArray[targIndex] + 1;
		nTrialRemain = nTrialRemain - 1;
		}
	// Canceled Stop Trial
	if (	trialOutcome == nogoCorrect)			// ...or if the trial is chosen as a surprise rewarded trial...
		{
		spawn TONE(toneStopSuccess,toneDuration);				// give the secondary reinforcer tone
		
		if (monkey == broca)
			{
			rewardDuration = round(rewardDuration * 1.3);   // give 'em a little extra for stopping to help them slow down
			}
		tone_time = time();									// record the time
	
		Event_fifo[Set_event] = Tone_;						// ...queue strobe...
		Set_event = (Set_event + 1) % Event_fifo_N;			// ...incriment event queue...
	
		Event_fifo[Set_event] = Reward_tone;				// ...queue strobe for Neuro Explorer...
		Set_event = (Set_event + 1) % Event_fifo_N;			// ...incriment event queue...
	
	
		nTrialComplete = nTrialComplete + 1;
		nTrialArray[targIndex] = nTrialArray[targIndex] + 1;
		nTrialRemain = nTrialRemain - 1;
		}
		
	//----------------------------------------------------------------------------------------------------
	//    Noncanceled stop trial
	else if (	trialOutcome == nogoTarg	||
				trialOutcome == nogoDist)		// ...or if the trial is chosen as a surprise punished trial...
		{
		spawn TONE(toneStopFailure,toneDuration);							// present negative tone
		tone_time = time();									// record the time
		punishDuration = basePunishDuration * 1.2;
		
		if (trialOutcome == nogoTarg)
			rewardDuration = round(rewardDuration / 3);
		else if (trialOutcome == nogoDist)
			rewardDuration = 0;

		
		Event_fifo[Set_event] = Tone_;									// ...queue strobe...
		Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue...
	
		Event_fifo[Set_event] = Error_tone;								// ...queue strobe for Neuro Explorer...
		Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue...

		nTrialComplete = nTrialComplete + 1;
		}
	//    Timed-out go trial
	else if (	trialOutcome	== goIncorrect)		// ...or if the trial is chosen as a surprise punished trial...
		{
		printf("goIncorrect \n");
		spawn TONE(toneAbort,toneDuration);							// present negative tone
		tone_time = time();									// record the time
		punishDuration = basePunishDuration * 3;
		rewardDuration = 0;
	
		Event_fifo[Set_event] = Tone_;									// ...queue strobe...
		Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue...
	
		Event_fifo[Set_event] = Error_tone;								// ...queue strobe for Neuro Explorer...
		Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue...
		}
	//    Go to distractor
	// Might want to some reward/punish for making the wrong choice but successfully responding on no-stop trial
	else if (trialOutcome == goDist)
		{
		punishDuration = round(basePunishDuration * 3);
		rewardDuration = 0;
		
		tone_time = time();									// record the time
		spawn TONE(toneChoiceFailure,toneDuration);							// present negative tone


		nTrialComplete = nTrialComplete + 1;
	
		Event_fifo[Set_event] = Tone_;									// ...queue strobe...
		Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue...
	
		Event_fifo[Set_event] = Error_tone;								// ...queue strobe for Neuro Explorer...
		Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue...
		}
	//----------------------------------------------------------------------------------------------------
	//    Aborted trial-- broke target fixation
	else if (trialOutcome == brokeTarg  || trialOutcome == brokeDist)
		{
		rewardDuration = 0;
		Event_fifo[Set_event] = Abort_;				// ...queue strobe...
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue...
		spawn TONE(200,300);	 
		punishDuration = round(basePunishDuration * 1.5);  // for choice countermanding, want it to be worse than making a wrong choice
		if (trialType == stopTrial && trialOutcome == brokeTarg)
			{
			punishDuration = basePunishDuration;  // for choice countermanding, can't help not stopping 50% of the time (so don't over-punish)
			rewardDuration = round(rewardDuration / 2); // give a bit of reward for at least making a correct choice
			nTrialComplete = nTrialComplete + 1;
			}
		}

		
	// Extra reward for a given target (on top of rewardRandomIncrease)
	if (trialOutcome == goTarg	&&
		(targIndex == 0 || targIndex == 2))							// if correct to the right target
		{
		rewardDuration = round(rewardDuration * (1 + targ1ExtraPct / 100));
		}
	else if (trialOutcome == goTarg	&&
		(targIndex == 1 || targIndex == 3))							// if correct to the left target
		{
		rewardDuration = round(rewardDuration * (1 + targ2ExtraPct / 100));
		}
	// Extra reward for successful stop trial
	if (trialOutcome == nogoCorrect)
		{
		rewardDuration = rewardDuration + 0;
		}

	if (trialOutcome == checkerAbort  || trialOutcome == saccOut)
		{
		punishDuration = round(basePunishDuration * 4);
		rewardDuration = 0;
		}
	}





// 		GO NO-GO TASK
//-----------------------------------------------------------------------------------------------------
if (state == stateGNG)
	{
	if (trialOutcome == brokeFix)
		{
		punishDuration = basePunishDuration * 2;
		rewardDuration = 0;
		}
	//    Correct trial
	if (	trialOutcome == goTarg 	||			// If the subject got the trial right...
				trialOutcome == nogoCorrect)			// ...or if the trial is chosen as a surprise rewarded trial...
		{
		if (trialOutcome == goTarg)
			spawn TONE(toneChoiceSuccess,toneDuration);				// give the secondary reinforcer tone
		else if (trialOutcome == nogoCorrect)
			spawn TONE(toneStopSuccess,toneDuration);				// give the secondary reinforcer tone
		tone_time = time();									// record the time
	
		Event_fifo[Set_event] = Tone_;						// ...queue strobe...
		Set_event = (Set_event + 1) % Event_fifo_N;			// ...incriment event queue...
	
		Event_fifo[Set_event] = Reward_tone;				// ...queue strobe for Neuro Explorer...
		Set_event = (Set_event + 1) % Event_fifo_N;			// ...incriment event queue...
	
	
	
		nTrialComplete = nTrialComplete + 1;
		nTrialArray[targIndex] = nTrialArray[targIndex] + 1;
		nTrialRemain = nTrialRemain - 1;
		}
	//----------------------------------------------------------------------------------------------------
	//    Error trial
	else if (	trialOutcome == nogoTarg)		// 
		{
		spawn TONE(toneStopFailure,toneDuration);						// present negative tone
		tone_time = time();											// record the time
		punishDuration = basePunishDuration;
		rewardDuration = 0;
	
		Event_fifo[Set_event] = Tone_;								// ...queue strobe...
		Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
	
		Event_fifo[Set_event] = Error_tone;							// ...queue strobe for Neuro Explorer...
		Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
		}
	else if (	trialOutcome	== goIncorrect)		// ...or if the trial is chosen as a surprise punished trial...
		{
		printf("goIncorrect \n");
		spawn TONE(toneAbort,toneDuration);							// present negative tone
		tone_time = time();									// record the time
		punishDuration = basePunishDuration * 1.5;
		rewardDuration = 0;
	
		Event_fifo[Set_event] = Tone_;									// ...queue strobe...
		Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue...
	
		Event_fifo[Set_event] = Error_tone;								// ...queue strobe for Neuro Explorer...
		Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue...
		}
	if (trialOutcome == nogoCorrect)
		{
		rewardDuration = rewardDuration + 0;
		}
	if (trialType == nogoTarg)					// noncanceled stop is  still a "complete" trial
		{
		nTrialComplete = nTrialComplete + 1;
		}

	}






// 		METACOG SUITE
//-----------------------------------------------------------------------------------------------------
if (state == stateMCM)
	{
	if (trialOutcome == brokeFix ||
		trialOutcome == saccOut)
		{
		spawn TONE(toneAbort,toneDuration*2);							// present negative tone
		punishDuration = round(basePunishDuration*2);
		rewardDuration = 0;
		}
	if (trialOutcome == saccTarg)			// Mask-only version
		{
		rewardDuration = round(rewardDuration);
		
		spawn TONE(toneChoiceSuccess,toneDuration);							// present negative tone
		tone_time = time();									// record the time
		}
	else if (trialOutcome == saccDist)			// Mask-only version
		{
		rewardDuration = 0;
		punishDuration = round(basePunishDuration * 1.2);
		spawn TONE(toneChoiceFailure,toneDuration);							// present negative tone
		tone_time = time();									// record the time
		}
	else if (trialOutcome == brokeTarg || trialOutcome == brokeDist)			// Mask-only version
		{
		rewardDuration = 0;
		punishDuration = round(basePunishDuration);			
		spawn TONE(toneAbort,toneDuration*2);							// present negative tone
		}
	if (trialType != tMaskTrial)  // For reverse-masking-only trials, reward like you would for a visually-guided saccade, e.g. (so skip this section)
		{
		if (trialOutcome == targHighBet)
			{
			rewardDuration = round(rewardDuration * 2);
			spawn TONE(toneTargHigh,toneDuration);							// present negative tone
			tone_time = time();									// record the time
			}
		else if (trialOutcome == targLowBet)
			{
			rewardDuration = round(rewardDuration * 1.5);
			spawn TONE(toneTargLow,toneDuration);							// present negative tone
			tone_time = time();									// record the time
			}
		else if (trialOutcome == distHighBet)
			{
			rewardDuration = 0;
			punishDuration = round(basePunishDuration * 3);
			spawn TONE(toneDistHigh,toneDuration);							// present negative tone
			tone_time = time();									// record the time
			}
		else if (trialOutcome == distLowBet)
			{
			rewardDuration = round(rewardDuration);
			punishDuration = 0;
			spawn TONE(toneDistLow,toneDuration);							// present negative tone
			tone_time = time();									// record the time
			}
		else if (trialOutcome == brokeBet)			
			{
			// rewardDuration = round(rewardDuration / 2);
			rewardDuration = 0;			
			punishDuration = basePunishDuration;			
			spawn TONE(toneAbort,toneDuration*2);							// present negative tone
			}
		else if (trialOutcome == betAbort)			// Mask-only version
			{
			rewardDuration = 0;
			punishDuration = round(basePunishDuration * 2);			
			spawn TONE(toneAbort,toneDuration*2);							// present negative tone
			}
		}
		
	}

if (state == stateVWM)
	{
	if (trialOutcome == fa || //false alarm
		trialOutcome == miss || //miss
		trialOutcome == hitIncSac) //incorrect saccade
		{
		Event_fifo[Set_event] = Abort_;				// ...queue strobe...
		Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue...
		punishDuration = round(basePunishDuration / 1.5);
		rewardDuration = 0;
		}
	if (trialOutcome == hitCorSac || //correct saccade
		trialOutcome == cr)			// correct rejection
		{
		spawn TONE(toneChoiceSuccess,toneDuration);				// give the secondary reinforcer tone
		tone_time = time();									// record the time

		Event_fifo[Set_event] = Tone_;						// ...queue strobe...
		Set_event = (Set_event + 1) % Event_fifo_N;			// ...incriment event queue...

		Event_fifo[Set_event] = Reward_tone;				// ...queue strobe for Neuro Explorer...
		Set_event = (Set_event + 1) % Event_fifo_N;			// ...incriment event queue...



		nTrialComplete = nTrialComplete + 1;
		condCounterArray[condIndex] = condCounterArray[condIndex] + 1;
		nTrialRemain = nTrialRemain - 1;
		}
		
	}





//-----------------------------------------------------------------------------------------------------
// DELIVERY OF REWARD:
if (rewardDuration > 0 && state != stateFix)
	{
		while (time() < tone_time + rewardDelay)			// wait until it is OK to give reward
			{		
			nexttick;										// wait for it... wait for it...
			}		
	spawn JUICE(juiceChannel,rewardDuration);			// YEAH BABY!  THAT'S WHAT IT'S ALL ABOUT!
	}
// Wait for the duration of a timeout (could be zero).
while(time() < rewards_start_time + punishDuration) // Then figure out how much time has elapsed since trial start...
	{                                                       
	nexttick;                                               // ...and continue to wait until time is up + timeout.
	}        
// drop reward code only if reward or timeout earned	
if ((rewardDuration > 0 || punishDuration > 0) && state != stateFix)  
	{
	Event_fifo[Set_event] = Reward_;									// ...queue strobe...
	Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue...
	}



nTrial = nTrial + 1;
nexttick 20;
trl_end_time = time();											// record the time b/c the trial is now over
	
Event_fifo[Set_event] = Eot_;									// ...queue strobe...
Set_event = (Set_event + 1) % Event_fifo_N;						// ...incriment event queue...




spawnwait INFOS();									// ...queue a big ole` pile-o-strobes for plexon
nexttick 25;										// Give TEMPO a chance to catch its breath before attempting.. 
													// ...RDX communication with vdosync.
													// NOTE: if you add a bunch more strobes to INFOS.pro and you...
													// start getting buffer overflow errors increase the number of nextticks.







//-----------------------------------------------------------------------------------------------------
// If the animal moved, and we are training stillness, impose a punishment
while (Move_ct > 0)
	{
	now = time();
	while (time() < now + bmove_tout)
		{
		nexttick;
		}
	Move_ct = Move_ct - 1;
	}



	



// -----------------------------------------------------------------------------------------------
// Should we run a trial or are we done?
if (nTrialRemain == 0)
	{
	system("dpop");
	state = stateNoTask;     // if we're done, kick it out to idle state
	
	}







// -----------------------------------------------------------------------------------------------
// Add extra inter-trial time if we are doing fixed-trial durations
if (fixedTrialDuration)											// Did you want a fixed trial length?
	{                                                           
	while(time() < trialStartTime + trialDuration + punishDuration) // Then figure out how much time has elapsed since trial start...
		{                                                       
		nexttick;                                               // ...and continue to wait until time is up + timeout.
		}                                                       
	}                                                           
else                                                            // Did you want a fixed intertrial interval?
	{                                                           
	while (time() < trl_end_time + interTrialDuration) // Then watch the time since trial end...
		{                                                       
		nexttick;                                               // ...and wait until time is up + timeout.
		}		                                                
	}


}//
// written by david.c.godlove@vanderbilt.edu 	January, 2011

// which room are we in?
declare constant hide int 	Room			= 23;		// which room are we in?


// viewing measurements used to compute degrees (units need to be the same)
declare constant hide float screenWidth 		= 40.00;	// in some units
declare constant hide float screenHeight		= 30.00;	// in some units
declare 		 hide float subjDist 		= 58.0;	// distance from center of subjects eyeball to screen
	
// where does your photodiode marker need to be?	
declare constant hide float pdLeft			= 1.0; //2.1; 		// distance from left of screen (same units as above)
declare constant hide float pdBottom		= 1.0; //1.8; 		// distance from bottom of screen (same units as above)
declare constant hide float pdSize			= 2;		// minimum targSize for consistant triggering (same units as above)
	
// what is your screen resolution	
declare constant hide int   screenPixelX    	= 1024;//640; //720;		// number of pixels across
declare constant hide int   screenPixelY    	= 768;//480;		// number of pixels in height
declare constant hide float	screenRefreshRate	= 70;		// in Hz

// what is the gain on your eye tracking setup?
// In 023, calibration target is 12.8cm horizontal, 12.8 cm vertical. Atan(12.8/58) = 9.74 deg, Atan(12.8/58) = 11.23 deg
declare constant hide float	eyeXGain			= 60;//12.44;//3.622;	// x scaling factor to convert eye trace voltage to degrees (must be calculated from calibration)
declare constant hide float eyeYGain			= 60;//12.44;//3.837;	// y scaling factor to convert eye trace voltage to degrees (must be calculated from calibration)
//declare constant hide float eyeXGain			= 9.74;	// x scaling factor to convert eye trace voltage to degrees (must be calculated from calibration)
//declare constant hide float eyeYGain			= 11.23;	// y scaling factor to convert eye trace voltage to degrees (must be calculated from calibration)
// declare constant hide float	eyeXGain			= 4.8;	// x scaling factor to convert eye trace voltage to degrees (must be calculated from calibration)
// declare constant hide float eyeYGain			= 5;	// y scaling factor to convert eye trace voltage to degrees (must be calculated from calibration)

declare hide float			eyeXOffset		= 0; 		// for zeroing x trace
declare hide float			eyeYOffset		= 0;		// for zeroing y trace

// what kind of hardware configuration are you using?
declare constant hide int	juiceChannel   = 0;   // line 0 is pin #51 (i.e. Digital A0 on the PIC-DAS1602)
declare constant hide int	stimChannel   = 6;//  (029 = 8;)    // line 8 is pin #59 (i.e. Digital BO on the PCI-DAS1602)
declare constant hide int	eyeXChannel   = 1;   
declare constant hide int	eyeYChannel   = 2;    
declare constant hide int	pdChannel  = 5;
declare constant hide float	maxVoltage 		= 10;		//look at das_gain and das_polarity in kped (setup tn)
declare constant hide float	analogUnits		= 65536;	// use this for a 64 bit AD board
// declare constant hide float analogUnits   = 4096;	// use this for a 12 bit AD board

// what kind of motion detector hardware are you using?
declare  hide 		checkMouthFlag		= 0;		// use this if you have a motion detector on the MOUTH going into channel 3
declare  hide 		checkBodyFlag		= 0;		// use this if you have a motion detector on the BODY going into channel 3//--------------------------------------------------------------------------------------------------
//This is the main search protocol.  It works like this.
// 1) Define all varialbes
// 2) Setup variables needed for a trial
// and start loop
// 3) Run a trial
// 4) End the trial
// 		a) deliver rewards and punishments
//		b) take care of ITI
// 		c) set up variables for next run
//
// written by joshua.d.cosman@vanderbilt.edu 	July, 2013
	
	
declare SEARCH_PGS();						

process SEARCH_PGS()     
	{
	declare hide int run_search_sess = 7;
	declare hide int run_idle		 = 0;
			
	Trl_number				= 1;
	Rand_Comp_Trl_number	= 0;
	Rep_Comp_Trl_number		= 0;
	Block_number			= 1;
	rand_inacc_sacc 		= 0;
	rep_inacc_sacc			= 0;
	RandPerAcc				= 0;
	RepPerAcc				= 0;
	Correct_trls 			= 0;
	
	if (Last_task != run_search_sess)			// Only do this if we have gone into another task or if this is first run of day.
		{
		system("dialog Select_Monkey");
		spawnwait DEFAULT(State,				// Set all globals to their default values.
						Monkey,					
						Room);				
		Last_task = run_search_sess;
		}
		
	dsend("DM RFRSH");                			// This code sets up a vdosync macro definition to wait a specified ...
	if (Room == 23)                   			// ...number of vertical retraces based on the room in which we are    ...
		{                             			// ...recording.  This kluge is necessary because vdosync operates     ...
		dsendf("vw %d:\n",1);         			// ...differently in the different rooms.  In 028 a command to wait    ...
		}                             			// ...2 refresh cycles usually only waits for one and a command to     ...
	else                              			// ...wait for 1 usually only waits for 0.  Room 029 and 023 appear to ...
		{                             			// ...work properly.
		dsendf("vw %d:\n",2);
		}
	dsend("EM RFRSH");
	
	
	
	while(!OK)									
		{
		nexttick;
		if(Set_monkey)
			{
			spawnwait DEFAULT(State,			// Set all globals to their default values for a particular monkey.
						Monkey,						
						Room);	
			Set_monkey = 0;
			}
		}
	
	//spawnwait GOODVARS(State);
	
	spawnwait SET_SCH();						// sets up search RT graph
					
	spawnwait SET_CLRS(n_targ_pos);             // calls SET_CLRS.pro, which sets all colors for all tasks based on input
	
	if (!Train)
		{
		spawnwait REP_ORT;							// sets repeated orientations once at beginning of task
		spawnwait LOC_REP;							// sets repeated locations once outside the trial loop at the beginning of task
		}
		
	spawnwait SETS_TRL(n_targ_pos,				// Select variables for the first search...
				go_weight,						// ...trial.  This happens once outside of the while...
				stop_weight,					// ...loop just to set up for the first iteration. After...
				ignore_weight,					// ...that SETC_TRL.pro will be called by END_TRL.pro.
				staircase,
				n_SSDs,
				min_holdtime,
                max_holdtime,
				expo_jitter);

				
	Event_fifo[Set_event] = SearchHeader_;		// Set a strobe to identify this file as a Cmanding session and...	
	Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
	Event_fifo[Set_event] = Identify_Room_;		// Set a strobe to identify this file as a Cmanding session and...	
	Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
	Event_fifo[Set_event] = Room;				// Set a strobe to identify this file as a Cmanding session and...	
	Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
	Event_fifo[Set_event] = SearchType;				// Set a strobe to identify this file as a Cmanding session and...	
	Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
	Event_fifo[Set_event] = SetSize;				// Set a strobe to identify this file as a Cmanding session and...	
	Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment even
	Event_fifo[Set_event] = TargetType;				// Set a strobe to identify this file as a Cmanding session and...	
	Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment even
	
	nexttick 10;								// to prevent buffer overflows after task reentry.
	
	CheckMotion = 1;							// set global for watching the motion detector
	spawn WATCHMTH;								// start watching the mouth motion detector if present
	spawn WATCHBOD;								// start watching motion detector for body if present
	
	while (state == run_search_sess)				// while the user has not yet terminated the countermanding task
		{
		 
		 //Pre-trial business
		 spawnwait RAND_ORT;						// sets orientations of random stimuli
		 spawnwait LOC_RAND;						 // sets random locations at the beginning of each new trial
		 
		 spawnwait SEL_LOCS;						// selects locations to be used on the current trial
		 
		 //Spawn the trial
		 spawnwait SCHTRIAL(allowed_fix_time, 	// run a trial with variables defined in SETC_TRL.pro
							curr_holdtime, 
							trl_type, 
							max_saccade_time, 
							curr_ssd, 
							cancl_time, 
							max_sacc_duration, 
							targ_hold_time,
							object_fix);		
		
		spawnwait END_TRL(trl_outcome);			// end a trial with trl_outcome set in SEARCH.pro

		nexttick 5;								// wait at least five cycles and do it all again
		
		while(Pause)							// gives the user the ability to pause the task without ending it
			{
			nexttick;
			}
		
		}

												// the State global variables allow a control structure...
												// ...to impliment the task.
	State = run_idle;							// If we are out of the while loop the user wanted...
												// ...to stop cmanding.
	CheckMotion = 0;							// stop watching for motion detector.
												
	oDestroy(object_fixwin);					// destroy all task graph objects
	oDestroy(object_targwin);
	oDestroy(object_fix);
	oDestroy(object_targ);
	oDestroy(object_eye);
	
	oSetGraph(gleft,aCLEAR);					// clear the left graph
	
	oDestroy(object_repeat);						// destroy all RT graph objects
	oDestroy(object_random);						

	
	oSetGraph(gleft,aCLEAR);					// clear the right graph
		
	spawn IDLE;									// return control to IDLE.pro
    
	}//--------------------------------------------------------------------------------------------------
// Set TTLs to a value denoting a stobed event, wait 100 micro seconds so plexon can pick it up, 
// and then set the values back 0
// value  = 0 to 32767 (signed 16 bit so in theory negative works too but not used here).
// NOTE: Two problems may arise when sending TTLs.  First, TTLs may be sent 
// too quickly for plexon to keep up and plexon may drop them.  This won't
// result in any errors you can see.  Second, too much time may be allotted
// to individual TTLs causing more time to be allotted to TTLs than is possible
// on a process cycle.  This will result in buffer overflow messages in TEMPO.
// The balance between too little time and too much time is struck by 1) the 
// number of micro seconds allotted to each TTL, 2) the number of TTLs sent
// per process cycle, and 3) the amount of other stuff you allow to happen while
// TTLs are being sent.  In rig 028 I have found that 100 microseconds between TTLs
// and 5 TTLs per process cycle results in zero drops and zero overflows AS LONG AS
// I HAVE APPROPRIATELY PLACED nextticks IN AREAS OF HEAVY TTL VOLUME.  That way
// other processes (e.g. rdx communication) don't use up all of the buffer while I am
// trying to strobe.  All of this may depend on plexon settings that I am 
// currently unaware of, and tests should be performed in each rig to find 
// appropriate parameters.
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011

#include C:/TEMPO/ProcLib/WAIT_MU.pro

declare SEND_TTL(int value);

process SEND_TTL(int value)
	{	
	declare int output = 1;

	dioSetMode(output, PORTA|PORTB|PORTC);			// set ports A, B, and C to send strobes (output)

	dioSetA(output, (value & 0xFF ));				// load the low 8 bits on port A
	dioSetB(output, (value>>8) | 0x80);				// load the high 8 bits on port B
	dioSetC(output, 0x01);							// set port C to flag telling plexon strobe is happening
													// (this may not be necessary if plexon is configured in...
													// ...a different way)	
	spawnwait WAIT_MU(100);							// wait 100 micro seconds to avoid losing events
		
	dioSetA(output, (0x0 & 0xFF));					// set port A back to 0
	dioSetB(output, (0x0 & 0x7F));					// I don't know why this is set to 01110000 (this is copied from Pierre's code)
	dioSetC(output, 0x00);							// set port C back to 0
	}// This sets all of the colors up which will be needed for the protocol based on user input
// specified elsewhere
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011

declare SET_CLRS();

process SET_CLRS()
	{
	declare hide int color_num, r_, g_, b_;
	r_ = 0; g_ = 1; b_ = 2;
	
	color_num = 0;
	while (color_num <=  8)				// set each target targColor to the matching targColor number 
		{
		dsendf("cm %d %d %d %d;\n",
						color_num + 1,				// 0 remains black
						targColorArray[color_num,r_],	// GLOBAL ALERT; targColorArray is an array so it cannot be passed
						targColorArray[color_num,g_],
						targColorArray[color_num,b_]);
		color_num = color_num + 1;
		nexttick;									// if we have a large number of targets we don't want to overflow the buffer
		}
	
	dsendf("cm 255 %d %d %d;\n",					// set the targColor of the fixation point to 255 (leaves room for many target colors)
						fixColorArray[r_],			// GLOBAL ALERT; fixColorArray is an array so it cannot be passed
	                    fixColorArray[g_],
						fixColorArray[b_]);
	
	dsendf("cm 254 %d %d %d;\n",					// set the targColor of the stop signal to 254 (leaves room for many target colors)
						stopColorArray[r_],			// GLOBAL ALERT; fixColor is an array so it cannot be passed
	                    stopColorArray[g_],
						stopColorArray[b_]);
	
	dsendf("cm 253 %d %d %d;\n",					// set the targColor of the ignore signal to 253 (leaves room for many target colors)
						ignoreColorArray[r_],		// GLOBAL ALERT; fixColor is an array so it cannot be passed
	                    ignoreColorArray[g_],
						ignoreColorArray[b_]);

	dsendf("cm 252 %d %d %d;\n",					// set the targColor of the ignore signal to 253 (leaves room for many target colors)
						maskColorArray[r_],			// GLOBAL ALERT; fixColor is an array so it cannot be passed
	                    maskColorArray[g_],
						maskColorArray[b_]);

	dsendf("cm 251 %d %d %d;\n",					// set the targColor of the ignore signal to 253 (leaves room for many target colors)
						highBetColorArray[r_],			// GLOBAL ALERT; fixColor is an array so it cannot be passed
	                    highBetColorArray[g_],
						highBetColorArray[b_]);

	dsendf("cm 250 %d %d %d;\n",					// set the targColor of the ignore signal to 253 (leaves room for many target colors)
						lowBetColorArray[r_],			// GLOBAL ALERT; fixColor is an array so it cannot be passed
	                    lowBetColorArray[g_],
						lowBetColorArray[b_]);

	dsendf("cm 249 %d %d %d;\n",					// set the targColor of the ignore signal to 253 (leaves room for many target colors)
						betFixColorArray[r_],			// GLOBAL ALERT; fixColor is an array so it cannot be passed
	                    betFixColorArray[g_],
						betFixColorArray[b_]);

	dsendf("cm 248 %d %d %d;\n",					// set the targColor of the ignore signal to 253 (leaves room for many target colors)
						proFixColorArray[r_],			// GLOBAL ALERT; fixColor is an array so it cannot be passed
	                    proFixColorArray[g_],
						proFixColorArray[b_]);
	//vwm				
	dsendf("cm 247 %d %d %d;\n",					// set the targColor of the ignore signal to 253 (leaves room for many target colors)
						vwmColorArray[0,r_],			// GLOBAL ALERT; fixColor is an array so it cannot be passed
	                    vwmColorArray[0,g_],
						vwmColorArray[0,b_]);	
	
	dsendf("cm 246 %d %d %d;\n",					// set the targColor of the ignore signal to 253 (leaves room for many target colors)
						vwmColorArray[1,r_],			// GLOBAL ALERT; fixColor is an array so it cannot be passed
	                    vwmColorArray[1,g_],
						vwmColorArray[1,b_]);	
	dsendf("cm 245 %d %d %d;\n",					// set the targColor of the ignore signal to 253 (leaves room for many target colors)
						vwmColorArray[2,r_],			// GLOBAL ALERT; fixColor is an array so it cannot be passed
	                    vwmColorArray[2,g_],
						vwmColorArray[2,b_]);	
	dsendf("cm 244 %d %d %d;\n",					// set the targColor of the ignore signal to 253 (leaves room for many target colors)
						vwmColorArray[3,r_],			// GLOBAL ALERT; fixColor is an array so it cannot be passed
	                    vwmColorArray[3,g_],
						vwmColorArray[3,b_]);	
	dsendf("cm 243 %d %d %d;\n",					// set the targColor of the ignore signal to 253 (leaves room for many target colors)
						vwmColorArray[4,r_],			// GLOBAL ALERT; fixColor is an array so it cannot be passed
	                    vwmColorArray[4,g_],
						vwmColorArray[4,b_]);	
	dsendf("cm 242 %d %d %d;\n",					// set the targColor of the ignore signal to 253 (leaves room for many target colors)
						vwmColorArray[5,r_],			// GLOBAL ALERT; fixColor is an array so it cannot be passed
	                    vwmColorArray[5,g_],
						vwmColorArray[5,b_]);	
	dsendf("cm 241 %d %d %d;\n",					// set the targColor of the ignore signal to 253 (leaves room for many target colors)
						vwmColorArray[6,r_],			// GLOBAL ALERT; fixColor is an array so it cannot be passed
	                    vwmColorArray[6,g_],
						vwmColorArray[6,b_]);	
	dsendf("cm 240 %d %d %d;\n",					// set the targColor of the ignore signal to 253 (leaves room for many target colors)
						vwmColorArray[7,r_],			// GLOBAL ALERT; fixColor is an array so it cannot be passed
	                    vwmColorArray[7,g_],
						vwmColorArray[7,b_]);
						
	dsendf("cm 239 %d %d %d;\n",					// set the targColor of the ignore signal to 253 (leaves room for many target colors)
						vwmColorArray[8,r_],			// GLOBAL ALERT; fixColor is an array so it cannot be passed
	                    vwmColorArray[8,g_],
						vwmColorArray[8,b_]);
	}//------------------------------------------------------------------------
// process SET_COOR(float screenWidth, float screenHeight, float subjDist);
// determine virtual coordiates in degrees based on screen size and 
// subject distance to the screen
// NOTE 1:  all measurements must be in the same units (doesn't matter what units).
// NOTE 2:  accuracy (and hence step targSize of stimuli) is in 0.1 degree incriments
// NOTE 3:  since accuracy is in 0.1 degree incriments, input measurements must 
// 			have corresponding resolution (this depends on distance from screen)
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011


declare hide float Deg2Pix_X;
declare hide float Deg2Pix_Y; 
declare hide float Unit2Pix_X;
declare hide float Unit2Pix_Y;
						/*OUTPUT: these conversion factors will be used throughout protocol when drawing
				         (this is necessary b/c unless you are really careful with virtual coordinates
				         you wil end up with stimuli which are slightly off, and what is the point of 
				         using virtual coordinates if you have to be super careful about it?)*/
		  
				 
declare SET_COOR();						// see RIGSETUP.pro for variable explanation

process SET_COOR() 						// see RIGSETUP.pro for variable explanation
	{
	
	declare hide float half_width;  
	declare hide float half_height; 	
	declare hide float deg_x;
	declare hide float deg_y; 
	
	// get half of screen targSize
	half_width  = screenWidth / 2;  						// right now we are thinking about cm, inches, mm, or whatever you measured in
	half_height = screenHeight / 2;
	
	// figure out dimensions in degrees
	deg_x  = rad2deg(atan (half_width / subjDist)); 	//tangent(theta) = opposite/adjacent
	deg_y  = rad2deg(atan (half_height / subjDist));
	
	// get half of screen targSize in pixels
	half_width  = screenPixelX / 2;  						// now we are thinking about pixels
	half_height = screenPixelY / 2;
	
	// set screen in pixel coordinates with the origin in center
	dsendf("vc %d, %d, %d, %d\n",-1*half_width,half_width,half_height,-1*half_height);
	
	Deg2Pix_X = half_width/deg_x;
	Deg2Pix_Y = half_height/deg_y;
	
	Unit2Pix_X = screenPixelX/screenWidth;
	Unit2Pix_Y = screenPixelY/screenHeight;
	
	}// Sets up Inhibition function graph for cmanding 
// NOTE: GRAPHS.pro or OBJECT.pro needs to have been run already
// to set up globals.
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011

declare FirstStopTrial = 1; 								// GLOBAL ALERT; Lets UPD8_INH.pro know to reset counters


declare SET_INH();

process SET_INH()
	{
	declare int ssd_range;
	declare int inh_left;
	declare int inh_right;
	declare int inh_box_size;
	
	FirstStopTrial = 1;											// GLOBAL ALERT; Lets UPD8_INH.pro know to reset counters

	ssd_range = (ssdMax - ssdMin) * 1000;
	
	oSetGraph(gRIGHT, aCLEAR);
	
	if (ssdMin == ssdMax)
		{
		ssd_range = 200000;
		}
		
	inh_left = (ssdMin * 1000) - (ssd_range/40);
	inh_right = (ssdMax * 1000) + (ssd_range/40);
	
	oSetGraph(gRIGHT,   										// Object graph virt. coord
			aRANGE, 
			inh_left,  		
			inh_right,
			1025, 
			-25);			

	inh_box_size = (ssd_range/20);		
	
	oSetGraph(gRIGHT, aTITLE, "*** INHIBITION FUNCTION ***");	// Graph title
	
	object_ssd0 = oCreate(tBOX, gRIGHT, inh_box_size, 50);		// Create SSD object (20 is max b/c defaults.  could be changed.)
    oSetAttribute(object_ssd0, aINVISIBLE);						// Not visible yet
	
	object_ssd1 = oCreate(tBOX, gRIGHT, inh_box_size, 50);		// Create SSD object
    oSetAttribute(object_ssd1, aINVISIBLE);						// Not visible yet
	
	object_ssd2 = oCreate(tBOX, gRIGHT, inh_box_size, 50);		// Create SSD object
    oSetAttribute(object_ssd2, aINVISIBLE);						// Not visible yet
	
	object_ssd3 = oCreate(tBOX, gRIGHT, inh_box_size, 50);		// Create SSD object
    oSetAttribute(object_ssd3, aINVISIBLE);						// Not visible yet
	
	object_ssd4 = oCreate(tBOX, gRIGHT, inh_box_size, 50);		// Create SSD object
    oSetAttribute(object_ssd4, aINVISIBLE);						// Not visible yet
	
	object_ssd5 = oCreate(tBOX, gRIGHT, inh_box_size, 50);		// Create SSD object
    oSetAttribute(object_ssd5, aINVISIBLE);						// Not visible yet
	
	object_ssd6 = oCreate(tBOX, gRIGHT, inh_box_size, 50);		// Create SSD object
    oSetAttribute(object_ssd6, aINVISIBLE);						// Not visible yet
	
	object_ssd7 = oCreate(tBOX, gRIGHT, inh_box_size, 50);		// Create SSD object
    oSetAttribute(object_ssd7, aINVISIBLE);						// Not visible yet
	
	object_ssd8 = oCreate(tBOX, gRIGHT, inh_box_size, 50);		// Create SSD object
    oSetAttribute(object_ssd8, aINVISIBLE);						// Not visible yet
	
	object_ssd9 = oCreate(tBOX, gRIGHT, inh_box_size, 50);		// Create SSD object
    oSetAttribute(object_ssd9, aINVISIBLE);						// Not visible yet
	
	object_ssd10 = oCreate(tBOX, gRIGHT, inh_box_size, 50);	// Create SSD object
    oSetAttribute(object_ssd10, aINVISIBLE);						// Not visible yet
	
	object_ssd11 = oCreate(tBOX, gRIGHT, inh_box_size, 50);	// Create SSD object
    oSetAttribute(object_ssd11, aINVISIBLE);						// Not visible yet
	
	nObject 		= object_ssd11; 			// update nObject to the biggest value possible
	
	}// Sets up  graph for go/no-go 
// NOTE: GRAPHS.pro or OBJECT.pro needs to have been run already
// to set up globals.
//
// 2012-04: adapted from SET_INH 	-pgm

declare FirstTrial 		= 1; 								// GLOBAL ALERT; Lets UPD8_PSY.pro know to reset counters


declare SET_PSY();

process SET_PSY()
	{
	declare int psy_range;
	declare int psy_left;
	declare int psy_right;
	declare int psy_box_size;
	
	FirstTrial = 1;											// GLOBAL ALERT; Lets UPD8_PSY.pro know to reset counters

	psy_range = 5 + (maxDiscriminate - minDiscriminate) * 1000;
	
	oSetGraph(gRIGHT, aCLEAR);
	
	if (minDiscriminate == maxDiscriminate)
		{
		psy_range = 1000;
		}
		
	psy_left = (minDiscriminate * 1000) - (psy_range/40);
	psy_right = (maxDiscriminate * 1000) + (psy_range/40);
	
	oSetGraph(gRIGHT,   										// Object graph virt. coord
			aRANGE,   
			psy_left,  		
			psy_right,
			1025, 
			-25);			

	psy_box_size = (psy_range/20);		
	
	oSetGraph(gRIGHT, aTITLE, "*** PSYCHOMETRIC FUNCTION ***");	// Graph title
	
	object_psy0 = oCreate(tBOX, gRIGHT, psy_box_size, 50);		// Create psy object (20 is max b/c defaults.  could be changed.)
    oSetAttribute(object_psy0, aINVISIBLE);						// Not visible yet
	
	object_psy1 = oCreate(tBOX, gRIGHT, psy_box_size, 50);		// Create psy object
    oSetAttribute(object_psy1, aINVISIBLE);						// Not visible yet
	
	object_psy2 = oCreate(tBOX, gRIGHT, psy_box_size, 50);		// Create psy object
    oSetAttribute(object_psy2, aINVISIBLE);						// Not visible yet
	
	object_psy3 = oCreate(tBOX, gRIGHT, psy_box_size, 50);		// Create psy object
    oSetAttribute(object_psy3, aINVISIBLE);						// Not visible yet
	
	object_psy4 = oCreate(tBOX, gRIGHT, psy_box_size, 50);		// Create psy object
    oSetAttribute(object_psy4, aINVISIBLE);						// Not visible yet
	
	object_psy5 = oCreate(tBOX, gRIGHT, psy_box_size, 50);		// Create psy object
    oSetAttribute(object_psy5, aINVISIBLE);						// Not visible yet
	
	object_psy6 = oCreate(tBOX, gRIGHT, psy_box_size, 50);		// Create psy object
    oSetAttribute(object_psy6, aINVISIBLE);						// Not visible yet
	
	object_psy7 = oCreate(tBOX, gRIGHT, psy_box_size, 50);		// Create psy object
    oSetAttribute(object_psy7, aINVISIBLE);						// Not visible yet
	
	object_psy8 = oCreate(tBOX, gRIGHT, psy_box_size, 50);		// Create psy object
    oSetAttribute(object_psy8, aINVISIBLE);						// Not visible yet
	
	object_psy9 = oCreate(tBOX, gRIGHT, psy_box_size, 50);		// Create psy object
    oSetAttribute(object_psy9, aINVISIBLE);						// Not visible yet
		
	nObject 		= object_psy9; 			// update nObject to the biggest value possible
		
	// Reset counter arrays:
	nPsy[0] = 0;
	nPsy[1] = 0;
	nPsy[2] = 0;
	nPsy[3] = 0;
	nPsy[4] = 0;
	nPsy[5] = 0;
	nPsy[6] = 0;
	nPsy[7] = 0;
	nPsy[8] = 0;
	nPsy[9] = 0;

	nPsyRespond[0] = 0;
	nPsyRespond[1] = 0;
	nPsyRespond[2] = 0;
	nPsyRespond[3] = 0;
	nPsyRespond[4] = 0;
	nPsyRespond[5] = 0;
	nPsyRespond[6] = 0;
	nPsyRespond[7] = 0;
	nPsyRespond[8] = 0;
	nPsyRespond[9] = 0;

	nTarg1Respond[0] = 0;
	nTarg1Respond[1] = 0;
	nTarg1Respond[2] = 0;
	nTarg1Respond[3] = 0;
	nTarg1Respond[4] = 0;
	nTarg1Respond[5] = 0;
	nTarg1Respond[6] = 0;
	nTarg1Respond[7] = 0;
	nTarg1Respond[8] = 0;
	nTarg1Respond[9] = 0;

	}//-----------------------------------------------------------------------------------
// process SETTRIAL();
// Calculates all variables needed to run each task. See DEFAULT.pro and ALL_VARS.pro for an explanation of the global input variables
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011
// 11-2011: Integrated choice countermanding task into ALL_PROS.pro. -pgm

#include C:/TEMPO/ProcLib/pgm/STAIR.pro						// staircases the SSD based on the last stop trial outcome
#include C:/TEMPO/ProcLib/pgm/STAIRDSC.pro					// staircases the discriminatory difficulty based on the last stop trial outcome
//#include C:/TEMPO/ProcLib/pgm/VWMParam.pro					//select setsize samediff stimuli, and locations for each vwm trial



declare hide int targIndex;								// OUTPUT: next trial target
declare hide int distIndex;								// for 2AFC tasks
declare hide int distIndex1, distIndex2, distIndex3; 	// up to 3 distractors (for reverse masking task)								
declare hide int highBetIndex, lowBetIndex;				// OUTPUT: next trial target
declare hide int signalColor;							// next signal targColor (could be either stop or ignore)
declare hide int ssd;									// SSD on next stop or ignore trial
declare hide int preTargHoldtime;						// next trial time between fixation and target onset
declare hide int postTargHoldtime;						// next trial time between target onset and cue to respond
declare hide int preBetHoldtime;						// next trial time between bet fixation and bet targets onset
declare hide int preProHoldtime;						// next trial time between proFixation and mask onset
declare hide int proportionIndex; 						// determined below to set the choice targColor proportion to use on this trial
declare hide int nDiscriminate;
declare float 	targ1CheckerProp;
declare int		targ1 = 0;
declare int		targ2 = 1;


//for VWM!
declare int acceptCondFlag = 0;
declare int acceptColorFlag = 0;
declare int acceptLocFlag = 0;

declare int condIndex = 0;
declare int colorIndex = 0;
declare int locIndex = 0;
declare int nColorsArray[8];
declare int nLocsArray[8];
declare int setsize;
declare int samediff; //vwm
declare int testColor;
declare int color_counter = 0;
declare int loc_counter = 0;



 

declare SETTRIAL();							// see DEFAULT.pro and ALL_VARS.pro for explanations of these globals


process SETTRIAL()							// see DEFAULT.pro and ALL_VARS.pro for explanations of these globals
{

declare hide int 		decideSSD;
declare hide float 		per_jitter, jitter, randomProp, holdtimeDiff, soa_diff;
declare int 			iLevel;
declare int 			acceptTargetFlag, acceptPropFlag;
declare int 			ampArrayIndex;						// the random index to use choosing an amplitude on this trial
declare int 			useMiddleStimFlag;				// Used to balance trial types, so the 50% discriminatory stim doesn't get used more than other discrim levels 
declare int 			agreeFlag;				// flag to make sure randomly chosen go/no-go cue targColor proportion agrees with trial type (go or nogo)
declare int				randomPct;
declare float			randomProp;
declare int 			i;



// -----------------------------------------------------------------------------------------------
// Select current holdtime

holdtimeDiff = holdtimeMax - holdtimeMin;
randomProp 			= (random(1001))/1000.0;
if (expoJitterFlag)
	{		
	per_jitter 		= exp(-1.0*(randomProp/0.25));	
	}
else
	{
	per_jitter 			= randomProp;
	}
jitter 			= holdtimeDiff * per_jitter;
preTargHoldtime 	= round(holdtimeMin + jitter);






// --------------------------------------------------------------------------------
// FIXATION TASK
// --------------------------------------------------------------------------------
if (state == stateFIX)
	{
	fixAngle 	= angleArray[targIndex]; 													// THESE USER DEFINED GLOBALS ARE ARRAYS SO 
	fixAmp 		= ampArray[targIndex];												// THEY CANNOT BE PASSED INTO PROCESSES
	}
	
	
	

// --------------------------------------------------------------------------------
// VISUALLY GUIDED, DELAYED, AND MEMORY GUIDED SACCADE TASK
// --------------------------------------------------------------------------------
if (state == stateVIS ||
	state == stateDEL ||
	state == stateMEM)
	{
	// -----------------------------------------------------------------------------------------------
	// 1) Pick a target
	acceptTargetFlag = 0;
	targAmp 		= ampDefault;
	while (acceptTargetFlag == 0)
		{
		targIndex = random(nTarg);						// 	COULD WEIGHT THIS IF NEED BE (see logic below)
		if (nTrialArray[targIndex] < nTrialPerTarget)
			{
			acceptTargetFlag = 1;
			targAngle = angleArray[targIndex];
			}
			nexttick;
		}
	

				

	// -----------------------------------------------------------------------------------------------
	// 5) Select current soa (same logic as above)
	
	soa_diff = soaMax - soaMin;
	randomProp 			= (random(1001))/1000.0;
		if (expoJitterFlag_soa)
			{
			per_jitter 		= exp(-1.0*(randomProp/.25));	
			}
		else
			{
			per_jitter 	= randomProp;				// random number 0-100 (percentages)
			}
		jitter 			= soa_diff * per_jitter;
		soa 		= round(soaMin + jitter);
		// }
	}






	
	
	
	
	
	
	
	
	
	
	
	
// --------------------------------------------------------------------------------
// AMPLITUDE TASK
// --------------------------------------------------------------------------------
if (state == stateAMP)		// user wants to run the choice countermanding task
	{
	// -----------------------------------------------------------------------------------------------
	// Pick an amplitude and default the targIndex to 0 (the first one in the list.

	targIndex = 0;
	acceptTargetFlag = 0;
	while (acceptTargetFlag == 0)
		{
		ampArrayIndex = random(8);						
		if (nTrialArray[ampArrayIndex] < nTrialPerTarget)
			{
			acceptTargetFlag = 1;
			trialAmp = ampArray[ampArrayIndex];
			// fixAngle = 		angleArray[targIndex] + 180;  // For the amplitude task, the fixation is 1/2 the amplitude from
			// fixAmp = 		trialAmp/2;				// the center of the screen, 180 degrees from the target.
			targAngle = 	angleArray[targIndex];
			targAmp = 		trialAmp;
			targWinSize = round(4 + targAmp * .6);
			}
		}
					
	}	




	
	
	
	
	
	
	
	
	
	
	
	
	


// --------------------------------------------------------------------------------
// SIMPLE COUNTERMANDING TASK
// --------------------------------------------------------------------------------
if (state == stateCMD)		// user wants to run the countermanding task
	{
	// -----------------------------------------------------------------------------------------------
	// Pick a target

	// targIndex = random(nTarg);						// 	COULD WEIGHT THIS IF NEED BE (see logic below)
	randomProp 			= (random(1001))/1000.0;
	if (randomProp <= targetRightRate)
		{
		targIndex = 0;						// 	COULD WEIGHT THIS IF NEED BE (see logic below)
		}
	else
		{
		targIndex = 1;
		}
	targAngle = angleArray[targIndex];
	targAmp 		= ampDefault;
	// targAmp already set as default
	
	
	// -----------------------------------------------------------------------------------------------
	// If randomly varying the eccentricity of the target, choose that
	
	if (!randomAmpFlag)
		{
		targAmp = ampDefault;
		}
	else if (randomAmpFlag)
		{
		ampIndex = random(4);
		targAmp = ampArray[ampIndex];
		}
		
	
	// -----------------------------------------------------------------------------------------------
	// Pick a trial type
															// Pick a number and then assess user defined weights to see what type of trial will be presented.
	randomPct 			= (random(10001))/100.0;

	if (randomPct <= goPct)						// If we are on the left of the number line...
		{
		trialType = goTrial;									// ...its a go trial.
		}
	else if (randomPct > goPct 
			&& randomPct <= goPct + stopPct)	// If we are in the middle of the number line...
		{
		trialType = stopTrial;								// ...it is a stop trial, and...
		signalColor = stopColor;							// ...the signal targColor will reflect this fact.
		}
	else													// Else we must be on the right of the number line.
		{													// NOTE: based on user input, ignore trials may not... 
		trialType  = ignoreTrial;								// ...exist and the number line may not have anything... 
		signalColor = ignoreColor;						// ...to the right of stopPcts.  (Same holds for...
		}													// ...stop trials above.
		
	if (Classic)											// We are emulating the old stop signal task
		{
		signalColor = fixColor;							// the stop signal is just the fixation point coming back on.
		}
	
	
	// -----------------------------------------------------------------------------------------------
	// Select current SSD
	if (staircase)
		{
		if (!randomAmpFlag)
			{
			spawnwait STAIR(nSSD);
			ssd = ssdArray[decideIndex];			
			}
		else if (randomAmpFlag)
			{
			decideIndex      = decideSSDArray[ampIndex];  // assign the SSD index from the last trial at this discrim level (then update it below)
			lastOutcome = lastStopArray[ampIndex];   // staircasing stop trials independently within each discriminatory level: see REWARDS.pro for when lastStopArray gets updated
			spawnwait STAIR(nSSD);
			ssd = ssdArray[decideIndex];			
			decideSSDArray[ampIndex] = decideIndex;      // update decideSSDArray with the new SSD index within the current proportionIndex
			}
		}
	else
		{
		decideIndex	= random(nSSD);						// get random index
		ssd			= ssdArray[decideIndex]; 				// THIS GLOBAL IS AN ARRAY SO IT CANNOT BE PASSED
		}
		
	}








// --------------------------------------------------------------------------------
// CHOICE COUNTERMANDING TASK
// --------------------------------------------------------------------------------
if (state == stateCCM)		// user wants to run the choice countermanding task
	{
	// -----------------------------------------------------------------------------------------------
	// Pick a choice trial type
		
	acceptTargetFlag = 0;
	while (acceptTargetFlag == 0)
		{
		// Choose a  proportion to use on the current trial, based on assigned trial rates per discrimination level
		randomProp 			= (random(1001))/1000.0;
		// proportionIndex = random(nDiscriminate);
		proportionIndex = 0;
		acceptPropFlag = 0;
		while (acceptPropFlag == 0)
			{
			if (randomProp <= trialRateBound[proportionIndex])
				acceptPropFlag = 1;
			else if (randomProp > trialRateBound[proportionIndex])
				proportionIndex = proportionIndex + 1;
			}
		psyIndex 		= proportionIndex;	  // for upd8_psy.pro
		targ1CheckerProp = targ1PropArray[proportionIndex];
		psyValue 		= targ1CheckerProp;	  // for upd8_psy.pro
		randomProp 			= (random(1001))/1000.0;
		if (targ1CheckerProp == 0.5 &&
			randomProp < fiftyPercentRate)   // Using randoProp random variable to determine whether to run a 50% checker trial
			{
			acceptTargetFlag = 1;
			targIndex = random(nTarg);
			}
		else if (targ1CheckerProp < 0.5 && 
				randomProp > targetRightRate)
			{
			acceptTargetFlag = 1;
			targIndex = targ2;
			}
		else if (targ1CheckerProp > 0.5 && 
				randomProp <= targetRightRate)
			{
			acceptTargetFlag = 1;
			targIndex = targ1;
			}
		}
		
	
	distIndex   = abs(targIndex - 1);						// If target is 0, disttactor is 1, vise versa
	if (random(nTarg) > 1)									// If we're using 4 possible targets, choose one of the sets here
		{
		targIndex = targIndex + 2;
		distIndex = distIndex + 2;
		}
	targAngle 	= angleArray[targIndex];
	distAngle 	= angleArray[distIndex];
	targAmp 	= ampArray[targIndex];
	distAmp 	= ampArray[distIndex];
	
	// Want the checker stimulus in the upper region and 90 degrees from target and distractor
	if (targIndex == 0 | targIndex == 2)
		{
		checkerAngle = targAngle + 90;
		// checkerAngle = targAngle + 75;
		}
	else
		{
		checkerAngle = targAngle - 90;
		// checkerAngle = targAngle - 75;
		}
		
	// If checkerboard serves as a target, figure out whether checkerboard appears at target or distractor location
	// Also set targSize of target and distractor to be equal to targSize of checkerboard
	if (checkerIsTarg == 1)
		{
		targSize 		= iSquareSizePixels * nCheckerColumn / Deg2Pix_Y;
		decideCheckerAngle 			= (random(1001))/1000.0;
		if (decideCheckerAngle < checkerTargRate)   // Using decideTargIndex random variable to determine whether checkerboard appears at target or distractor location
			{			
			checkerTarg = targIndex;
			}
		else
			{
			checkerTarg = distIndex;
			}
		checkerAngle 		= angleArray[checkerTarg];
		}

	
	// -----------------------------------------------------------------------------------------------
	// 2) Pick a go/stop trial type
															// Pick a number and then assess user defined weights to see what type of trial will be presented.
	randomPct 			= (random(10001))/100.0;
															// Think of the if statement below as a number line with user defined divisions (weights).
	if (randomPct <= goPct)						// If we are on the left of the number line...
		{
		trialType = goTrial;									// ...its a go trial.
		}
	else if (randomPct > goPct 
			&& randomPct <= goPct + stopPct)	// If we are in the middle of the number line...
		{
		trialType  = stopTrial;								// ...it is a stop trial, and...
		signalColor = stopColor;							// ...the signal targColor will reflect this fact.
		}
	else													// Else we must be on the right of the number line.
		{													// NOTE: based on user input, ignore trials may not... 
		trialType  = ignoreTrial;								// ...exist and the number line may not have anything... 
		signalColor = ignoreColor;						// ...to the right of stopPcts.  (Same holds for...
		}													// ...stop trials above.
		
	if (Classic)											// We are emulating the old stop signal task
		{
		signalColor = fixColor;							// the stop signal is just the fixation point coming back on.
		}
	
	// -----------------------------------------------------------------------------------------------
	// 5) Select current SSD
	if (trialType == stopTrial | trialType == ignoreTrial)
		{
		if (staircase)
			{
			decideIndex      = decideSSDArray[proportionIndex];  // assign the SSD index from the last trial at this discrim level (then update it below)
			lastOutcome = lastStopArray[proportionIndex];   // staircasing stop trials independently within each discriminatory level: see REWARDS.pro for when lastStopArray gets updated
			spawnwait STAIR(nSSD);
			ssd = ssdArray[decideIndex];			
			decideSSDArray[proportionIndex] = decideIndex;      // update decideSSDArray with the new SSD index within the current proportionIndex
			}
		else
			{
			decideIndex	= random(nSSD);						// get random index
			ssd	= ssdArray[decideIndex]; 				// THIS GLOBAL IS AN ARRAY SO IT CANNOT BE PASSED
			}
		}
	
		
		
	// -----------------------------------------------------------------------------------------------
	// Select current holdtime after target presentation
	
	randomProp 	= (random(1001))/1000.0;				
	if (expoJitterFlag)
		{		
		per_jitter 		= exp(-1.0*(randomProp/.25));	
		}
	else
		{
		per_jitter 	= randomProp;				// random number 0-100 (percentages)
		}
	jitter 			= holdtimeDiff * per_jitter;
	postTargHoldtime 	= round(holdtimeMin + jitter);
	
	
	
	
	// -----------------------------------------------------------------------------------------------
	//  Select current delay (soa) if you want there to be a delay between checkerboard onset and response cue
	if (ccmDelayFlag)
		{
		soa_diff = soaMax - soaMin;
		randomProp 			= (random(1001))/1000.0;
			if (expoJitterFlag_soa)
				{
				per_jitter 		= exp(-1.0*(randomProp/.25));	
				}
			else
				{
				per_jitter 	= randomProp;				// random number 0-100 (percentages)
				}
			jitter 			= soa_diff * per_jitter;
			soa 		= round(soaMin + jitter);
		}
	else
		{
		soa 	 = 0;
		}
		
		
		
	}	// End Choice Countermanding Section








	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

// --------------------------------------------------------------------------------
// GO/NO-GO TASK
// --------------------------------------------------------------------------------
if (state == stateGNG)		// user wants to run the choice countermanding task
	{
	// -----------------------------------------------------------------------------------------------
	// 1) Pick a target

	// targIndex = random(nTarg);						// 	COULD WEIGHT THIS IF NEED BE (see logic below)
		randomProp 	= (random(1001))/1000.0;				
	if (randomProp <= targetRightRate)
		{
		targIndex = 0;						// 	COULD WEIGHT THIS IF NEED BE (see logic below)
		}
	else
		{
		targIndex = 1;
		}
	targAngle = angleArray[targIndex];
	targAmp 		= ampDefault;
	

		
	
	// -----------------------------------------------------------------------------------------------
	// 2) Pick a trial type
															// Pick a number and then assess user defined weights to see what type of trial will be presented.
	randomPct 			= (random(10001))/100.0;
															// Think of the if statement below as a number line with user defined divisions (weights).
	if (randomPct <= goPct)						// If we are on the left of the number line...
		{
		trialType = goTrial;									// ...its a go trial.
		}
	else if (randomPct > goPct 
			&& randomPct <= goPct + nogoPct)	// If we are in the middle of the number line...
		{
		trialType  = nogoTrial;								// ...it is a nogo trial, and...
		// signalColor = nogoColor;							// ...the signal targColor will reflect this fact.
		}
			
	
	
	// -----------------------------------------------------------------------------------------------
	// 3) Pick a go/no-go discrimination level

	if (staircase)
		{
		spawnwait STAIR_DSC();
		}
	else
		{
		// Choose a random proportion to use on the current trial, making sure it agrees with trialType
		agreeFlag = 0;
		while (agreeFlag == 0)
			{		
			useMiddleStimFlag = random(2);
			proportionIndex = random(nDiscriminate);
			psyIndex = proportionIndex;   // for upd8_psy.pro
			goCheckerProp = goPropArray[proportionIndex];
			psyValue = goCheckerProp;	  // for upd8_psy.pro
			if (trialType == goTrial && goCheckerProp > .5)
				{
				agreeFlag = 1;
				}
			else if (trialType == nogoTrial && goCheckerProp < .5)
				{
				agreeFlag = 1;
				}
			else if (goCheckerProp == .5 && useMiddleStimFlag)
				{
				agreeFlag = 1;
				}
			}
		}
		
	

	// printf("Go Square Proportion: %.2d\n", goCheckerProp);



		
		
	// -----------------------------------------------------------------------------------------------
	// 6) Select current holdtime after cue presentation
	
	randomProp 	= (random(1001))/1000.0;				
	if (expoJitterFlag)
		{		
		per_jitter 		= exp(-1.0*(randomProp/.25));	
		}
	else
		{
		per_jitter 	= randomProp;				// random number 0-100 (percentages)
		}
	jitter 			= holdtimeDiff * per_jitter;
	postTargHoldtime 	= round(holdtimeMin + jitter);
	}




	
	
	
	
	
	
	
	
	
	





// --------------------------------------------------------------------------------------------------------
// METACOGNITION TASKS (REVERSE MASKING AND BETS)
// --------------------------------------------------------------------------------------------------------
if (state == stateMCM)		
	{
	// -----------------------------------------------------------------------------------------------
	// Set trial type: use a random percentage and determine which trial type distribution it falls in
	randomPct 			= (random(10001))/100.0;
	if (randomPct < maskPct)
		{
		trialType = tMaskTrial;
		}
	else if (randomPct >= maskPct && 
			randomPct < (maskPct + BetPct))
		{
		trialType = tBetTrial;
		targWinSize = 0;
		// If it's a bet-only trial, need to assign a random mask decision outcome so bet targets get values
		randomProp 			= (random(1001))/1000.0;
		if (randomProp <= fakeCorrectRate)
			{
			maskOutcome = saccTarg;
			}
		else
			{
			maskOutcome = saccDist;
			}		
		}	
	else if (randomPct >= (maskPct + BetPct) && 
			randomPct <= (maskPct + BetPct + retroPct))
		{
		trialType = tRetroTrial;
		}	
	else if (randomPct > maskPct + BetPct + retroPct) 
		{
		trialType = tProTrial;
		}	


	
	// -----------------------------------------------------------------------------------------------
	// Set target location (where one mask target will appear)
	targAmp 		= ampDefault;
	i = 0;
	while (i < nTarg)
		{
		maskAmpArray[i] = targAmp;
		i = i + 1;
		}
	

	if (trialType != tBetTrial)
		{
		randomProp 	= (random(1001))/1000.0;
		// If there are 2 possible target locations, probabilistically assign target to one hemifield and low bet to the other
		// If there are 4 possible target locations, need to consider that more than one target is in each hemifield (see below)
		if (nTarg == 2)
			{
			if (randomProp <= targetRightRate)	
				{
				targIndex = 0;
				}
			else
				{
				targIndex = 1;
				}
			}
		else if (nTarg == 4)
			{
			if (randomProp <= targetRightRate)	
				{
				targIndex = random(2);
				}
			else
				{
				targIndex = random(2) + 2;
				}
			}
		targAngle = maskAngleArray[targIndex];


		// -----------------------------------------------------------------------------------------------
		// Set distractor locations (where the other mask targets will appear)
		if (nTarg == 2)
			{
			distIndex1 = abs(targIndex - 2);
			}
		else if (nTarg == 4)    // This is not elegant- should change this to an array-based method of assigning distractor indices
			{
			if (targIndex == 0)
				{
				distIndex1 = 1;
				distIndex2 = 2;
				distIndex3 = 3;
				}
			else if (targIndex == 1)
				{
				distIndex1 = 0;
				distIndex2 = 2;
				distIndex3 = 3;
				}
			else if (targIndex == 2)
				{
				distIndex1 = 0;
				distIndex2 = 1;
				distIndex3 = 3;
				}
			else if (targIndex == 3)
				{
				distIndex1 = 0;
				distIndex2 = 1;
				distIndex3 = 2;
				}
			}
		}	 // if (trialType != tBetTrial)								 
	
	// -----------------------------------------------------------------------------------------------
	// Set bet target locations
	
	if (trialType != tMaskTrial)
		{
		randomProp 	= (random(1001))/1000.0;
		// If there are 2 possible target locations, probabilistically assign high bet to one hemifield and low bet to the other
		// If there are 4 possible target locations, need to consider that more than one target is in each hemifield (see below)
		if (nTarg == 2)
			{
			if (randomProp <= highBetRightRate)	
				{
				highBetIndex = 0;
				}
			else
				{
				highBetIndex = 1;
				}
			lowBetIndex = abs(highBetIndex - 2);
			}
		else if (nTarg == 4)
			{
			if (randomProp <= highBetRightRate)	
				{
				highBetIndex = random(2);
				lowBetIndex = highBetIndex + 2;
				}
			else
				{
				highBetIndex = random(2) + 2;
				lowBetIndex = highBetIndex - 2;
				}
			}
		highBetAmp		= targAmp;
		lowBetAmp	 	= targAmp;
		highBetAngle = maskAngleArray[highBetIndex];
		lowBetAngle = maskAngleArray[lowBetIndex];

		// -----------------------------------------------------------------------------------------------
		// Select bet-fixation hold time
		
			randomProp 	= (random(1001))/1000.0;				
			if (expoJitterFlag)
				{		
				per_jitter 		= exp(-1.0*(randomProp/.25));	
				}
			else
				{
				per_jitter 	= randomProp;				// random number 0-100 (percentages)
				}
			jitter 			= holdtimeDiff * per_jitter;
			preBetHoldtime 	= round(holdtimeMin + jitter);
		} //if (trialType != tMaskTrial)
										 

	
	// -----------------------------------------------------------------------------------------------
	// Set SOA
	if (trialType != tBetTrial)
		{
		if (staircase)
			{
			decideIndex      = decideSOAArray[targIndex];  // assign the SOA index from the last trial at this discrim level (then update it below)
			lastOutcome = lastMaskArray[targIndex];   // staircasing soa independently within each target position: see REWARDS.pro for when lastMaskArray gets updated
			spawnwait STAIR(nSOA);
			decideSOAArray[targIndex] = decideIndex;      // update decideSSDArray with the new SSD index within the current proportionIndex
			}
		else
			{
			decideIndex	= random(nSOA);						// get random index
			}
		soa	= soaArray[decideIndex]; 				// THIS GLOBAL IS AN ARRAY SO IT CANNOT BE PASSED

		
	// -----------------------------------------------------------------------------------------------
	// Select holdtime after cue presentation
	
		randomProp 	= (random(1001))/1000.0;				
		if (expoJitterFlag)
			{		
			per_jitter 		= exp(-1.0*(randomProp/.25));	
			}
		else
			{
			per_jitter 	= randomProp;				// random number 0-100 (percentages)
			}
		jitter 			= holdtimeDiff * per_jitter;
		postTargHoldtime 	= round(holdtimeMin + jitter);


	// -----------------------------------------------------------------------------------------------
	// Select prospective trial (2nd mask appearence) hold time
		
		if (trialType == tProTrial)
			{
			randomProp 	= (random(1001))/1000.0;				
			if (expoJitterFlag)
				{		
				per_jitter 		= exp(-1.0*(randomProp/.25));	
				}
			else
				{
				per_jitter 	= randomProp;				// random number 0-100 (percentages)
				}
			jitter 			= holdtimeDiff * per_jitter;
			preProHoldtime 	= round(holdtimeMin + jitter);
			}
				
		} // if (trialType != tBetTrial)
		
		
		
	} // if (state == stateMCM)		


	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	// --------------------------------------------------------------------------------
// VWMtask
// --------------------------------------------------------------------------------
if (state == stateVWM)
	{
	// -----------------------------------------------------------------------------------------------
	// 1) Pick a target
	
	
	acceptTargetFlag = 0;
	targAmp 		= ampDefault*.65;//.75 for C ub rig 029ampDefault;
	acceptCondFlag = 0;
	
	acceptLocFlag = 0;
	while (acceptTargetFlag == 0)
		{
		//condition selection
		while (acceptCondFlag == 0)
			{
			condIndex = random(12);
			if(condCounterArray[condIndex]<nTrialsArray[condIndex])
				{
				
				acceptCondFlag = 1;
				
				setsize = setSizeArray[condIndex];
				samediff = sameDiffArray[condIndex];

				}
			}
		//color selection
		color_counter =0; 
		//initialize the nColorsArray
		nColorsArray[0] = 0;
		nColorsArray[1] = 0;
		nColorsArray[2] = 0;
		nColorsArray[3] = 0;
		nColorsArray[4] = 0;
		nColorsArray[5] = 0;
		nColorsArray[6] = 0;
		nColorsArray[7] = 0;
		while (color_counter <5) // upto set size 4 due to color similarity
			{
			acceptColorFlag = 0;
			while (acceptColorFlag == 0)
				{
				colorIndex = random(5);
				if(nColorsArray[colorIndex]<1)
					{
					acceptColorFlag = 1;
					nColorsArray[colorIndex]=1;
					}
				}
			if (color_counter<setsize)		
				{
				ColorArray[color_counter]=247-colorIndex;
				}
			else if (color_counter == 5) //set the diff color
				{
				ColorArray[color_counter]=247-colorIndex;
				}
			else //set it to the background color
				{
				ColorArray[color_counter]=blackColor;//background black!
				}
			
			
			color_counter = color_counter+1;
			}
			
		// lorr = random(2);
		// if (lorr == 0)
			// {
		
			// ColorArray[0] = 244;
			// ColorArray[1] = 245;
			// ColorArray[2] = blackColor;
			// ColorArray[3] = blackColor;
			// ColorArray[4] = blackColor;
			// ColorArray[5] = blackColor;
			// }
		// if (lorr == 1)
			// {
			// ColorArray[0] = 245;
			// ColorArray[1] = 244;
			// ColorArray[2] = blackColor;
			// ColorArray[3] = blackColor;
			// ColorArray[4] = blackColor;
			// ColorArray[5] = -blackColor;
			
			// }
			
		
		//Loc selection
		loc_counter =0; 
		//initialize the nLocsArray
		nLocsArray[0] = 0;
		nLocsArray[1] = 0;
		nLocsArray[2] = 0;
		nLocsArray[3] = 0;
		nLocsArray[4] = 0;
		nLocsArray[5] = 0;
		nLocsArray[6] = 0;
		nLocsArray[7] = 0;
		
		//below is for 2 locs!	
		 //while (loc_counter <2)
			 //{
			 //acceptLocFlag = 0;
			 //while (acceptLocFlag == 0)
				 //{
				 //locIndex = random(2);
				 //if(nLocsArray[locIndex]<1)
					 //{
					 //acceptLocFlag = 1;
					 //nLocsArray[locIndex]=1;
					//
					 //}
				//
				// }
			 //LocArray[loc_counter]=vwmAngleArray[locIndex];
			 //loc_counter = loc_counter+1;
			//		
			//
			 //}
		
		//below is for 4 locs!	
		while (loc_counter <4)
			{
			acceptLocFlag = 0;
			while (acceptLocFlag == 0)
				{
				locIndex = random(4);
				if(nLocsArray[locIndex]<1)
					{
					acceptLocFlag = 1;
					nLocsArray[locIndex]=1;
					
					}
				
				}
			LocArray[loc_counter]=vwmAngleArray[locIndex];
			loc_counter = loc_counter+1;
			
			
			}
		
		//below is for 8 locs!	
		// while (loc_counter <6)
			// {
			// acceptLocFlag = 0;
			// while (acceptLocFlag == 0)
				// {
				// locIndex = random(8);
				// if(nLocsArray[locIndex]<1)
					// {
					// acceptLocFlag = 1;
					// nLocsArray[locIndex]=1;
					
					// }
				
				// }
			// LocArray[loc_counter]=vwmAngleArray[locIndex];
			// loc_counter = loc_counter+1;
					
			
			// }


		
		
			
		if (samediff == 1) //same
			{
			testColor = ColorArray[0];
			targAngle = LocArray[0];
			testAmp = targAmp;
				
			}
		else if (samediff == 2) //diff
			{
			testColor = ColorArray[6];
			targAngle = 0;
			testAmp = fixAmp;
			}

		

		acceptTargetFlag = 1;
		printf("Color = %d\n",ColorArray[0]);
		printf("Loc = %d\n",LocArray[0]);
		printf("targAngle = %d\n",targAngle);
		
		//printf("Color = %d\n",ColorArray[2]);
		//printf("Color = %d\n",ColorArray[3]);
		//printf("Color = %d\n",ColorArray[4]);
		//printf("Color = %d\n",ColorArray[5]);
		//printf("Color = %d\n",ColorArray[6]);
		} //if state = VWMstate

	}

}

// simple 1, 2, or 3 up down staircasing algorithm
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011

				
declare STAIR(int nIndex);
			
process STAIR(int nIndex)
	{
	declare hide int	plus_minus;
	declare int			randStep;
	
	// For simple countermanding, make the step larger to make SSD less predictable. Otherwise, use smaller step
	if (state == stateCMD)
		{
		randStep = 2;
		}
	else
		{
		randStep = 1;
		// randStep = 0;
		}
		
		
	if (decideIndex == -1)
	{
		decideIndex = random(randStep) + 1;					// Sorry for weirdness.  See above.
	}
	
												// 1) figure out the random SSD step for the next trial
	plus_minus = 1 + random(randStep);  				// pick a number 1 or 2
	if (state == stateMCM)
		{
		plus_minus = -plus_minus;
		}
	
												// 2) add or subtrace SSD steps based on last trial performance.
	if (lastOutcome == success)
		{
		decideIndex = decideIndex + plus_minus; 	// increase SSD to make it harder
		}
	else if (lastOutcome == failure)
		{
		decideIndex = decideIndex - plus_minus; 	// decrease SSD to make it easier
		}
	
												// 3) set to limits if we went out of bounds
	if (decideIndex > nIndex - 1)
		{
		decideIndex = nIndex - 1;
		}
	if (decideIndex < 0)
		{
		decideIndex = 0;
		}
		

	}// simple 1, 2, or 3 up down staircasing algorithm
//
// 04-17-2012: created  -pgm

				
declare STAIR_DSC();
			
process STAIR_DSC()
	{
	declare hide int	plus_minus;
	declare int 		lowBound;
	declare int 		hiBound;
	declare hide int  	goTrial 		= 0;				// label these so they are easier to read below
	declare hide int  	nogoTrial 	= 1;				// label these so they are easier to read below
	
	// 1) figure out the random proportionIndex step for the next trial
	//-------------------------------------------
	plus_minus = 1 + random(3);  				// pick a number 1, 2, or 3
	
	
	
	// 3) establish bounds of increasing/decreasing the difficulty
	//-------------------------------------------
	if (trialType == goTrial)
		{
		hiBound 	= nDiscriminate - 1;
		lowBound	= (nDiscriminate / 2) + 1 - 1;
		}
	else if (trialType == nogoTrial)
		{
		hiBound = (nDiscriminate / 2) - 1 - 1;
		lowBound = 0;
		}


	// 2) add or subtract plus_minus steps based on last trial performance, respecting the bounds
	//-------------------------------------------
	if (lastoutcome == success && trialType == goTrial)
		{	
		proportionIndex = proportionIndex - plus_minus; 	// decrease PSY to make it harder
		if (proportionIndex < lowBound)
			{
			proportionIndex = hiBound;
			}		
		}
	else if (lastoutcome == failure && trialType == goTrial)
		{	
		proportionIndex = proportionIndex + plus_minus; 	// increase PSY to make it easier
		if (proportionIndex > hiBound)
			{
			proportionIndex = hiBound;
			}		
		}
	else if (lastoutcome == success && trialType == nogoTrial)
		{	
		proportionIndex = proportionIndex + plus_minus; 	// increase PSY to make it harder
		if (proportionIndex > hiBound)
			{
			proportionIndex = hiBound;
			}		
		}
	else if (lastoutcome == failure && trialType == nogoTrial)
		{	
		proportionIndex = proportionIndex - plus_minus; 	// decrease PSY to make it easier
		if (proportionIndex < lowBound)
			{
			proportionIndex = hiBound;
			}		
		}
	
	
	}//------------------------------------------------------------------------
// process STIM(int channel, int duration)
// Deliver a STIM reward to the animal
// INPUT
//	 channel  = rig specific TTL channel connected to solenoid (channel 9 in 028)
//	 duration = amount of time (in ms) to leave solenoid open
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011

declare STIM(int channel, int duration);

process STIM(int channel, int duration)
	{
	declare hide int open   = 1;	
	declare hide int closed = 0;	
	
	mio_dig_set(channel,open);		// Start sending the TTL
	wait(duration);					// Wait for user defined period of time (ms)
	mio_dig_set(channel,closed);	// Stop sending the TTL

			printf("STIMULATION\n");						// ...tell the user whats up...
	Event_fifo[Set_event] = Stimulation_;		// queue strobe, and ...
	Set_event = (Set_event + 1) % Event_fifo_N;	// ...incriment event queue.
	}//Made this its own process so that I can fire a sound off from the
//server without pausing to wait for the sound to end.
//Can be used as a warning tone to alert the operator that the animal
//is doing something wrong.

declare SVR_BEL2();

process SVR_BEL2()
	{
	
	sound(4000);
	wait 100;
	sound(0);
	
	}
//Made this its own process so that I can fire a sound off from the
//server without pausing to wait for the sound to end.
//Can be used as a warning tone to alert the operator that the animal
//is doing something wrong.

declare SVR_BELL();

process SVR_BELL()
	{	
	
	sound(250);
	wait 50;
	sound(0);
	
	sound(500);
	wait 50;
	sound(0);
	
	sound(1000);
	wait 50;
	sound(0);
	
	sound(2000);
	wait 50;
	sound(0);
	
	sound(4000);
	wait 50;
	sound(0);
	
	sound(8000);
	wait 50;
	sound(0);
	
	sound(16000);
	wait 50;
	sound(0);
	
	sound(32000);
	wait 50;
	sound(0);
	
	sound(64000);
	wait 50;
	sound(0);
	
	}
; TEMPO GRAPH CONFIGURATION FILE
; Copyright 1997-2017 Reflective Computing.  All Rights Reserved.
; This file was created by TEMPO and should not be edited directly by the user.
; The commands in this file are undocumented and subject to change in future releases.
; Thu Feb 02 16:42:24 2017
; GLOAD tempo.gcf


; WINDOW CONFIGURATION

SCREENRES 1280,1024,32,1,0,0
MAINWND 1,-1,-1,-1,-1,1,-1,912,53,0

CMDWND 1,-1,-1,-1,-1,3,911,618,968,0

; DATABASES PAGES & VIEWS

DBPCOLORS 0x0,0x0,0x0,0x0,0x0

; END GRAPH CONFIGURATION

//------------------------------------------------------------------------
// process Tone(int frequency, int duration)
// Play a tone for the specified frequency and duration
// INPUT
//	 frequency = frequency of tone (hz) to be played
//	 duration  = amount of time (in ms) to pay tone
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011

declare TONE(int frequency, int duration);

process TONE(int frequency, int duration)
	{
	declare hide count;			// Count down for the pulse generator to change state (see below)
	declare hide int off = 0;	// To turn tone off at end
	
	/*  A call to the PCI-DAS-1602 analog pulse generator is in the 
		form of...
		mio_fout(count) 
		where "count" specifies a count down in 10 MHz clock cycles 
		before the square wave switches states.
		Converting that to frequency is done by...
		frequency(Hz) = 10,000,000 / count
		therefore...
		count = 10,000,000 / frequency(Hz)
	*/
	count = 10000000/frequency; // See above
	mio_fout(count);			// Start sending the tone
	wait(duration);				// Wait for user defined period of time (ms)
	mio_fout(off);				// Stop sending the tone
	}//------------------------------------------------------------------------
// process TONESWEP()
// Play something which can be differentiated from a task relevant pure
// tone.
//
// written by david.c.godlove@vanderbilt.edu 	Sept, 2011

declare TONESWEP();

process TONESWEP()
	{
	spawnwait TONE(64000,10);
	
	spawnwait TONE(32000,10);
	
	spawnwait TONE(16000,10);
	
	spawnwait TONE(8000,10);
	
	spawnwait TONE(4000,10);
	
	spawnwait TONE(2000,10);
	
	spawnwait TONE(1000,10);
	
	spawnwait TONE(500,10);
	
	spawnwait TONE(250,10);	
	}// Updates inhibition function in the animated graph online. 
// NOTE: SET_INH must have been run already to set inhibition
// function graph up.  Needed for global objects.
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011

declare UPD8_INH();

process UPD8_INH()
	{
	declare int ct;
	declare float hide weight;
	declare float hide change_value;
	declare int hide position_x;
	declare float hide position_y[12];  // nSSD = 12, but nSSD isn't initialized yet so we have to use 12 here
	declare float hide ct_ssd[12];		// ditto
	
	ct = 0;
	if (FirstStopTrial == 1)
		{
		while(ct < nSSD)
			{
			position_y[ct] = 0;
			ct_ssd[ct] = 0;
			ct = ct + 1;
			FirstStopTrial = 0;
			}
		}
	
	if (lastOutcome == success)
		{
		change_value = 0;
		}
	else if(lastOutcome == failure)
		{
		change_value = 1000;
		}
		
	
	position_x = (ssd * 1000.0/screenRefreshRate) * 1000;	

	weight = 1.0 / (ct_ssd[decideIndex] + 1.0);
	position_y[decideIndex] = ((1 - weight) * position_y[decideIndex]) + (change_value * weight);
	ct_ssd[decideIndex] = ct_ssd[decideIndex] + 1;

		
	//---------------------------------------------------------------------
	// SSD 0		
	if (ssd == ssdArray[0])
		{
		oSetAttribute(object_ssd0,aFILLED);
		oSetAttribute(object_ssd0,aVISIBLE);
		oMove(object_ssd0,position_x,position_y[0]);	
		}
	//---------------------------------------------------------------------
	// SSD 1		
	if (ssd == ssdArray[1])
		{
		oSetAttribute(object_ssd1,aFILLED);
		oSetAttribute(object_ssd1,aVISIBLE);
		oMove(object_ssd1,position_x,position_y[1]);	
		}
	//---------------------------------------------------------------------
	// SSD 2		
	if (ssd == ssdArray[2])
		{
		oSetAttribute(object_ssd2,aFILLED);
		oSetAttribute(object_ssd2,aVISIBLE);
		oMove(object_ssd2,position_x,position_y[2]);	
		}
	//---------------------------------------------------------------------
	// SSD 3		
	if (ssd == ssdArray[3])
		{
		oSetAttribute(object_ssd3,aFILLED);
		oSetAttribute(object_ssd3,aVISIBLE);
		oMove(object_ssd3,position_x,position_y[3]);	
		}
	//---------------------------------------------------------------------
	// SSD 4		
	if (ssd == ssdArray[4])
		{
		oSetAttribute(object_ssd4,aFILLED);
		oSetAttribute(object_ssd4,aVISIBLE);
		oMove(object_ssd4,position_x,position_y[4]);	
		}
	//---------------------------------------------------------------------
	// SSD 5		
	if (ssd == ssdArray[5])
		{
		oSetAttribute(object_ssd5,aFILLED);
		oSetAttribute(object_ssd5,aVISIBLE);
		oMove(object_ssd5,position_x,position_y[5]);	
		}
	//---------------------------------------------------------------------
	// SSD 6		
	if (ssd == ssdArray[6])
		{
		oSetAttribute(object_ssd6,aFILLED);
		oSetAttribute(object_ssd6,aVISIBLE);
		oMove(object_ssd6,position_x,position_y[6]);	
		}
	//---------------------------------------------------------------------
	// SSD 7		
	if (ssd == ssdArray[7])
		{
		oSetAttribute(object_ssd7,aFILLED);
		oSetAttribute(object_ssd7,aVISIBLE);
		oMove(object_ssd7,position_x,position_y[7]);	
		}
	//---------------------------------------------------------------------
	// SSD 8		
	if (ssd == ssdArray[8])
		{
		oSetAttribute(object_ssd8,aFILLED);
		oSetAttribute(object_ssd8,aVISIBLE);
		oMove(object_ssd8,position_x,position_y[8]);	
		}
	//---------------------------------------------------------------------
	// SSD 9		
	if (ssd == ssdArray[9])
		{
		oSetAttribute(object_ssd9,aFILLED);
		oSetAttribute(object_ssd9,aVISIBLE);
		oMove(object_ssd9,position_x,position_y[9]);	
		}
	//---------------------------------------------------------------------
	// SSD 10		
	if (ssd == ssdArray[10])
		{
		oSetAttribute(object_ssd10,aFILLED);
		oSetAttribute(object_ssd10,aVISIBLE);
		oMove(object_ssd10,position_x,position_y[10]);	
		}
	//---------------------------------------------------------------------
	// SSD 11		
	if (ssd == ssdArray[11])
		{
		oSetAttribute(object_ssd11,aFILLED);
		oSetAttribute(object_ssd11,aVISIBLE);
		oMove(object_ssd11,position_x,position_y[11]);	
		}
	//
	}// Updates psychometric function in the animated graph online. 
// NOTE: SET_GNG must have been run already to set inhibition
// function graph up.  Needed for global objects.
//
// 04-17-2012:  adapted from UPD8_INH.pro  -pgm


declare UPD8_PSY();

process UPD8_PSY()
	{
	declare int ct;
	declare int hide position_x;
	declare float hide position_y[10];
	
	ct = 0;
	if (FirstTrial == 1)
		{
		while(ct<10)
			{
			position_y[ct] = 0;
			nPsy[ct] = 0;
			ct = ct + 1;
			FirstTrial = 0;
			}
		}

	// Specific graphs for specific tasks:
	if (state == stateGNG)
		{
		if(trialOutcome == goTarg ||					// For choice RT pcychometric function
			trialOutcome == nogoCorrect ||
			trialOutcome == goIncorrect ||
			trialOutcome == nogoTarg)									
			{
			nPsy[psyIndex] = nPsy[psyIndex] + 1;
			printf("nPsy: %d\n", nPsy[psyIndex]);
			// Increment the number of trials with a response at this discriminatory level
			if (trialOutcome == nogoTarg ||
				trialOutcome == goTarg)
				{
				nPsyRespond[psyIndex] = nPsyRespond[psyIndex] + 1;
				}
			}
		}
	else if (state == stateCCM)
		{
		if(trialOutcome == goTarg ||					// For choice RT pcychometric function
			trialOutcome == goDist)							
			{
			nPsy[psyIndex] = nPsy[psyIndex] + 1;
			// printf("nPsy: %d\n", nPsy[psyIndex]);
			// Increment the rightward response tally at this discriminatory level if necessary 
			if ((targIndex == targ1 &&
				trialOutcome == goTarg) ||
				(targIndex == targ1 + 2 &&
				trialOutcome == goTarg) ||
				(targIndex == targ2 && 
				trialOutcome == goDist) ||
				(targIndex == targ2 + 2 && 
				trialOutcome == goDist))
				{
				nTarg1Respond[psyIndex] = nTarg1Respond[psyIndex] + 1;
				}
				// printf("psyIndex: %d   Targ1 responses: %d   ", psyIndex, nTarg1Respond[psyIndex]);
			}
		}
	// Increment the total number of trials at this discriminatory level
	//nPsy[psyIndex] = nPsy[psyIndex] + 1;
			// printf("nPsy: %d\n", nPsy[psyIndex]);
		
	
	position_x = psyValue * 1000;

	if (state == stateGNG)
		{
		position_y[psyIndex] = 1000 * nPsyRespond[psyIndex] / nPsy[psyIndex];
		}
	else if (state == stateCCM)
		{
		position_y[psyIndex] = 1000 * nTarg1Respond[psyIndex] / nPsy[psyIndex];
		}
		

		
	//---------------------------------------------------------------------
	// GO Proportion 0		
	if ((state == stateGNG && psyValue == goPropArray[0]) ||
		(state == stateCCM && psyValue == targ1PropArray[0]))
		{
		oSetAttribute(object_psy0,aFILLED);
		oSetAttribute(object_psy0,aVISIBLE);
		oMove(object_psy0,position_x,position_y[0]);	
		}
	//---------------------------------------------------------------------
	// GO Proportion 1		
	if ((state == stateGNG && psyValue == goPropArray[1]) ||
		(state == stateCCM && psyValue == targ1PropArray[1]))
		{
		oSetAttribute(object_psy1,aFILLED);
		oSetAttribute(object_psy1,aVISIBLE);
		oMove(object_psy1,position_x,position_y[1]);	
		}
	//---------------------------------------------------------------------
	// GO Proportion 2		
	if ((state == stateGNG && psyValue == goPropArray[2]) ||
		(state == stateCCM && psyValue == targ1PropArray[2]))
		{
		oSetAttribute(object_psy2,aFILLED);
		oSetAttribute(object_psy2,aVISIBLE);
		oMove(object_psy2,position_x,position_y[2]);	
		}
	//---------------------------------------------------------------------
	// GO Proportion 3		
	if ((state == stateGNG && psyValue == goPropArray[3]) ||
		(state == stateCCM && psyValue == targ1PropArray[3]))
		{
		oSetAttribute(object_psy3,aFILLED);
		oSetAttribute(object_psy3,aVISIBLE);
		oMove(object_psy3,position_x,position_y[3]);	
		}
	//---------------------------------------------------------------------
	// GO Proportion 4		
	if ((state == stateGNG && psyValue == goPropArray[4]) ||
		(state == stateCCM && psyValue == targ1PropArray[4]))
		{
		oSetAttribute(object_psy4,aFILLED);
		oSetAttribute(object_psy4,aVISIBLE);
		oMove(object_psy4,position_x,position_y[4]);	
		}
	//---------------------------------------------------------------------
	// GO Proportion 5		
	if ((state == stateGNG && psyValue == goPropArray[5]) ||
		(state == stateCCM && psyValue == targ1PropArray[5]))
		{
		oSetAttribute(object_psy5,aFILLED);
		oSetAttribute(object_psy5,aVISIBLE);
		oMove(object_psy5,position_x,position_y[5]);	
		}
	//---------------------------------------------------------------------
	// GO Proportion 6		
	if ((state == stateGNG && psyValue == goPropArray[6]) ||
		(state == stateCCM && psyValue == targ1PropArray[6]))
		{
		oSetAttribute(object_psy6,aFILLED);
		oSetAttribute(object_psy6,aVISIBLE);
		oMove(object_psy6,position_x,position_y[6]);	
		}
	//---------------------------------------------------------------------
	// GO Proportion 7		
	if ((state == stateGNG && psyValue == goPropArray[7]) ||
		(state == stateCCM && psyValue == targ1PropArray[7]))
		{
		oSetAttribute(object_psy7,aFILLED);
		oSetAttribute(object_psy7,aVISIBLE);
		oMove(object_psy7,position_x,position_y[7]);	
		}
	//---------------------------------------------------------------------
	// GO Proportion 8		
	if ((state == stateGNG && psyValue == goPropArray[8]) ||
		(state == stateCCM && psyValue == targ1PropArray[8]))
		{
		oSetAttribute(object_psy8,aFILLED);
		oSetAttribute(object_psy8,aVISIBLE);
		oMove(object_psy8,position_x,position_y[8]);	
		}
	//---------------------------------------------------------------------
	// GO Proportion 9		
	if ((state == stateGNG && psyValue == goPropArray[9]) ||
		(state == stateCCM && psyValue == targ1PropArray[9]))
		{
		oSetAttribute(object_psy9,aFILLED);
		oSetAttribute(object_psy9,aVISIBLE);
		oMove(object_psy9,position_x,position_y[9]);	
		}
	}//--------------------------------------------------------------------------------------------------
// process VIS_PGS();
//
// Figure out all stimuli that will be needed on the next visually guided saccade trial and
// place it all into video memory.


declare VIS_PGS();                       										// see GRAPHS.pro

process VIS_PGS()	                       										// see GRAPHS.pro
{										
										
// number the pgs that need to be drawn
declare hide int   	blank       		= 0;	
declare hide int	pd					= 1;
declare hide int	fixation_pd			= 2;										
declare hide int	fixation    		= 3;
declare hide int	target_pd			= 4;	
declare hide int	target		   		= 5;										

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Calculate screen coordinates for stimuli on this trial								
if (AutoTargetSizeFlag)
	{
	targSize        	 	= targAmp * TargetSizeConversion;   			// Figure out the attributes of the current target
	}
else
	{
	targSize				= sizeArray[targIndex];
	}
targColor        = targIndex + 1;																// zero is reserved for black.  see SET_CLRS.pro							
												

opposite = ((screenHeight/2)-pdBottom);														// Figure out angle and eccentricity of photodiode marker in pixels
adjacent = ((screenWidth/2)-pdLeft);                                                         // NOTE: I am assuming your pd is in the lower left quadrant of your screen
pdAmp = sqrt((opposite * opposite) + (adjacent * adjacent));
pdAngle = rad2deg(atan (opposite / adjacent));
pdAngle = pdAngle + 180; 																	//change this for different quadrent or write some code for flexibility

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 1
// print("photodiode");
dsendf("rw %d,%d;\n",pd,pd);				 												// draw first pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker	
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 2
// print("fixation with photodiode");
dsendf("rw %d,%d;\n",fixation_pd,fixation_pd); 												// draw second pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 3	  
// print("fixation");
dsendf("rw %d,%d;\n",fixation,fixation);   													// draw 3rd pg of video memory                                       
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 4	  
// print("fixation target and photodiode");
dsendf("rw %d,%d;\n",target_pd,target_pd);   								// draw 4th pg of video memory                                       
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);          	// draw target
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 5	  
// print("target");
dsendf("rw %d,%d;\n",target,target);  														// draw pg 6                                        
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(targSize, targAngle, targAmp, targColor, fill, deg2pix_X, deg2pix_Y);         	// draw target
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
// Draw pg 0 (last is displayed first)	
// print("blank"); 																			
dsendf("rw %d,%d;\n",blank,blank);                                          				// draw the blank screen last so that it shows up first
dsendf("cl:\n");                                                                            // clear screen (that's all)

}
//--------------------------------------------------------------------------------------------
// Run a memory guided saccade trial based on the variables calculated by SETV_TRL.pro and 
// those given by the user.  Adapted from CMDTRIAL.
//
// 11-2011: Created by adapting MEMTRIAL.pro -pgm


declare VISTRIAL();	
	
process VISTRIAL()        	
	{
	
	
	// Number the trial stages to make them easier to read below
	declare hide int 	need_fix  	= 1;
	declare hide int 	fixating  	= 2;
	declare hide int 	targ_on   	= 3;
	declare hide int	fix_off		= 4;
	declare hide int 	in_flight 	= 5;
	declare hide int 	on_target 	= 6;	
	declare hide int 	stage;
	
	// Number the stimuli pages to make reading easier
	declare hide int   	blank       		= 0;
	declare hide int	pd					= 1;
	declare hide int	fixation_pd 		= 2;
	declare hide int	fixation    		= 3;
	declare hide int	target_pd   		= 4;	
	declare hide int	target      		= 5;
	
	  
	// Timing variables which will be used to time task
	declare hide float 	fix_on_time; 	
	declare hide float 	aquire_fix_time;
	declare hide float  targ_time;	
	declare hide float  saccade_time;
	declare hide float	aquire_targ_time;	
	
	
	// Have to be reset on every iteration since 
	// variable declaration only occurs at load time
	trl_running 		= 1;
	stage 				= need_fix;
	
	// Tell the user what's up
	printf(" \n");
	printf("# %d\n",nTrial);

	
	
																			// HERE IS WHERE THE FUN BEGINS
	Event_fifo[Set_event] = TrialStart_;									// queue TrialStart_ strobe
	Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
	dsendf("vp %d\n",fixation_pd);											// flip the pg to the fixation stim with pd marker
	fix_on_time = time();  													// record the time
	Event_fifo[Set_event] = FixSpotOn_;										// queue strobe
	Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
	dsendf("XM RFRSH:\n"); 													// wait for one retrace
	dsendf("vp %d\n",fixation);												// flip the pg to the fixation stim without pd marker
	oSetAttribute(object_fix, aVISIBLE); 									// turn on the fixation point in animated graph
	
	
	while (trl_running)														// trials ending will set trl_running = 0
		{	
		
	//--------------------------------------------------------------------------------------------
	// STAGE need_fix (the fixation point is on, but the subject hasn't looked at it)
		if (stage == need_fix)
			{		
			if (In_FixWin)													// If the eyes have entered the fixation window (before time, see below)...
				{
				aquire_fix_time = time();									// ...function call to time to note current time and...
				trialStartTime = aquire_fix_time;							// Global output for timing iti
				Event_fifo[Set_event] = Fixate_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				stage = fixating;											// ...advance to the next stage.
				}
			else if (time() > fix_on_time + allowFixTime)				// But if time runs out...
				{
				trialOutcome = noFix;    									// TRIAL OUTCOME ABORT (no fixation)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen,...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Aborted (no fixation)\n");							// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}			
			}
			
			

	//--------------------------------------------------------------------------------------------
	// STAGE fixating (the subject is looking at the fixation point waiting for target onset)		
		else if (stage == fixating)
			{
			if (!In_FixWin && time() > aquire_fix_time + 100)													// If the eyes stray out of the fixation window...
				{
				trialOutcome = brokeFix;									// TRIAL OUTCOME ABORT (broke fixation)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}
			else if (In_FixWin && time() > aquire_fix_time + preTargHoldtime)	// But if the eyes are still in the window at end of holdtime...
				{
				dsendf("vp %d\n",target_pd);						// ...flip the pg to the target with pd marker...	
				targ_time = time(); 										// ...record the time...
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				dsendf("vp %d\n",target);							// ...flip the pg to the target point without pd marker.
		
					
		
				oSetAttribute(object_targ, aVISIBLE); 						// ...show target in animated graph...
														
				stage = targ_on;											// Advance to the next trial stage.				
				}
			}
			
			

	//--------------------------------------------------------------------------------------------
	// STAGE targ_on (the target has been presented but the subject is still fixating)		
		else if (stage == targ_on)
			{		
			if (!In_FixWin)													// If the eyes leave the fixation window...			
				{															// ...we have a saccade, so...
				saccade_time = time();										// ...record the time...
				Event_fifo[Set_event] = Saccade_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				printf("                          rt = %d\n",saccade_time - targ_time);	// ...tell the user whats up...
				stage = in_flight;											// ...and advance to the next stage.
				}
			
			else if (In_FixWin &&  											// But if no saccade occurs...
				time() > targ_time + saccTimeMax) 					// ...and time for a saccade runs out...
				{
				trialOutcome = noSacc;           							// TRIAL OUTCOME ERROR (no saccade after cue)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (no saccade)\n");								// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}	
			}


			
			
	//--------------------------------------------------------------------------------------------
	// STAGE in_flight (eyes have left fixation window but have not entered target window)		
		else if (stage == in_flight)
			{
			if (In_TargWin)													// If the eyes get into the target window...
				{
				// dsendf("vp %d\n",target_pd);								// ...flip the pg to the target with pd marker...	
				aquire_targ_time = time(); 									// ...record the time...
				// dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				// dsendf("vp %d\n",target);									// ...flip the pg to the target without pd marker.
				Event_fifo[Set_event] = Decide_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				stage = on_target;											// ...and advance to the next stage of the trial.
				}
			else if (time() > saccade_time + saccDurationMax)				// But, if the eyes are out of the target window and time runs out...
				{
				trialOutcome = saccOut;   									// TRIAL OUTCOME ERROR (innacurrate saccade)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (inaccurate saccade)\n");						// ...tell the user whats up...
				trl_running = 0; 											// ...and terminate the trial.
				}
			}
		
		
		
	//--------------------------------------------------------------------------------------------
	// STAGE on_target (eyes have entered the target window.  will they remain there for duration?)	
		else if (stage == on_target)
			{
			if (!In_TargWin)												// If the eyes left the target window...
				{			
				trialOutcome = brokeTarg;									// TRIAL OUTCOME ERROR (broke target fixation)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (broke target fixation)\n");					// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}		
			else if (In_TargWin  											// But if the eyes are still in the target window...
				&&  time() > aquire_targ_time + targHoldtime)				// ...and the target hold time is up...				
				{
				trialOutcome = saccTarg;									//TRIAL OUTCOME CORRECT (correct sacc trial)
				Event_fifo[Set_event] = Correct_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				printf("Correct (saccade)\n");								// ...tell the user whats up...
				dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				trl_running = 0;											// ...and terminate the trial.
				}			
			}
			
		nexttick;
		}
	}; TEMPO DIALOG CONFIGURATION FILE
; Copyright 1997-2013 Reflective Computing.  All Rights Reserved.
; This file was created by TEMPO and should not be edited directly by the user.
; The commands in this file are undocumented and subject to change in future releases.
; Fri Aug 02 09:48:21 2013
; DLOAD C:\tempo\ProcLib\pgm\VWM.dcf

; DIALOGS

SCREENRES 1280,1024,32

DIAPAGE 0,"Info_and_StartClock"
DIAPOS   0,0,-1,-1,-1,-1,411,354,791,557,0
DIAOBJ   0,0,2,269,120,349,150,"OK","start;\r\ndpop Info_and_StartClock;"
DIAOBJ   0,3,1,17,14,243,157,"","ALL_PROS.pro     (F1)\r\n\r\nprotocol control structure\r\nand associated protocols\r\n\r\nwritten by\r\ndavid.c.godlove@vanderbilt.edu\r\nJanuary, 2011"

DIAPAGE 1,"Choose_Task"
DIAPOS   1,0,-1,-1,-1,-1,881,263,1252,874,1
DIAOBJ   1,0,2,190,66,339,96,"Countermanding","quiet State = 6;\r\ndshow countermanding;\r\ndpop Choose_Task"
DIAOBJ   1,1,1,20,12,166,62,"","Which task do you\r\nwant to run? (F2)"
DIAOBJ   1,2,2,270,538,350,562,"Exit","Exit"
DIAOBJ   1,3,2,175,538,255,562,"Stop Clock","stop"
DIAOBJ   1,4,2,10,109,159,139,"Visually Guided","quiet State = 2;\r\ndpop Choose_Task"
DIAOBJ   1,5,2,10,66,159,96,"Fixation","quiet State = 1;\r\ndialog Fixation_Main;\r\ndpop Choose_Task"
DIAOBJ   1,6,2,12,236,161,266,"Memory Guided","quiet State = 5;\r\ndshow Memory_guided;\r\ndpop Choose_Task"
DIAOBJ   1,7,2,190,110,339,140,"Choice Countermand","quiet State = 7;\r\ndshow choice_countermanding;\r\ndpop Choose_Task"
DIAOBJ   1,8,2,11,154,155,182,"Amplitude","quiet State = 3;\r\ndshow Amplitude_task;\r\ndpop Choose_Task"
DIAOBJ   1,9,2,191,193,332,218,"Go/No-go","quiet State = 8;\r\ndshow go_nogo;\r\ndpop Choose_Task"
DIAOBJ   1,10,2,12,196,158,223,"Delayed","quiet State = 4;\r\ndshow delayed_task;\r\ndpop Choose_Task"
DIAOBJ   1,11,2,190,151,334,176,"Choice CM Target","quiet State = 7;\r\ncheckerIsTarg = 1;\r\ndshow choice_countermanding;\r\ndpop Choose_Task"
DIAOBJ   1,12,2,184,317,319,341,"Metacog","quiet State = 9;\r\ndshow mask_betting;\r\ndpop Choose_Task"
DIAOBJ   1,13,2,195,242,323,264,"VWM","quiet State = 10;\r\ndshow VWM;\r\ndpop Choose_Task"

DIAPAGE 2,"mask_betting"
DIAPOS   2,0,-1,-1,-1,-1,817,72,1203,862,2
DIAOBJ   2,0,2,296,728,360,750,"Start","beginTaskFlag = 1; "
DIAOBJ   2,1,2,211,728,275,750,"Quit","dshow quit_check;\r\nDPOP"
DIAOBJ   2,2,2,118,730,191,749,"Update","DSET;"
DIAOBJ   2,3,2,21,729,96,750,"Pause","quiet Pause = 1;\r\ndialog Resume"
DIAOBJ   2,4,1,6,73,103,94,"","Mask Trial %"
DIAOBJ   2,5,1,6,107,103,128,"","Bet Trial %"
DIAOBJ   2,6,1,6,141,103,162,"","Retro Trial %"
DIAOBJ   2,7,1,6,176,103,196,"","ProTrial %"
DIAOBJ   2,8,1,114,44,242,66,"","Trial Distribution"
DIAOBJ   2,9,3,203,73,264,91,"","maskPct"
DIAOBJ   2,10,3,203,106,264,122,"","betPct"
DIAOBJ   2,11,3,203,137,264,159,"","retroPct"
DIAOBJ   2,12,3,203,174,264,196,"","proPct"
DIAOBJ   2,13,1,8,229,103,249,"","Target Amp"
DIAOBJ   2,14,5,117,227,180,248,"","ampDefault"
DIAOBJ   2,15,3,216,226,292,245,"","ampDefault"
DIAOBJ   2,16,1,6,257,107,277,"","Target 1 Angle"
DIAOBJ   2,17,5,118,141,168,162,"","retroPct"
DIAOBJ   2,18,5,117,287,180,305,"","maskAngleArray[1]"
DIAOBJ   2,19,5,118,177,168,196,"","proPct"
DIAOBJ   2,20,5,118,73,168,92,"","maskPct"
DIAOBJ   2,21,5,118,106,168,127,"","betPct"
DIAOBJ   2,22,5,117,257,180,278,"","maskAngleArray[0]"
DIAOBJ   2,23,3,216,257,292,275,"","maskAngleArray[0]"
DIAOBJ   2,24,5,117,315,180,336,"","maskAngleArray[2]"
DIAOBJ   2,25,5,117,348,180,365,"","maskAngleArray[3]"
DIAOBJ   2,26,3,216,346,292,368,"","maskAngleArray[3]"
DIAOBJ   2,27,3,216,316,292,338,"","maskAngleArray[2]"
DIAOBJ   2,28,3,216,287,292,304,"","maskAngleArray[1]"
DIAOBJ   2,29,1,5,285,105,302,"","Target 2 Angle"
DIAOBJ   2,30,1,6,315,110,333,"","Target 3 Angle"
DIAOBJ   2,31,1,9,349,109,368,"","Target 4 Angle"
DIAOBJ   2,32,1,11,423,106,442,"","Mask Window"
DIAOBJ   2,33,5,140,421,203,439,"","targWinSize"
DIAOBJ   2,34,3,261,421,306,437,"","targWinSize"
DIAOBJ   2,35,1,10,452,103,472,"","Bet Window"
DIAOBJ   2,36,5,140,453,203,472,"","betWinSize"
DIAOBJ   2,37,3,261,451,303,470,"","betWinSize"
DIAOBJ   2,38,1,9,508,121,529,"","Fake Correct Rate"
DIAOBJ   2,39,5,140,507,203,527,"","fakeCorrectRate"
DIAOBJ   2,40,3,261,509,308,528,"","fakeCorrectRate"
DIAOBJ   2,41,1,9,536,124,558,"","Target Right Rate"
DIAOBJ   2,42,5,140,533,203,555,"","targetRightRate"
DIAOBJ   2,43,3,261,536,304,554,"","targetRightRate"
DIAOBJ   2,44,1,9,564,137,586,"","High Bet Right Rate"
DIAOBJ   2,45,3,261,563,306,584,"","highBetRightRate"
DIAOBJ   2,46,5,140,562,203,582,"","highBetRightRate"
DIAOBJ   2,47,3,249,625,314,642,"","baseRewardDuration"
DIAOBJ   2,48,5,142,619,209,637,"","baseRewardDuration"
DIAOBJ   2,49,1,18,617,118,636,"","Reward time"
DIAOBJ   2,50,1,14,649,119,669,"","Timeout"
DIAOBJ   2,51,3,242,656,324,671,"","basePunishDuration"
DIAOBJ   2,52,5,143,653,213,669,"","basePunishDuration"
DIAOBJ   2,53,5,130,688,198,707,"","nTarg"
DIAOBJ   2,54,3,243,692,313,707,"","nTarg"
DIAOBJ   2,55,1,26,690,109,709,"","nTarg"

DIAPAGE 3,"VWM"
DIAPOS   3,0,-1,-1,-1,-1,641,68,988,880,3
DIAOBJ   3,0,2,272,15,336,37,"OK","DSET; DPOP"
DIAOBJ   3,1,2,272,45,336,67,"Cancel","DPOP"
DIAOBJ   3,2,1,128,8,185,26,"","Duration"

DIAPAGE 13,"Quit_Check"
DIAPOS   13,0,-1,-1,-1,-1,431,452,791,632,13
DIAOBJ   13,0,2,233,119,345,141,"Quit Task","quiet state = 0;\r\nDPOP Fixation_Main;\r\nDPOP;\r\n"
DIAOBJ   13,1,2,110,119,222,141,"Don't Quit","DPOP"
DIAOBJ   13,2,1,8,15,218,79,"","QUIT TASK\r\n\r\nAre you sure you want to quit?"

DIAPAGE 14,"Fixation_Main"
DIAPOS   14,0,-1,-1,-1,-1,687,617,1037,901,14
DIAOBJ   14,0,2,116,229,180,250,"Start","quiet beginTaskFlag = 1;"
DIAOBJ   14,1,2,195,229,259,250,"Quit","dialog Quit_Check;"
DIAOBJ   14,2,1,6,65,134,87,"","Reward duration"
DIAOBJ   14,3,1,6,97,134,119,"","Tone frequency"
DIAOBJ   14,4,1,6,129,134,151,"","Target window targSize"
DIAOBJ   14,5,1,3,190,131,212,"","Inter-trial interval"
DIAOBJ   14,6,1,6,161,134,183,"","Hold fixation time"
DIAOBJ   14,7,2,271,228,335,249,"Apply","DSET"
DIAOBJ   14,8,5,144,126,211,148,"","targWinSize"
DIAOBJ   14,9,5,144,158,211,180,"","targHoldtime"
DIAOBJ   14,10,5,144,190,211,212,"","interTrialDuration"
DIAOBJ   14,11,5,144,62,211,84,"","baseRewardDuration"
DIAOBJ   14,12,5,144,94,211,116,"","Success_Tone_medR"
DIAOBJ   14,13,3,257,131,324,149,"","targWinSize"
DIAOBJ   14,14,3,257,163,324,181,"","targHoldtime"
DIAOBJ   14,15,3,257,195,324,213,"","interTrialDuration"
DIAOBJ   14,16,3,257,67,324,85,"","baseRewardDuration"
DIAOBJ   14,17,3,257,99,324,117,"","Success_Tone_medR"
DIAOBJ   14,18,1,115,8,243,41,"","Set fixation task\r\nvariables"
DIAOBJ   14,19,1,251,11,295,33,"","(F3)"

DIAPAGE 15,"Resume"
DIAPOS   15,0,-1,-1,-1,-1,512,377,694,513,15
DIAOBJ   15,0,1,35,22,148,50,"","Task is paused."
DIAOBJ   15,1,2,53,63,117,85,"Resume","quiet Pause = 0;\r\nDPOP"

DIAPAGE 16,"Select_Monkey"
DIAPOS   16,0,-1,-1,-1,-1,884,264,1248,875,16
DIAOBJ   16,0,2,181,391,245,413,"OK","DPOP"
DIAOBJ   16,1,2,70,299,195,335,"Default","quiet setMonkey = 1;\r\ndpop"
DIAOBJ   16,2,2,63,175,191,209,"Cajal","quiet Monkey = 2;\r\nquiet setMonkey = 1;\r\ndpop"
DIAOBJ   16,4,2,61,79,186,115,"Xena","quiet Monkey = 3;\r\nquiet setMonkey = 1;\r\ndpop"
DIAOBJ   16,5,2,61,125,186,161,"Broca","quiet Monkey = 2;\r\nquiet setMonkey = 1;\r\ndpop"

DIAPAGE 17,"Memory_guided"
DIAPOS   17,0,-1,-1,-1,-1,732,485,1110,938,17
DIAOBJ   17,0,2,295,396,359,418,"Start","beginTaskFlag = 1;\r\nDSET;"
DIAOBJ   17,1,2,207,394,271,416,"Quit","dialog Quit_Check;\r\ndpop;"
DIAOBJ   17,2,5,121,67,204,89,"","ampDefault"
DIAOBJ   17,3,5,124,204,204,224,"","baseRewardDuration"
DIAOBJ   17,4,3,235,70,363,92,"","ampDefault"
DIAOBJ   17,5,3,239,202,367,224,"","baseRewardDuration"
DIAOBJ   17,6,1,13,69,116,90,"","Eccentricity"
DIAOBJ   17,7,1,7,206,110,227,"","Reward Time"
DIAOBJ   17,8,2,108,396,192,417,"Update","dset;"
DIAOBJ   17,9,5,121,137,207,158,"","targWinSize"
DIAOBJ   17,10,1,7,135,114,156,"","Target Window"
DIAOBJ   17,11,3,255,137,358,157,"","targWinSize"
DIAOBJ   17,12,5,121,169,206,191,"","fixWinSize"
DIAOBJ   17,13,1,3,168,95,189,"","Fix Window"
DIAOBJ   17,14,3,268,167,356,188,"","fixWinSize"
DIAOBJ   17,15,3,269,236,366,259,"","basePunishDuration"
DIAOBJ   17,16,5,129,237,220,258,"","basePunishDuration"
DIAOBJ   17,17,1,13,237,98,258,"","Timeout"
DIAOBJ   17,18,2,7,397,96,419,"Pause","quiet Pause = 1;\r\ndialog Resume"
DIAOBJ   17,19,3,136,309,214,326,"","nTrialRemain"
DIAOBJ   17,20,5,143,279,211,301,"","nTrialPerTarget"
DIAOBJ   17,21,1,8,279,136,301,"","Trials Per Target"
DIAOBJ   17,22,1,7,304,135,326,"","Trials Remaining"
DIAOBJ   17,23,4,129,100,204,122,"","angleArray[0]"
DIAOBJ   17,24,1,4,99,117,122,"","Right Targ Angle"
DIAOBJ   17,25,3,241,100,369,122,"","angleArray[0]"
DIAOBJ   17,26,2,105,357,233,379,"180","angleArray[1] = angleArray[0] + 180;\r\nampArray[1] = ampArray[0];"

DIAPAGE 18,"choice_countermanding"
DIAPOS   18,0,0,972,-1,-1,828,15,1243,970,18
DIAOBJ   18,0,2,326,896,390,918,"Start","beginTaskFlag = 1;\r\n"
DIAOBJ   18,1,2,236,896,300,918,"Quit","dshow quit_check;\r\nDPOP"
DIAOBJ   18,2,1,19,511,179,529,"","Right Targ Square Prop."
DIAOBJ   18,3,5,12,538,68,560,"","targ1PropArray[0]"
DIAOBJ   18,4,5,8,572,64,594,"","targ1PropArray[1]"
DIAOBJ   18,5,5,10,606,66,628,"","targ1PropArray[2]"
DIAOBJ   18,6,5,17,640,73,662,"","targ1PropArray[3]"
DIAOBJ   18,7,5,17,674,73,696,"","targ1PropArray[4]"
DIAOBJ   18,8,5,17,708,73,730,"","targ1PropArray[5]"
DIAOBJ   18,9,5,17,742,73,764,"","targ1PropArray[6]"
DIAOBJ   18,10,5,17,776,73,798,"","targ1PropArray[7]"
DIAOBJ   18,11,5,17,810,73,832,"","targ1PropArray[8]"
DIAOBJ   18,12,5,17,845,73,867,"","targ1PropArray[9]"
DIAOBJ   18,13,1,219,510,380,529,"","SSDs (Sreen Refreshes)"
DIAOBJ   18,14,5,217,539,272,558,"","ssdArray[0]"
DIAOBJ   18,15,5,217,573,272,592,"","ssdArray[1]"
DIAOBJ   18,16,5,217,607,272,626,"","ssdArray[2]"
DIAOBJ   18,17,5,217,641,272,660,"","ssdArray[3]"
DIAOBJ   18,18,5,217,675,272,694,"","ssdArray[4]"
DIAOBJ   18,19,5,217,709,272,728,"","ssdArray[5]"
DIAOBJ   18,20,5,217,743,272,762,"","ssdArray[6]"
DIAOBJ   18,21,5,217,777,272,796,"","ssdArray[7]"
DIAOBJ   18,22,5,217,811,272,830,"","ssdArray[8]"
DIAOBJ   18,23,5,217,846,272,865,"","ssdArray[9]"
DIAOBJ   18,24,3,98,541,171,556,"","targ1PropArray[0]"
DIAOBJ   18,25,3,98,573,171,590,"","targ1PropArray[1]"
DIAOBJ   18,26,3,98,607,171,624,"","targ1PropArray[2]"
DIAOBJ   18,27,3,98,641,171,658,"","targ1PropArray[3]"
DIAOBJ   18,28,3,98,675,171,692,"","targ1PropArray[4]"
DIAOBJ   18,29,3,98,709,171,726,"","targ1PropArray[5]"
DIAOBJ   18,30,3,98,743,171,760,"","targ1PropArray[6]"
DIAOBJ   18,31,3,98,777,171,794,"","targ1PropArray[7]"
DIAOBJ   18,32,3,98,811,171,828,"","targ1PropArray[8]"
DIAOBJ   18,33,3,98,847,171,864,"","targ1PropArray[9]"
DIAOBJ   18,34,2,123,899,209,920,"Update","DSET;\r\ngoPct = 100 - stopPct;"
DIAOBJ   18,35,3,278,541,379,556,"","ssdArray[0]"
DIAOBJ   18,36,3,278,575,379,590,"","ssdArray[1]"
DIAOBJ   18,37,3,278,609,379,624,"","ssdArray[2]"
DIAOBJ   18,38,3,278,643,379,658,"","ssdArray[3]"
DIAOBJ   18,39,3,278,677,379,692,"","ssdArray[4]"
DIAOBJ   18,40,3,278,711,379,726,"","ssdArray[5]"
DIAOBJ   18,41,3,278,745,379,760,"","ssdArray[6]"
DIAOBJ   18,42,3,278,779,379,794,"","ssdArray[7]"
DIAOBJ   18,43,3,278,813,379,828,"","ssdArray[8]"
DIAOBJ   18,44,3,278,848,379,863,"","ssdArray[9]"
DIAOBJ   18,45,1,110,239,272,261,"","CHECKER STIMULUS:"
DIAOBJ   18,46,3,125,262,190,282,"","checkerWidthDegrees"
DIAOBJ   18,47,3,322,263,387,284,"","checkerHeightDegrees"
DIAOBJ   18,48,3,265,304,346,319,"","iSquareSizePixels"
DIAOBJ   18,49,5,177,300,242,319,"","iSquareSizePixels"
DIAOBJ   18,50,1,25,299,153,321,"","Squares pixel width"
DIAOBJ   18,51,5,177,330,242,349,"","checkerAmp"
DIAOBJ   18,52,3,265,334,346,349,"","checkerAmp"
DIAOBJ   18,53,1,25,329,153,351,"","Chekcer stim Eccent"
DIAOBJ   18,54,1,25,360,153,382,"","Chekcer stim Angle"
DIAOBJ   18,55,5,177,361,242,380,"","checkerAngle"
DIAOBJ   18,56,3,265,365,346,380,"","checkerAngle"
DIAOBJ   18,57,1,136,5,264,27,"","TARGETS:"
DIAOBJ   18,58,1,8,34,136,56,"","Right Targ Eccen"
DIAOBJ   18,59,3,236,35,314,54,"","ampArray[0]\r\n"
DIAOBJ   18,60,5,150,34,213,52,"","ampArray[0]"
DIAOBJ   18,61,1,9,62,137,84,"","Right Target Angle"
DIAOBJ   18,62,5,150,63,213,81,"","angleArray[0]"
DIAOBJ   18,63,3,236,64,314,83,"","angleArray[0]"
DIAOBJ   18,64,1,18,262,107,282,"","Width (deg.)"
DIAOBJ   18,65,1,215,263,304,284,"","Height (deg.)"
DIAOBJ   18,66,4,177,392,242,410,"","chkrWinSize"
DIAOBJ   18,67,1,26,391,154,413,"","Checker Window"
DIAOBJ   18,68,1,15,186,143,208,"","Target Window"
DIAOBJ   18,69,5,150,184,213,202,"","targWinSize"
DIAOBJ   18,70,5,150,212,215,230,"","fixWinSize"
DIAOBJ   18,71,1,13,213,141,235,"","Fixation Window"
DIAOBJ   18,72,3,236,184,314,205,"","targWinSize"
DIAOBJ   18,73,3,236,213,314,235,"","fixWinSize"
DIAOBJ   18,74,3,218,392,346,414,"","chkrWinSize"
DIAOBJ   18,75,2,9,898,98,919,"Pause","quiet Pause = 1;\r\ndialog Resume"
DIAOBJ   18,76,5,165,424,243,442,"","baseRewardDuration"
DIAOBJ   18,77,3,266,424,354,441,"","baseRewardDuration"
DIAOBJ   18,78,1,29,426,127,448,"","Reward Time"
DIAOBJ   18,79,1,27,451,155,473,"","Timeout"
DIAOBJ   18,80,5,167,448,244,463,"","basePunishDuration"
DIAOBJ   18,81,3,260,449,351,464,"","basePunishDuration"
DIAOBJ   18,82,5,150,124,212,141,"","ampArray[1]"
DIAOBJ   18,83,3,236,125,314,141,"","ampArray[1]"
DIAOBJ   18,84,1,10,122,138,144,"","Left Targ Eccen"
DIAOBJ   18,85,5,150,147,218,166,"","angleArray[1]"
DIAOBJ   18,86,3,236,152,314,168,"","angleArray[1]"
DIAOBJ   18,87,1,12,151,130,173,"","Left Target Angle"
DIAOBJ   18,88,2,141,875,192,894,"180","angleArray[1] = angleArray[0] + 180;\r\nampArray[1] = ampArray[0];\r\ncheckerAngle = angleArray[0] + 90;"
DIAOBJ   18,89,5,208,480,263,500,"","stopPct"
DIAOBJ   18,90,1,82,483,210,505,"","Stop Trial Percent"
DIAOBJ   18,91,3,317,480,366,497,"","stopPct"
DIAOBJ   18,92,3,256,93,318,108,"","targetRightRate"
DIAOBJ   18,93,5,158,95,225,110,"","targetRightRate"
DIAOBJ   18,94,1,4,93,132,115,"","Right Target Proportion"

DIAPAGE 19,"Amplitude_task"
DIAPOS   19,0,-1,-1,-1,-1,810,469,1146,755,19
DIAOBJ   19,0,2,188,232,252,254,"Start","beginTaskFlag = 1;\r\nDSET;"
DIAOBJ   19,1,2,115,232,179,254,"Quit","dshow quit_check;\r\nDPOP"
DIAOBJ   19,2,4,44,88,107,109,"","angleArray[0]"
DIAOBJ   19,3,1,2,90,61,108,"","Angle"
DIAOBJ   19,4,3,173,91,207,106,"","angleArray[0]"
DIAOBJ   19,5,2,52,13,180,35,"Turn ON Auto-targSize","autoTargetSizeFlag = 1;"
DIAOBJ   19,6,2,52,43,180,65,"Turn OFF Auto-szie","autoTargetSizeFlag = 0;"
DIAOBJ   19,7,2,40,232,106,254,"Update","spawn GOODVARS;\r\ndset;"
DIAOBJ   19,8,3,143,181,229,200,"","nTrialRemain"
DIAOBJ   19,9,5,160,152,231,171,"","nTrialPerTarget"
DIAOBJ   19,10,1,11,151,139,173,"","Trials Per Target"
DIAOBJ   19,11,1,11,177,139,199,"","Trials Remaining"

DIAPAGE 20,"go_nogo"
DIAPOS   20,0,-1,-1,-1,-1,730,125,1142,882,20
DIAOBJ   20,0,2,308,699,372,721,"Start","beginTaskFlag = 1;\r\ndset;"
DIAOBJ   20,1,2,16,701,92,723,"Quit Task","dialog Quit_Check"
DIAOBJ   20,2,2,190,701,299,722,"Update","DSET;\r\nangleArray[1] = angleArray[0] + 180;\r\nnTrialArray[1] = ampArray[0];"
DIAOBJ   20,3,1,6,34,141,54,"","Target Eccentricity"
DIAOBJ   20,4,3,263,33,347,51,"","ampDefault"
DIAOBJ   20,5,5,166,34,250,53,"","ampDefault\r\n"
DIAOBJ   20,6,1,11,62,139,84,"","Right Target Angle"
DIAOBJ   20,7,5,166,67,250,86,"","angleArray[0]"
DIAOBJ   20,8,3,263,66,347,84,"","angleArray[0]"
DIAOBJ   20,9,3,263,132,347,150,"","targWinSize"
DIAOBJ   20,10,5,166,133,250,152,"","targWinSize"
DIAOBJ   20,11,1,13,119,141,141,"","Target Window"
DIAOBJ   20,12,1,9,150,137,172,"","Fixation Window"
DIAOBJ   20,13,5,166,166,250,185,"","fixWinSize"
DIAOBJ   20,14,3,263,165,347,183,"","fixWinSize"
DIAOBJ   20,15,1,8,300,233,325,"","Go Square Proportions"
DIAOBJ   20,16,5,4,339,132,361,"","goPropArray[0]"
DIAOBJ   20,17,5,4,373,132,395,"","goPropArray[1]"
DIAOBJ   20,18,5,3,405,131,427,"","goPropArray[2]"
DIAOBJ   20,19,5,3,436,131,458,"","goPropArray[3]"
DIAOBJ   20,20,5,6,470,134,492,"","goPropArray[4]"
DIAOBJ   20,21,5,6,505,134,527,"","goPropArray[5]"
DIAOBJ   20,22,5,4,537,132,559,"","goPropArray[6]"
DIAOBJ   20,23,5,5,570,133,592,"","goPropArray[7]"
DIAOBJ   20,24,5,6,601,134,623,"","goPropArray[8]"
DIAOBJ   20,25,5,4,636,132,658,"","goPropArray[9]"
DIAOBJ   20,26,3,146,341,274,363,"","goPropArray[0]"
DIAOBJ   20,27,3,145,373,273,395,"","goPropArray[1]"
DIAOBJ   20,28,3,139,404,267,426,"","goPropArray[2]"
DIAOBJ   20,29,3,140,437,268,459,"","goPropArray[3]"
DIAOBJ   20,30,3,136,471,264,493,"","goPropArray[4]"
DIAOBJ   20,31,3,135,505,263,527,"","goPropArray[5]"
DIAOBJ   20,32,3,139,537,267,559,"","goPropArray[6]"
DIAOBJ   20,33,3,133,570,261,592,"","goPropArray[7]"
DIAOBJ   20,34,3,134,601,262,623,"","goPropArray[8]"
DIAOBJ   20,35,3,135,636,263,658,"","goPropArray[9]"
DIAOBJ   20,36,3,263,198,347,216,"","baseRewardDuration"
DIAOBJ   20,37,5,166,199,250,218,"","baseRewardDuration"
DIAOBJ   20,38,1,6,192,118,212,"","Reward Time"
DIAOBJ   20,39,3,263,231,347,249,"","basePunishDuration"
DIAOBJ   20,40,5,166,232,250,251,"","basePunishDuration"
DIAOBJ   20,41,1,9,231,137,253,"","Timeout time"
DIAOBJ   20,42,2,99,702,184,723,"Pause","quiet Pause = 1;\r\ndialog Resume"
DIAOBJ   20,43,5,166,270,250,289,"","iSquareSizePixels"
DIAOBJ   20,44,3,263,270,347,288,"","iSquareSizePixels"
DIAOBJ   20,45,1,6,270,143,290,"","Chkr Sqr Pixel Width"
DIAOBJ   20,46,5,166,100,250,119,"","targetRightRate"
DIAOBJ   20,47,3,263,99,347,117,"","targetRightRate"
DIAOBJ   20,48,1,6,92,151,110,"","Right Target Proportion"

DIAPAGE 21,"Visually_Guided"
DIAPOS   21,0,-1,-1,-1,-1,748,427,1122,837,21
DIAOBJ   21,0,2,283,350,347,372,"Start","dset;\r\nbeginTaskFlag = 1;"
DIAOBJ   21,1,2,206,351,270,373,"quit","dshow quit_check;\r\nDPOP"
DIAOBJ   21,2,2,101,352,185,371,"Update","spawn GOODVARS;\r\ndset;"
DIAOBJ   21,3,5,130,73,181,95,"","ampDefault"
DIAOBJ   21,4,3,219,73,286,93,"","ampDefault"
DIAOBJ   21,5,1,16,74,99,93,"","Eccentricity"
DIAOBJ   21,6,3,221,134,288,149,"","targWinSize"
DIAOBJ   21,7,1,13,137,112,153,"","Target Window"
DIAOBJ   21,8,5,138,167,192,184,"","fixWinSize"
DIAOBJ   21,9,2,14,351,96,373,"Pause","quiet Pause = 1;\r\ndialog Resume"
DIAOBJ   21,10,5,126,204,177,223,"","baseRewardDuration"
DIAOBJ   21,11,3,194,203,281,222,"","baseRewardDuration"
DIAOBJ   21,12,1,15,201,116,221,"","Reward duration"
DIAOBJ   21,13,1,22,236,150,258,"","Trials Per Target"
DIAOBJ   21,14,1,15,266,143,288,"","Trials Remaining"
DIAOBJ   21,15,5,159,235,222,253,"","nTrialPerTarget"
DIAOBJ   21,16,3,166,266,227,281,"","nTrialRemain"
DIAOBJ   21,17,5,132,135,185,154,"","targWinSize"
DIAOBJ   21,18,3,221,164,288,180,"","fixWinSize"
DIAOBJ   21,19,1,15,167,132,185,"","Fixation Window"
DIAOBJ   21,20,2,131,321,259,343,"180","angleArray[1] = angleArray[0] + 180;\r\nampArray[1] = ampArray[0];\r\n"
DIAOBJ   21,21,1,12,104,124,123,"","Right Targ Angle"
DIAOBJ   21,22,5,131,104,183,124,"","angleArray[0]"
DIAOBJ   21,23,3,218,104,287,126,"","angleArray[0]"

DIAPAGE 22,"delayed_task"
DIAPOS   22,0,-1,-1,-1,-1,796,211,1170,602,22
DIAOBJ   22,0,2,275,334,339,356,"Start","DSET;\r\nbeginTaskFlag = 1;"
DIAOBJ   22,1,2,189,334,253,356,"Quit","dshow quit_check;"
DIAOBJ   22,2,2,99,335,183,356,"Update","dset;"
DIAOBJ   22,3,5,127,27,209,47,"","ampDefault"
DIAOBJ   22,4,3,212,27,340,49,"","ampDefault"
DIAOBJ   22,5,1,4,28,106,47,"","Eccentricity"
DIAOBJ   22,6,3,250,90,327,105,"","targWinSize"
DIAOBJ   22,7,5,136,92,208,113,"","targWinSize"
DIAOBJ   22,8,1,6,163,134,185,"","Reward Time"
DIAOBJ   22,9,1,4,91,132,113,"","Target Window"
DIAOBJ   22,10,5,137,125,208,148,"","fixWinSize"
DIAOBJ   22,11,3,219,125,339,145,"","fixWinSize"
DIAOBJ   22,12,1,6,125,134,147,"","Fix Window targSize"
DIAOBJ   22,13,5,139,160,213,181,"","baseRewardDuration"
DIAOBJ   22,14,3,261,161,340,183,"","baseRewardDuration"
DIAOBJ   22,15,2,7,336,90,358,"Pause","quiet Pause = 1;\r\ndialog Resume"
DIAOBJ   22,16,5,141,190,215,210,"","basePunishDuration"
DIAOBJ   22,17,1,11,191,115,210,"","Timeout Time"
DIAOBJ   22,18,3,256,189,347,208,"","basePunishDuration"
DIAOBJ   22,19,1,29,274,157,296,"","Trials Remaining"
DIAOBJ   22,20,1,30,247,158,269,"","Trials Per Target"
DIAOBJ   22,21,5,162,247,225,268,"","nTrialPerTarget"
DIAOBJ   22,22,3,160,278,227,293,"","nTrialRemain"
DIAOBJ   22,23,2,117,304,245,326,"180","angleArray[1] = angleArray[0] + 180;\r\nampArray[1] = ampArray[0];\r\n"
DIAOBJ   22,24,5,128,59,210,79,"","angleArray[0]"
DIAOBJ   22,25,3,266,60,345,80,"","angleArray[0]"
DIAOBJ   22,26,1,4,57,113,76,"","Right Targ Angle"

DIAPAGE 23,"countermanding"
DIAPOS   23,0,-1,-1,-1,-1,836,113,1211,790,23
DIAOBJ   23,0,2,286,615,350,637,"Start","dset;\r\nbeginTaskFlag = 1;"
DIAOBJ   23,1,2,202,614,266,636,"Quit","dshow quit_check;\r\nDPOP"
DIAOBJ   23,2,5,156,39,219,62,"","ampDefault"
DIAOBJ   23,3,1,5,40,133,62,"","Target Eccentricity"
DIAOBJ   23,4,3,265,44,337,62,"","ampDefault"
DIAOBJ   23,5,3,264,71,338,90,"","angleArray[0]"
DIAOBJ   23,6,5,158,75,227,94,"","angleArray[0]"
DIAOBJ   23,7,1,10,70,138,92,"","Right Target Angle"
DIAOBJ   23,8,1,8,132,136,154,"","Target Window"
DIAOBJ   23,9,1,10,165,138,187,"","Fixation Window"
DIAOBJ   23,10,5,160,165,227,181,"","fixWinSize"
DIAOBJ   23,11,3,264,163,337,180,"","fixWinSize"
DIAOBJ   23,12,5,157,131,229,148,"","targWinSize"
DIAOBJ   23,13,3,267,126,332,144,"","targWinSize"
DIAOBJ   23,14,1,127,13,255,35,"","STIMULI"
DIAOBJ   23,15,1,25,278,153,300,"","SSDs"
DIAOBJ   23,16,3,100,308,169,327,"","ssdArray[0]"
DIAOBJ   23,17,5,20,306,77,325,"","ssdArray[0]"
DIAOBJ   23,18,5,20,339,77,358,"","ssdArray[1]"
DIAOBJ   23,19,3,100,342,169,361,"","ssdArray[1]"
DIAOBJ   23,20,3,100,370,169,389,"","ssdArray[2]"
DIAOBJ   23,21,5,20,370,77,389,"","ssdArray[2]"
DIAOBJ   23,22,5,20,401,77,420,"","ssdArray[3]"
DIAOBJ   23,23,3,100,398,169,417,"","ssdArray[3]"
DIAOBJ   23,24,3,100,431,169,450,"","ssdArray[4]"
DIAOBJ   23,25,5,20,431,77,450,"","ssdArray[4]"
DIAOBJ   23,26,5,20,460,77,479,"","ssdArray[5]"
DIAOBJ   23,27,3,100,460,169,479,"","ssdArray[5]"
DIAOBJ   23,28,3,100,487,169,506,"","ssdArray[6]"
DIAOBJ   23,29,5,20,489,77,508,"","ssdArray[6]"
DIAOBJ   23,30,5,20,516,77,535,"","ssdArray[7]"
DIAOBJ   23,31,3,100,513,169,532,"","ssdArray[7]"
DIAOBJ   23,32,3,100,542,169,561,"","ssdArray[8]"
DIAOBJ   23,33,5,20,546,77,565,"","ssdArray[8]"
DIAOBJ   23,34,5,20,578,77,597,"","ssdArray[9]"
DIAOBJ   23,35,3,100,573,169,592,"","ssdArray[9]"
DIAOBJ   23,36,2,17,615,100,636,"Pause","quiet pause = 1;\r\ndialog Resume;"
DIAOBJ   23,37,2,104,615,196,636,"Update","DSET;\r\nangleArray[1] = angleArray[0] + 180;\r\nnTrialArray[1] = ampArray[0];\r\ngoPct = 100 - stopPct;\r\n"
DIAOBJ   23,38,3,297,310,349,329,"","baseRewardDuration"
DIAOBJ   23,39,5,203,310,274,330,"","baseRewardDuration"
DIAOBJ   23,40,1,228,288,315,306,"","Reward Time"
DIAOBJ   23,41,1,234,354,313,373,"","Timeout"
DIAOBJ   23,42,5,198,379,263,400,"","basePunishDuration"
DIAOBJ   23,43,3,275,382,352,398,"","basePunishDuration"
DIAOBJ   23,44,3,254,101,340,117,"","targetRightRate"
DIAOBJ   23,45,5,167,103,226,119,"","targetRightRate"
DIAOBJ   23,46,1,6,104,156,124,"","Right Target Proportion"
DIAOBJ   23,47,5,155,227,213,242,"","stopPct"
DIAOBJ   23,48,3,258,228,329,243,"","stopPct"
DIAOBJ   23,49,1,10,222,138,244,"","Stop Trial Percent"
DIAOBJ   23,50,2,148,255,200,274,"ON","randomAmpFlag = 1;\r\ndset;"
DIAOBJ   23,51,3,287,260,350,276,"","randomAmpFlag "
DIAOBJ   23,52,2,220,255,272,274,"OFF","randomAmpFlag = 0;\r\ndset;"
DIAOBJ   23,53,1,11,257,139,279,"","Vary Eccentricity"

; END OF DIALOGS

//--------------------------------------------------------------------------------------------------
// process MEM_PGS();
//
// Figure out all stimuli that will be needed on the next mem guided trial and
// place it all into video memory.
//
// written by david.c.godlove@vanderbilt.edu 	July, 2011


declare VWM_PGS();                       										// see GRAPHS.pro

process VWM_PGS()	                       										// see GRAPHS.pro
{


// number the pgs that need to be drawn
declare hide int   	blank       		= 0;
declare hide int	pd					= 1;
declare hide int	fixation_pd			= 2;
declare hide int	fixation    		= 3;
declare hide int	fixation_target_pd	= 4;
declare hide int	fixation_target	= 5;
declare hide int	test_pd   		= 6;
declare hide int	test      		= 7;
declare hide int	emove     		= 8;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Calculate screen coordinates for stimuli on this trial

if (AutoTargetSizeFlag)
	{
	targSize        	 	= targAmp * TargetSizeConversion;   			// Figure out the attributes of the current target
	}
else
	{
	targSize				= sizeArray[targIndex]*3;
	}
//targAngle        = angleArray[targIndex]; 													// THESE USER DEFINED GLOBALS ARE ARRAYS SO
//targColor        = targIndex + 1;																// zero is reserved for black.  see SET_CLRS.pro


opposite = ((screenHeight/2)-pdBottom);														// Figure out angle and eccentricity of photodiode marker in pixels
adjacent = ((screenWidth/2)-pdLeft);                                                         // NOTE: I am assuming your pd is in the lower left quadrant of your screen
pdAmp = sqrt((opposite * opposite) + (adjacent * adjacent));
pdAngle = rad2deg(atan (opposite / adjacent));
pdAngle = pdAngle + 180; 																	//change this for different quadrent or write some code for flexibility

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 1
// print("photodiode");
dsendf("rw %d,%d;\n",pd,pd);				 												// draw first pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 2
// print("fixation with photodiode");
dsendf("rw %d,%d;\n",fixation_pd,fixation_pd); 												// draw second pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 3
// print("fixation");
dsendf("rw %d,%d;\n",fixation,fixation);   													// draw 3rd pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 4
// print("fixation target and photodiode");
dsendf("rw %d,%d;\n",fixation_target_pd,fixation_target_pd);   								// draw 4th pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point

spawnwait DRW_SQR(targSize, LocArray[0], targAmp, ColorArray[0], fill, deg2pix_X, deg2pix_Y);          	// draw target 
spawnwait DRW_SQR(targSize, LocArray[1], targAmp, ColorArray[1], fill, deg2pix_X, deg2pix_Y);          	// draw target 
spawnwait DRW_SQR(targSize, LocArray[2], targAmp, ColorArray[2], fill, deg2pix_X, deg2pix_Y);          	// draw target 
spawnwait DRW_SQR(targSize, LocArray[3], targAmp, ColorArray[3], fill, deg2pix_X, deg2pix_Y);          	// draw target 
//spawnwait DRW_SQR(targSize, LocArray[4], targAmp, ColorArray[4], fill, deg2pix_X, deg2pix_Y);          	// draw target 
//spawnwait DRW_SQR(targSize, LocArray[5], targAmp, ColorArray[5], fill, deg2pix_X, deg2pix_Y);          	// draw target 

spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);			// draw photodiode marker
nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 5
// print("fixation and target");
dsendf("rw %d,%d;\n",fixation_target,fixation_target);   								// draw 4th pg of video memory
dsendf("cl:\n");																			// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   	// draw fixation point

spawnwait DRW_SQR(targSize, LocArray[0], targAmp, ColorArray[0], fill, deg2pix_X, deg2pix_Y);          	// draw target 
spawnwait DRW_SQR(targSize, LocArray[1], targAmp, ColorArray[1], fill, deg2pix_X, deg2pix_Y);          	// draw target 
spawnwait DRW_SQR(targSize, LocArray[2], targAmp, ColorArray[2], fill, deg2pix_X, deg2pix_Y);          	// draw target 
spawnwait DRW_SQR(targSize, LocArray[3], targAmp, ColorArray[3], fill, deg2pix_X, deg2pix_Y);          	// draw target 
//spawnwait DRW_SQR(targSize, LocArray[4], targAmp, ColorArray[4], fill, deg2pix_X, deg2pix_Y);          	// draw target 
//spawnwait DRW_SQR(targSize, LocArray[5], targAmp, ColorArray[5], fill, deg2pix_X, deg2pix_Y);          	// draw target 


nexttick;



//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 6
// print("target");
dsendf("rw %d,%d;\n",test_pd,test_pd);  																	// draw pg 6
dsendf("cl:\n");																							// clear screen 

spawnwait DRW_SQR(targSize, fixAngle, fixAmp, testColor, fill, deg2pix_X, deg2pix_Y);          				// draw target 

spawnwait DRW_SQR(pdSize,pdAngle,pdAmp,15,fill,unit2pix_X,unit2pix_Y);										// draw photodiode marker
//spawnwait DRW_SQR(targSize*1, LocArray[0], targAmp, ColorArray[0], fill, deg2pix_X, deg2pix_Y);          	// draw target 
//spawnwait DRW_SQR(targSize*1, LocArray[1], targAmp, ColorArray[1], fill, deg2pix_X, deg2pix_Y);          	// draw target 
//spawnwait DRW_SQR(targSize*1, LocArray[2], targAmp, ColorArray[2], fill, deg2pix_X, deg2pix_Y);          	// draw target 
//spawnwait DRW_SQR(targSize*1, LocArray[3], targAmp, ColorArray[3], fill, deg2pix_X, deg2pix_Y);          	// draw target 
// spawnwait DRW_SQR(targSize*1, LocArray[4], targAmp, ColorArray[4], fill, deg2pix_X, deg2pix_Y);          	// draw target 
// spawnwait DRW_SQR(targSize*1, LocArray[5], targAmp, ColorArray[5], fill, deg2pix_X, deg2pix_Y);          	// draw target 

nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 7
// print("target");
dsendf("rw %d,%d;\n",test,test);  																			// draw pg 7
dsendf("cl:\n");																							// clear screen 

spawnwait DRW_SQR(targSize, fixAngle, fixAmp, testColor, fill, deg2pix_X, deg2pix_Y);          				// draw target 
//spawnwait DRW_SQR(targSize*1, LocArray[0], targAmp, ColorArray[0], fill, deg2pix_X, deg2pix_Y);          	// draw target 
//spawnwait DRW_SQR(targSize*1, LocArray[1], targAmp, ColorArray[1], fill, deg2pix_X, deg2pix_Y);          	// draw target
//spawnwait DRW_SQR(targSize*1, LocArray[2], targAmp, ColorArray[2], fill, deg2pix_X, deg2pix_Y);          	// draw target 
//spawnwait DRW_SQR(targSize*1, LocArray[3], targAmp, ColorArray[3], fill, deg2pix_X, deg2pix_Y);          	// draw target 
//spawnwait DRW_SQR(targSize*1, LocArray[4], targAmp, ColorArray[4], fill, deg2pix_X, deg2pix_Y);          		// draw target 
// spawnwait DRW_SQR(targSize*1, LocArray[5], targAmp, ColorArray[5], fill, deg2pix_X, deg2pix_Y);          	// draw target  

nexttick;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Draw pg 8
dsendf("rw %d,%d;\n",emove,emove);   																	// draw 8th pg of video memory
dsendf("cl:\n");																						// clear screen
spawnwait DRW_SQR(fixSize, fixAngle, fixAmp, fixColor, fill, deg2pix_X, deg2pix_Y);   					// draw fixation point

spawnwait DRW_SQR(targSize, LocArray[0], targAmp, ColorArray[0], fill, deg2pix_X, deg2pix_Y);          	// draw target 
spawnwait DRW_SQR(targSize, LocArray[1], targAmp, ColorArray[1], fill, deg2pix_X, deg2pix_Y);          	// draw target 
spawnwait DRW_SQR(targSize, LocArray[2], targAmp, ColorArray[2], fill, deg2pix_X, deg2pix_Y);          	// draw target 
spawnwait DRW_SQR(targSize, LocArray[3], targAmp, ColorArray[3], fill, deg2pix_X, deg2pix_Y);          	// draw target 
// spawnwait DRW_SQR(targSize, LocArray[4], targAmp, ColorArray[4], fill, deg2pix_X, deg2pix_Y);          	// draw target 
// spawnwait DRW_SQR(targSize, LocArray[5], targAmp, ColorArray[5], fill, deg2pix_X, deg2pix_Y);          	// draw target 


 // nexttick;








//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Draw pg 0 (last is displayed first)
// print("blank");
dsendf("rw %d,%d;\n",blank,blank);                                          				// draw the blank screen last so that it shows up first
dsendf("cl:\n");                                                                            // clear screen (that's all)

}//Experiment Parameter setup!
//It sets up importatnt stimuli parameters (e.g. locations and colors)
//For the experiment

declare VWMParam();

declare Color_Selection();			    /* Choose color values */
declare SameDiff_Selection();			    /* Choose color values */
declare Location_Selection();			    /* Choose location values */
declare Setsize_Selection();			    /* Choose Setsize values */

declare setsize = 0;
declare samediff = 0;
declare tlocs[8,2];
declare tcolors[7];

process VWMParam
	{
	spawn Setsize_Selection;
	nexttick;
	spawn SameDiff_Selection;
	nexttick;
	spawn Location_Selection;
	nexttick;
	spawn Color_Selection;
	nexttick;
	
	}
	
//Component Processes!////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

process Location_Selection
	{
	//Set Stimulus Locations Declaration comes first!!!!!!!!!!!!!!!!!!!
	declare loc_indecies[8];
	declare loc_index = 0;
	declare temp_loc = 0;
	declare norepetition = 1;
	declare loc = 0;
	
	
	//initialize the array!

	loc_indecies[0] = 99;
	loc_indecies[1] = 99;
	loc_indecies[2] = 99;
	loc_indecies[3] = 99;
	loc_indecies[4] = 99;
	loc_indecies[5] = 99;
	loc_indecies[6] = 99;
	loc_indecies[7] = 99;
	
	
	loc = 0;
	while (loc <numLocs)
		{
		loc_index = random(4);//original was 8
		temp_loc = 0;
		norepetition = 1;
		
		while (temp_loc <numLocs)
			{
			if (loc_index ==loc_indecies[temp_loc])
				{
				norepetition = 0;
				}
			temp_loc = temp_loc+1;
			}
		if (norepetition == 1)
			{
			loc_indecies[loc]=loc_index;
			//tlocs[loc,0]= Locs[loc_index,0];
			//tlocs[loc,1]= Locs[loc_index,1];
			loc = loc+1;
			}
		
		}
	nexttick; 
	}
	


process Setsize_Selection
	{
	//declare setsizes[5]={1,2,3,4,6};
	declare setsizes[5]={1,1,1,1,1};
	declare setsize_index;
	
	
	//initialize the array!
	setsizes[0] = 1;
	setsizes[1] = 1;
	setsizes[2] = 1;
	setsizes[3] = 1;
	setsizes[4] = 1;
	setsize_index = random(5);
	//printf("setsize=%d\n",setsize_index);
	setsize = setsizes[setsize_index];
	}
	
process SameDiff_Selection
	{
	declare samediffs[2] = {1,2};
	declare samediff_index;
	samediff_index = random(2);
	samediff = samediffs[samediff_index];
	}
		

		

	
process Color_Selection
	{
	//Set Stimulus COlors
	declare color_indecies[7] = {99,99,99,99,99,99,99};
	declare color_index = 0;
	declare temp_color = 0;
	declare norepetition = 1;
	declare color = 0;

	//initialize the array!
	color_indecies[0] = 99;
	color_indecies[1] = 99;
	color_indecies[2] = 99;
	color_indecies[3] = 99;
	color_indecies[4] = 99;
	color_indecies[5] = 99;
	color_indecies[6] = 99;
	
	color = 0;
	while (color < numColors)
		{
		color_index = random(7);
		temp_color = 0;
		norepetition = 1;
		while (temp_color < numColors)
			{
			if (color_index ==color_indecies[temp_color])
				{
				norepetition = 0;
				}
			temp_color = temp_color+1;
			}
		if (norepetition == 1)
			{
			color_indecies[color]=color_index;
			tcolors[color]= Colors[color_index];
			color = color+1;
			}
		
		}
	nexttick; 
	}
//--------------------------------------------------------------------------------------------
// Run a memory guided saccade trial based on the variables calculated by SETM_TRL.pro and 
// those given by the user.  Adapted from CMDTRIAL.
//
// written by david.c.godlove@vanderbilt.edu 	July, 2011


declare VWMTRIAL();			// animated graph object

process VWMTRIAL()        		// animated graph object
	{
	
	
	// Number the trial stages to make them easier to read below
	declare hide int 	need_fix  	= 1;
	declare hide int 	fixating  	= 2;
	declare hide int 	targ_off   	= 3;
	declare hide int	same		= 4;
	declare hide int	diff		= 5;
	declare hide int 	in_flight 	= 6;
	declare hide int 	on_target 	= 7;	
	declare hide int 	test_hold 	= 8;
	declare hide int 	stage;
	
	// Number the stimuli pages to make reading easier
	declare hide int   	blank       		= 0;
	declare hide int	pd					= 1;
	declare hide int	fixation_pd 		= 2;
	declare hide int	fixation    		= 3;
	declare hide int	fixation_target_pd	= 4;
	declare hide int	fixation_target	= 5;
	declare hide int	test_pd   		= 6;	
	declare hide int	test      		= 7;
	declare hide int	emove      		= 8;

	
		  
	// Timing variables which will be used to time task
	declare hide float 	fix_on_time; 	
	declare hide float 	aquire_fix_time;
	declare hide float  targ_time;	
	declare hide float	fix_off_time;
	declare hide float  saccade_time;
	declare hide float	aquire_targ_time;	
	declare hide float test_on_time;
	declare hide float test_off_time;
	
	
	// Have to be reset on every iteration since 
	// variable declaration only occurs at load time
	trl_running 		= 1;
	stage 				= need_fix;
	
	// Tell the user what's up
	printf("\n# %d\n",nTrial);
	printf("Hold time:     %d\n",  soa);

	
	
																			// HERE IS WHERE THE FUN BEGINS
	Event_fifo[Set_event] = TrialStart_;									// queue TrialStart_ strobe
	Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
	dsendf("vp %d\n",fixation_pd);											// flip the pg to the fixation stim with pd marker
	fix_on_time = time();  													// record the time
	Event_fifo[Set_event] = FixSpotOn_;										// queue strobe
	Set_event = (Set_event + 1) % Event_fifo_N;								// incriment event queue
	dsendf("XM RFRSH:\n"); 													// wait for one retrace
	dsendf("vp %d\n",fixation);												// flip the pg to the fixation stim without pd marker
	oSetAttribute(object_fix, aVISIBLE); 									// turn on the fixation point in animated graph
	
	
	while (trl_running)														// trials ending will set trl_running = 0
		{	
		
	//--------------------------------------------------------------------------------------------
	// STAGE need_fix (the fixation point is on, but the subject hasn't looked at it)
		if (stage == need_fix)
			{		
			if (In_FixWin)													// If the eyes have entered the fixation window (before time, see below)...
				{
				aquire_fix_time = time();									// ...function call to time to note current time and...
				trialStartTime = aquire_fix_time;							// Global output for timing iti
				Event_fifo[Set_event] = Fixate_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				stage = fixating;											// ...advance to the next stage.
				}
			else if (time() > fix_on_time + allowFixTime)				// But if time runs out...
				{
				trialOutcome = noFix;    									// TRIAL OUTCOME ABORT (no fixation)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen,...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Aborted (no fixation)\n");							// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}			
			}
			
			

	//--------------------------------------------------------------------------------------------
	// STAGE fixating (the subject is looking at the fixation point waiting for target onset)		
		else if (stage == fixating)
			{
			if (!In_FixWin)													// If the eyes stray out of the fixation window...
				{
				trialOutcome = brokeFix;									// TRIAL OUTCOME ABORT (broke fixation)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Aborted (broke fixation)\n");						// ...tell the user whats up...
				vwm_performance[18+setsize-1] = vwm_performance[18+setsize-1]+1; // ...update performance monitor
				trl_running = 0;											// ...and terminate the trial.
				}
			else if (In_FixWin && time() > aquire_fix_time + fixDuration)	// But if the eyes are still in the window at end of holdtime...
				{
				dsendf("vp %d\n",fixation_target_pd);						// ...flip the pg to the target with pd marker...	
				targ_time = time(); 										// ...record the time...
				Event_fifo[Set_event] = MemOn_;						// Queue strobe... #need to change 
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				dsendf("vp %d\n",fixation_target);						// ...flip the pg to the target with pd marker...	
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
					dsendf("vw %d\n",memRefresh-1);							// Wait so many vertical retraces (one is waited implicitly b/c photodiode marker above)...
					
				dsendf("vp %d\n",fixation);									// ...flip the pg to the fixation point without pd marker.
								
				

				oSetAttribute(object_targ, aVISIBLE); 						// ...show target in animated graph...
				//here also provide set size and loc info as eventcodes!
				Event_fifo[Set_event] = 10000+setsize;
				Set_event = (Set_event + 1) % Event_fifo_N;	
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				Event_fifo[Set_event] = 20000+LocArray[0];
				Set_event = (Set_event + 1) % Event_fifo_N;	
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				Event_fifo[Set_event] = 20000+LocArray[1];
				Set_event = (Set_event + 1) % Event_fifo_N;	
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				Event_fifo[Set_event] = 20000+LocArray[2];
				Set_event = (Set_event + 1) % Event_fifo_N;	
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				Event_fifo[Set_event] = 20000+LocArray[3];
				Set_event = (Set_event + 1) % Event_fifo_N;	
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				//Event_fifo[Set_event] = 20000+LocArray[4];
				//Set_event = (Set_event + 1) % Event_fifo_N;	
				//dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				Event_fifo[Set_event] = 30000+ColorArray[0];
				Set_event = (Set_event + 1) % Event_fifo_N;	
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				Event_fifo[Set_event] = 30000+ColorArray[1];
				Set_event = (Set_event + 1) % Event_fifo_N;	
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				Event_fifo[Set_event] = 30000+ColorArray[2];
				Set_event = (Set_event + 1) % Event_fifo_N;	
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				Event_fifo[Set_event] = 30000+ColorArray[3];
				Set_event = (Set_event + 1) % Event_fifo_N;	
				dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				//Event_fifo[Set_event] = 30000+ColorArray[4];
				//Set_event = (Set_event + 1) % Event_fifo_N;	
				//dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
				
														
				stage = targ_off;											// Advance to the next trial stage.				
				}
			}
			
			

	//--------------------------------------------------------------------------------------------
	// STAGE targ_off (the target has been presented and disappeared but the subject is still fixating)		
		else if (stage == targ_off)
			{		
			if (!In_FixWin)													// If the eyes leave the fixation window...
				{
				trialOutcome = saccEarly;									// TRIAL OUTCOME ERROR (sacc before cued to do so)
				
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (early saccade)\n");							// ...tell the user whats up...
				vwm_performance[18+setsize-1] = vwm_performance[18+setsize-1]+1; // ...update performance monitor
				trl_running = 0;											// ...and terminate the trial.
				}
			
			else if (In_FixWin &&  											// But if no saccade occurs...
				time() > targ_time + retDuration)	 							// ...and the stim onset asychrony passes...
				{
					nexttick;
					dsendf("vp %d\n",pd);	//test_pd									// Flip the pg to the blank screen with the photodiode marker...
					// dsendf("vp %d\n",target_pd);										// DELAY TASK  Flip the pg to the target screen with the photodiode marker...
					fix_off_time = time();										// ...and record the time that the fixation point was extinguished.
					test_on_time = time();
					Event_fifo[Set_event] = TestOn_;						// Queue strobe... #need to change 
					Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
					dsendf("XM RFRSH:\n"); 										// ...wait for one retrace cycle...
					dsendf("vp %d\n",test);									// ...flip the pg to the same screen without pd marker.
					dsendf("vw %d\n",testRefresh-1);							// Wait so many vertical retraces (one is waited implicitly b/c photodiode marker above)...
		
					// dsendf("vp %d\n",target);									// .DELAY TASK..flip the pg to the target screen without pd marker.
					oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
					stage = test_hold;

				}	
			}



	//--------------------------------------------------------------------------------------------
	// STAGE SAME (the fixation point has been turned off but the subject is still fixating)		
		else if (stage == test_hold)
			{
			if (!In_FixWin)													// If the eyes leave the fixation window...			
				{															// ...we have a saccade, so...
				trialOutcome = saccEarly;									// TRIAL OUTCOME ERROR (sacc before cued to do so)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (early saccade)\n");							// ...tell the user whats up...
				vwm_performance[18+setsize-1] = vwm_performance[18+setsize-1]+1; // ...update performance monitor
				trl_running = 0;											// ...and advance to the next stage.
				}
			
			else if (In_FixWin &&  											// But if no saccade occurs...
				time() > test_on_time + testHoldDuration) 					// ...and time for a saccade runs out...
				{
				//dsendf("vp %d\n",pd);									// Flip the pg to the blank screen...
				dsendf("vp %d\n",pd);//pd	
				test_off_time = time();										// ...and record the time that the fixation point was extinguished.
				Event_fifo[Set_event] = TestOff_;						// Queue strobe... #need to change 
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				if (samediff == 1)
						{
						stage = same;											// ...and advance to the next stage.
						}
					else if (samediff == 2)
						{
						stage = diff;
						}
				}	
	
			}			
			
	//--------------------------------------------------------------------------------------------
	// STAGE SAME (the fixation point has been turned off but the subject is still fixating)		
		else if (stage == same)
			{
			if (!In_FixWin)													// If the eyes leave the fixation window...			
				{															// ...we have a saccade, so...
				saccade_time = time();										// ...record the time...
				Event_fifo[Set_event] = Saccade_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				printf("                          rt = %d\n",saccade_time - fix_off_time);	// ...tell the user whats up...
				stage = in_flight;											// ...and advance to the next stage.
				}
			
			else if (In_FixWin &&  											// But if no saccade occurs...
				time() > test_off_time + saccadeInitiationDuration) 		// ...and time for a saccade runs out...
				{
				trialOutcome = miss;           							// TRIAL OUTCOME ERROR (no saccade after cue)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (miss)\n");								// ...tell the user whats up...
				trl_running = 0;											// ...and terminate the trial.
				}	
			}	
	//-------------------------------------------------------------------------------------------------------------------------------------
	// STAGE Diff (the fixation point has been turned off but the subject is still fixating)		
		else if (stage == diff)
			{
			if (!In_FixWin)													// If the eyes leave the fixation window...			
				{															// ...we have a saccade, so...
				trialOutcome = fa;  
				saccade_time = time();										// ...record the time...
				Event_fifo[Set_event] = Saccade_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				printf("                          rt = %d\n",saccade_time - fix_off_time);	// ...tell the user whats up...

				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (false alarm)\n");								// ...tell the user whats up...
				trl_running = 0;	
				}
			
			else if (In_FixWin &&  											// But if no saccade occurs...
				time() > fix_off_time + testDuration) 					// ...and time for a saccade runs out...
				{
				stage = on_target;											// ...and advance to the next stage of the trial.
				}	
			}				
			
			
	//--------------------------------------------------------------------------------------------
	// STAGE in_flight (eyes have left fixation window but have not entered target window)		
		else if (stage == in_flight)
			{
			if (In_TargWin)													// If the eyes get into the target window...
				{
				//dsendf("vp %d\n",blank);									// turn on the target again to reinforce the idea
				aquire_targ_time = time(); 									// ...record the time...
				Event_fifo[Set_event] = Decide_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				stage = on_target;											// ...and advance to the next stage of the trial.
				}
			else if (time() > saccade_time + testDuration)				// But, if the eyes are out of the target window and time runs out...
				{
				trialOutcome = hitIncSac;   									// TRIAL OUTCOME ERROR (innacurrate saccade)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (inaccurate saccade)\n");						// ...tell the user whats up...
				vwm_performance[6+setsize-1] = vwm_performance[6+setsize-1]+1; // ...update performance monitor
				trl_running = 0; 											// ...and terminate the trial.
				}
			}
		
		
		
	//--------------------------------------------------------------------------------------------
	// STAGE on_target (eyes have entered the target window.  will they remain there for duration?)	
		else if (stage == on_target)
			{
			if (!In_Targwin)													// If the eyes stray out of the fixation window...
				{			
				trialOutcome = brokeTarg;									// TRIAL OUTCOME ERROR (broke target fixation)
				dsendf("vp %d\n",blank);									// Flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				printf("Error (broke target fixation)\n");					// ...tell the user whats up...
				vwm_performance[12+setsize-1] = vwm_performance[12+setsize-1]+1; // ...update performance monitor
				trl_running = 0;											// ...and terminate the trial.
				}		
			else if (In_TargWin 											// But if the eyes are still in the target window...
				&&  time() > aquire_targ_time + targHoldtime)				// ...and the target hold time is up...				
				{
				trialOutcome = hitCorSac;									//TRIAL OUTCOME CORRECT (correct sacc trial)
				Event_fifo[Set_event] = Correct_;							// ...queue strobe...
				Set_event = (Set_event + 1) % Event_fifo_N;					// ...incriment event queue...
				printf("Correct (saccade)\n");								// ...tell the user whats up...
				vwm_performance[0+setsize-1] = vwm_performance[0+setsize-1]+1; // ...update performance monitor
				dsendf("vp %d\n",blank);									// ...flip the pg to the blank screen...
				oSetAttribute(object_targ, aINVISIBLE); 					// ...remove target from animated graph...
				oSetAttribute(object_fix, aINVISIBLE); 						// ...remove fixation point from animated graph...
				trl_running = 0;											// ...and terminate the trial.
				}			
			}
			
		nexttick;
		}
	}//--------------------------------------------------------------------------------------------------------------
// Wait a user defined number if micro-seconds.  (Just like wait() but 
// with micro instead of milli senoncds and obviously needing a spawnwait
// statement before it.
//
// ripped off by david.c.godlove@vanderbilt.edu 	January, 2011

declare WAIT_MU(int u_sec);

process WAIT_MU(int u_sec)			// uSec between 1 and 1000
	{
	int start, duration, clock_cycles;
	
	clock_cycles = u_sec * 1.192;	// Convert uSec to 1192000 Hz hardware clock cycles (this is approximate).
									// The PC clock does not count in true uSec.  It counts at a rate around
									// 1192000 Hz (give or take based on many variables).  Yours may differ 
									// from this estimate.  To find out use...
									// time1 = timeus();
									// nexttick;	
									// time2 = timeus();
									// cycles_per_ms = ((time2 - time1)/asets)/1000.0;
									// NOTE: This answer will be variable, so try it several times before... 
									// ...settling on an answer for good.
									// see pg 6-94.
	start = timeus();
	duration = 0;
	while (duration < clock_cycles)
		{
		duration = (timeus() - start) & 0xFFFF;
		}
	}// For use with a simple circuit which detects when the animal shifts
// weight in the chair.
// 
// written by david.c.godlove@vanderbilt.edu 	March, 2011
// adapted from WATCHMTH.pro

//declare checkBodyFlag	= 1;									// GLOBAL ALERT! Check body can be set to 0 to end this function
															// MOVED TO RIGSETUP.pro so that it can be toggled by rig
															
declare CheckMotion = 1;									// For turning on and off while task is running or not															
										

declare WATCHBOD();
	
process WATCHBOD()                                  		                                                                                                    
	{ 		
			
	declare body_channel	= 3;							// these should be set by rig setup but...
	declare sample_n        = 0;
	declare a_sets = 2;
			
 	while (checkBodyFlag & CheckMotion)		
		{
		sample_n = 0;
		while (sample_n < a_sets)
			{
			
			if (ctable_set(body_channel,sample_n,0))

				{
				if (Move_ct < Max_move_ct)
					{
					Move_ct = Move_ct + 1;
					}
				spawn TONE(toneAbort,toneDuration);		// present negative tone
				}


			sample_n = sample_n + 1;
			}
		nexttick;
		}
	}//----------------------------------------------------------------------
// WATCHEYE - This process monitors eye position.  It runs every process 
// cycle so it is important to minimize the computations done here.  
// WATCHEYE does the following:
//  1. updates ax, ay as the current analog values for X,Y position
//  2. maps ax,ay to x,y into degrees
//  3. calls LOCATE_I to monitor eyes in relation to target windows
//  4. moves the EYE object to the new x,y position
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011

											
#include C:\TEMPO\ProcLib\PGM\LOCATE_I.pro

declare Eye_on_VDOSync = 0;
declare CenterEyeNow = 0;

declare WATCHEYE();

process WATCHEYE()
    {
	
	declare hide float eye_x, eye_y, oldx, oldy;
	declare hide int lasttime, plot_x, plot_y;

	
    while (1)  														// From this moment until the end of eternity. (Did you know what you were starting?)                        
        {      
		
        eye_x = atable(eyeXChannel);             					// Get analog values
        eye_y = atable(eyeYChannel);
		
				
		eye_x = (eye_x * ((maxVoltage*2) / analogUnits) * eyeXGain) - eyeXOffset;	// Translate to degrees (x_ and eyeYGain values are set during calibration routine)
		eye_y = (eye_y * ((maxVoltage*2)  / analogUnits) * eyeYGain) - eyeYOffset;	
        
		if(CenterEyeNow)											// GLOBAL flag set by key press to center eye position
			{
			eyeXOffset = eyeXOffset + eye_x;
			eyeYOffset = eyeYOffset + eye_y;
			CenterEyeNow = 0;
			}
		
		plot_x = eye_x * deg2pix_X;
		plot_y = eye_Y * deg2pix_Y;
        if (plot_x != oldx || plot_y != oldy)     					// If position has changed..
            {
			
						
			spawn LOCATE_I(eye_x,									//...figure out where the eyes are in relation to stim...
						eye_y);
							
		
			
			if(time() > lasttime + 16)								//...and if more than a single refresh has gone by...
				{
				
				oMove(object_eye, plot_x, plot_y);            		// ..update eye object...
				if (Eye_on_VDOSync)
					{
					dsendf("cl;\n");
					dsendf("ru %d,%d,%d,%d;\n",plot_x-4,(-1*plot_y)-4,plot_x+3,(-1*plot_y)+3); // .. and move vdosync location (could be good for debugging).
					dsendf("co %d;\n",5);
					}
				lasttime = time();
				oldx = plot_x;                   					// This is the new position.
				oldy = plot_y;
				}					
			}
            
        nexttick;
		
        }
    }
// code for use with PELCO MD2001 Motion Detector
// when inactive (still)+10v. when active (moving) motion is detected and ~0v 
// the unit will automatically reset to inactive after motion ceases.
// the dip switches on the rear of the unit define the reset interval.
// currently set to 1/2 sec (shortest interval availible). so motions 
// less than 1/2 second apart will not be detected as separate events.
// 
// written by david.c.godlove@vanderbilt.edu 	March, 2011
// borrowed heavily from code by EEE

// declare checkMouthFlag = 1;									// GLOBAL ALERT! Check mouth can be set to 0 to end this function
															// MOVED TO RIGSETUP.pro so can be toggled in different rigs.
															
declare CheckMotion = 1;									// For turning on and off while task is running or not

declare WATCHMTH();
	
process WATCHMTH()                                  		                                                                                                    
	{ 		
			
	declare mouth_channel	= 3;							// these should be set by rig setup but...
	declare mouth_thresh	= 13720;						// ...what's the point since they quit making this motion detector.
	declare still			= 0;		
	declare moving			= 1;	
	declare mouth_status	= still;		
	declare last_status		= still;
	declare mouth;
	declare mouth_time;	
			
			
	if (atable(mouth_channel) < mouth_thresh)				// check to see if mouth is already moving when WATCHMTH() is first called
		{		
		mouth_status	= moving;							// initial status is moving
		last_status		= moving;		
		}		
		
		while (checkMouthFlag & CheckMotion)		
			{
			mouth = atable(mouth_channel);
			if (mouth < mouth_thresh)							// what is the current status of the mouth?
				{
				mouth_status = moving;
				if (TrainingStill)								// if we are using the motion detector to train the monk to be still instead
						{
						if (time() > mouth_time + 200)
							{
							spawn TONESWEP();					// present negative tone which can be distingueshed from task tones
							if (Move_ct < Max_move_ct)
								{
								Move_ct = Move_ct + 1;			// and increase the timeout counter
								mouth_time = time();
								}						
							}					
						}
				}
			else if (mouth >= mouth_thresh)
				{
				mouth_status = still;
				}
			
			if (mouth_status != last_status)					// did a change in the status occur on this interation?
				{
				if (mouth_status == moving)
					{
					Event_fifo[Set_event] = MouthBegin_;		// queue TrialStart_ strobe
					Set_event = (Set_event + 1) % Event_fifo_N;	// incriment event queue
					}
				else if (mouth_status == still)
					{
					Event_fifo[Set_event] = MouthEnd_;			// queue TrialStart_ strobe
					Set_event = (Set_event + 1) % Event_fifo_N;	// incriment event queue
					}
				last_status = mouth_status;
				}
			nexttick;
			}
		}
//----------------------------------------------------------------------------------------------------
// Process for locating fixation and target window locations.
//
// written by david.c.godlove@vanderbilt.edu 	January, 2011
// 11-2011: Integrated choice countermanding task into ALL_PROS.pro. -pgm

declare hide float Fix_win_left;	
declare hide float Fix_win_right;		
declare hide float Fix_win_down;	
declare hide float Fix_win_up;	
declare hide float Targ_win_left;		
declare hide float Targ_win_right;	
declare hide float Targ_win_down;
declare hide float Targ_win_up;
declare hide float Dist_win_left;		// For Choice countermanding task
declare hide float Dist_win_right;	
declare hide float Dist_win_down;
declare hide float Dist_win_up;
declare hide float Chkr_win_left;		// For Choice countermanding task
declare hide float Chkr_win_right;	
declare hide float Chkr_win_down;
declare hide float Chkr_win_up;
declare hide float highBet_win_left;		// For Betting tasks
declare hide float highBet_win_right;	
declare hide float highBet_win_down;
declare hide float highBet_win_up;
declare hide float lowBet_win_left;		// For Betting tasks
declare hide float lowBet_win_right;	
declare hide float lowBet_win_down;
declare hide float lowBet_win_up;
declare hide float Dist1_win_left;		// For Choice countermanding task
declare hide float Dist1_win_right;	
declare hide float Dist1_win_down;
declare hide float Dist1_win_up;
declare hide float Dist2_win_left;		// For Choice countermanding task
declare hide float Dist2_win_right;	
declare hide float Dist2_win_down;
declare hide float Dist2_win_up;
declare hide float Dist3_win_left;		// For Choice countermanding task
declare hide float Dist3_win_right;	
declare hide float Dist3_win_down;
declare hide float Dist3_win_up;
     
     
     
              
declare WINDOWS();						// see SETC_TRL

process WINDOWS()						// see SETC_TRL
{
declare hide float fixX, fixY,
				targX, targY,
				distX, distY,
				chkrX, chkrY,
				dist1X, dist1Y,
				dist2X, dist2Y,
				dist3X, dist3Y,
				hbetX, hbetY,
				lbetX, lbetY,
				old_fix_win_size,
				old_targ_win_size,
				old_chkr_win_size,
				old_bet_win_size;
declare int i;




// find the center of the fixation spot in x and y space based on the angle and eccentricity	
fixX		= cos(fixAngle) * fixAmp;
fixY		= sin(fixAngle) * fixAmp * -1;
oMove(object_fix, fixX*deg2pix_X , fixY*deg2pix_Y); //move the animated graph window to location
oMove(object_fixwin, fixX*deg2pix_X , fixY*deg2pix_Y); //move the animated graph window to location
oSetAttribute(object_fix, aSIZE, 1*deg2pix_X, 1*deg2pix_Y);									


// find the center of the target in x and y space based on the angle and eccentricity
targX			= cos(targAngle) * targAmp;
targY			= sin(targAngle) * targAmp * -1;
oMove(object_targwin, targX*deg2pix_X , targY*deg2pix_Y); //move the animated graph window to location
oMove(object_targ, targX*deg2pix_X , targY*deg2pix_Y); //move the animated graph window to location
oSetAttribute(object_targ, aSIZE, targSize*deg2pix_X, targSize*deg2pix_Y);							// while we are at it, resize fixation object on animated graph


// Dynamically change the target window when the amplitude varies:
if (randomAmpFlag)
	{
	targwinSize = 4 + targAmp * .4;
	} 

// calculate the params of the fixation window
Fix_win_left 	= fixX - fixWinSize/2;					
Fix_win_right 	= fixX + fixWinSize/2;				
Fix_win_down 	= fixY + fixWinSize/2;
Fix_win_up		= fixY - fixWinSize/2;

// calculate the params of the target window
Targ_win_left	= targX - targWinSize/2;
Targ_win_down	= targY + targWinSize/2;
Targ_win_right	= targX + targWinSize/2;
Targ_win_up		= targY - targWinSize/2;

// If running choice countermanding, get distractor and chekered stimulus  window parameters, too
if (State == stateCCM)
	{
	// Move the distractor window to its location
	distX			= cos(distAngle) * distAmp;
	distY			= sin(distAngle) * distAmp * -1;
	oMove(object_distwin, distX*deg2pix_X , distY*deg2pix_Y); // move the animated graph window to location
	
	// calculate the params of the distractor window... pgm: for now the distractor is 180 degrees opposite from target
	Dist_win_left	= distX - targWinSize/2;
	Dist_win_down	= distY + targWinSize/2;
	Dist_win_right	= distX + targWinSize/2;
	Dist_win_up		= distY - targWinSize/2;
	
	// pgm: find the center of the checkered stimulus in x and y space based on the angle and eccentricity
	chkrX		= cos(checkerAngle) * checkerAmp;
	chkrY		= -1 * sin(checkerAngle) * checkerAmp;
	oMove(object_chkrwin, chkrX*deg2pix_X , chkrY*deg2pix_Y); //move the animated graph window to location
	oMove(object_checker, chkrX*deg2pix_X , chkrY*deg2pix_Y); //move the animated graph window to location

	// pgm: calculate the params of the checkered stimulus window
	Chkr_win_left	= chkrX - chkrWinSize/2;
	Chkr_win_down	= chkrY + chkrWinSize/2;
	Chkr_win_right	= chkrX + chkrWinSize/2;
	Chkr_win_up		= chkrY - chkrWinSize/2;
	}


// Need to move the mask (non-target) windows to their locations... 
if (State == stateMCM)
	{
	if (trialType != tBetTrial)
		{
		// Always at least 1 other mask location	
		dist1X	= cos(maskAngleArray[distIndex1]) * maskAmpArray[distIndex1];
		dist1Y	= -1 * sin(maskAngleArray[distIndex1]) * maskAmpArray[distIndex1];
		oMove(object_distwin1, dist1X*deg2pix_X , dist1Y*deg2pix_Y); //move the animated graph window to location

		// pgm: calculate the params of the 1st distractor window
		dist1_win_left	= dist1X - targWinSize/2;
		dist1_win_down	= dist1Y + targWinSize/2;
		dist1_win_right	= dist1X + targWinSize/2;
		dist1_win_up	= dist1Y - targWinSize/2;

		// Sometimes there 4 mask locations- need the other 2 distractors here	
		if (nTarg == 4)
			{
			dist2X	= cos(maskAngleArray[distIndex2]) * maskAmpArray[distIndex2];
			dist2Y	= -1 * sin(maskAngleArray[distIndex2]) * maskAmpArray[distIndex2];
			oMove(object_distwin2, dist2X*deg2pix_X , dist2Y*deg2pix_Y); //move the animated graph window to location

			dist3X	= cos(maskAngleArray[distIndex3]) * maskAmpArray[distIndex3];
			dist3Y	= -1 * sin(maskAngleArray[distIndex3]) * maskAmpArray[distIndex3];
			oMove(object_distwin3, dist3X*deg2pix_X , dist3Y*deg2pix_Y); //move the animated graph window to location

			// pgm: calculate the params of the 2nd distractor window
			dist2_win_left	= dist2X - targWinSize/2;
			dist2_win_down	= dist2Y + targWinSize/2;
			dist2_win_right	= dist2X + targWinSize/2;
			dist2_win_up	= dist2Y - targWinSize/2;
		
			// pgm: calculate the params of the 3rd distractor stimulus window
			dist3_win_left	= dist3X - targWinSize/2;
			dist3_win_down	= dist3Y + targWinSize/2;
			dist3_win_right	= dist3X + targWinSize/2;
			dist3_win_up	= dist3Y - targWinSize/2;
			}
			
		// if the user changes the size of the fix window update the graph
		if (nTrial == 1			||
			targWinSize != old_targ_win_size)
			{
			oSetAttribute(object_targwin, aSIZE, targWinSize*Deg2pix_X, targWinSize*Deg2pix_Y);
			oSetAttribute(object_targwin, aVISIBLE);
			oSetAttribute(object_distwin1, aSIZE, targWinSize*Deg2pix_X, targWinSize*Deg2pix_Y);
			oSetAttribute(object_distwin1, aVISIBLE);
			if (nTarg == 4)
				{
				oSetAttribute(object_distwin2, aSIZE, targWinSize*Deg2pix_X, targWinSize*Deg2pix_Y);
				oSetAttribute(object_distwin2, aVISIBLE);
				oSetAttribute(object_distwin3, aSIZE, targWinSize*Deg2pix_X, targWinSize*Deg2pix_Y);
				oSetAttribute(object_distwin3, aVISIBLE);
				}
			old_targ_win_size = targWinSize;
			}
		}
	if (trialType != tMaskTrial)
		{
		hbetX = cos(highBetAngle) * highBetAmp;												// find the center of the box in x and y space based on the targAngle and targAmp...
		hbetY = sin(highBetAngle) * highBetAmp * -1;
		oMove(object_highBet, hbetX*deg2pix_X, hbetY*deg2pix_Y);								// ...and move the animated graph object there.
		oMove(object_highBetwin, hbetX*deg2pix_X, hbetY*deg2pix_Y);								// ...and move the animated graph object there.
		oSetAttribute(object_highBet, aSIZE, targSize*deg2pix_X, targSize*deg2pix_Y);				// while we are at it, resize fixation object on animated graph
	
		highBet_win_left	= hbetX - betWinSize/2;
		highBet_win_down	= hbetY + betWinSize/2;
		highBet_win_right	= hbetX + betWinSize/2;
		highBet_win_up	= hbetY - betWinSize/2;

		lbetX = cos(lowBetAngle) * lowBetAmp;												// find the center of the box in x and y space based on the targAngle and targAmp...
		lbetY = sin(lowBetAngle) * lowBetAmp * -1;
		oMove(object_lowBet, lbetX*deg2pix_X, lbetY*deg2pix_Y);								// ...and move the animated graph object there.
		oMove(object_lowBetwin, lbetX*deg2pix_X, lbetY*deg2pix_Y);								// ...and move the animated graph object there.
		oSetAttribute(object_lowBet, aSIZE, targSize*deg2pix_X, targSize*deg2pix_Y);					// while we are at it, resize fixation object on animated graph

		lowBet_win_left	= lbetX - betWinSize/2;
		lowBet_win_down	= lbetY + betWinSize/2;
		lowBet_win_right	= lbetX + betWinSize/2;
		lowBet_win_up	= lbetY - betWinSize/2;

		// if the user changes the size of the bet window update the graph
		if (nTrial == 1			||
			betWinSize != old_bet_win_size)
			{
			oSetAttribute(object_highBetWin, aSIZE, betWinSize*Deg2pix_X, betWinSize*Deg2pix_Y);
			oSetAttribute(object_highBetWin, aVISIBLE);
			oSetAttribute(object_lowBetWin, aSIZE, betWinSize*Deg2pix_X, betWinSize*Deg2pix_Y);
			oSetAttribute(object_lowBetWin, aVISIBLE);
			old_bet_win_size = betWinSize;
			}
		}
	}

	
// if the user changes the size of the fix window update the graph
if (nTrial == 1			||
	fixWinSize != old_fix_win_size)
	{
	oSetAttribute(object_fixwin, aSIZE, fixWinSize*Deg2pix_X, fixWinSize*Deg2pix_Y);
	oSetAttribute(object_fixwin, aVISIBLE);
	old_fix_win_size = fixWinSize;
	}
	
// if the user changes the size of the targ window update the graph
if (nTrial == 1			||
	targWinSize != old_targ_win_size)
	{
	oSetAttribute(object_targwin, aSIZE, targWinSize*Deg2pix_X, targWinSize*Deg2pix_Y);
	oSetAttribute(object_targwin, aVISIBLE);
	old_targ_win_size = targWinSize;
	
	// For choice countermanding task, do the same for the distractor window
	if (State == stateCCM)
		{
		oSetAttribute(object_distwin, aSIZE, targWinSize*Deg2pix_X, targWinSize*Deg2pix_Y);
		oSetAttribute(object_distwin, aVISIBLE);
		}
	}
	
// For choice countermanding task: if the user changes the size of the stimulus window update the graph
if (State == stateCCM)
	{
	if (nTrial == 1			||
		chkrWinSize != old_chkr_win_size)
		{
		oSetAttribute(object_chkrwin, aSIZE, chkrWinSize*Deg2pix_X, chkrWinSize*Deg2pix_Y);
		oSetAttribute(object_chkrwin, aVISIBLE);
		old_chkr_win_size = chkrWinSize;
		}
	}
if (state == stateVWM) //(State == stateVWM)
	{

	if (samediff == 1) //same
		{
		testColor = ColorArray[0];
		targAngle = LocArray[0];
		targAmp = testAmp;
			
		}
	else if (samediff == 2) //diff
		{
		testColor = ColorArray[6];
		targAngle = 0;
		targAmp = testAmp;
		}
	
	// find the center of the fixation spot in x and y space based on the angle and eccentricity	
	// fixX		= cos(fixAngle) * fixAmp;
	// fixY		= sin(fixAngle) * fixAmp * -1;
	// oMove(object_fix, fixX*deg2pix_X , fixY*deg2pix_Y); //move the animated graph window to location
	// oMove(object_fixwin, fixX*deg2pix_X , fixY*deg2pix_Y); //move the animated graph window to location
	// oSetAttribute(object_fix, aSIZE, 1*deg2pix_X, 1*deg2pix_Y);									


	// find the center of the target in x and y space based on the angle and eccentricity
	printf("targAngle = %d\n",targAngle);
	targX			= cos(targAngle) * targAmp;
	targY			= sin(targAngle) * targAmp * -1;
	oMove(object_targwin, targX*deg2pix_X , targY*deg2pix_Y); //move the animated graph window to location
	oMove(object_targ, targX*deg2pix_X , targY*deg2pix_Y); //move the animated graph window to location
	oSetAttribute(object_targ, aSIZE, targSize*deg2pix_X, targSize*deg2pix_Y);	
	
	// calculate the params of the fixation window
	Fix_win_left 	= fixX - fixWinSize/2;					
	Fix_win_right 	= fixX + fixWinSize/2;				
	Fix_win_down 	= fixY + fixWinSize/2;
	Fix_win_up		= fixY - fixWinSize/2;

	// calculate the params of the target window
	Targ_win_left	= targX - targWinSize/2;
	Targ_win_down	= targY + targWinSize/2;
	Targ_win_right	= targX + targWinSize/2;
	Targ_win_up		= targY - targWinSize/2;	
	
	}
}